********************************************************************************
* TurboAss                                                                     *
* ©1989/90 ∑-soft, written Sören Hellwig & Markus Fritze                       *
********************************************************************************
                OPT X-,F+,O+,W+
version         EQU $0170       ;Version<$200 ist die Grundversion
sprache         EQU 0           ;0=Deutsch, 1=Englisch
menu_offset     EQU 2           ;reservierte Zeilen am Bildschirmstart
part_anz        EQU 999         ;max. Anzahl von PARTs
slider          EQU 0           ;<>0: Slider vorhanden
slsize          EQU 3           ;Breite des Sliders in Zeichenpositionen
max_scrlines    EQU 70          ;maximale Anzahl an Bildschirmzeilen
                DEFAULT 2
                OUTPUT 'TURBOASS.PRG'
************************************************************************
*   Programmstart                                                      *
************************************************************************
                >PART 'AES/VDI-Library-EQUs'
************************************************************************
* Die AES-"Library"                                                    *
************************************************************************
appl_init       EQU $0A000100
appl_read       EQU $0B020101
appl_write      EQU $0C020101
appl_find       EQU $0D000101
appl_tplay      EQU $0E020101
appl_trecord    EQU $0F010101
appl_bvset      EQU $10020100   ;ab GEM 2.0
appl_yield      EQU $11000100   ;ab GEM 2.0
appl_exit       EQU $13000100

evnt_keybd      EQU $14000100
evnt_button     EQU $15030500
evnt_mouse      EQU $16050500
evnt_mesag      EQU $17000101
evnt_timer      EQU $18020100
evnt_multi      EQU $19100701
evnt_dclick     EQU $1A020100

menu_bar        EQU $1E010101
menu_icheck     EQU $1F020101
menu_ienable    EQU $20020101
menu_tnormal    EQU $21020101
menu_text       EQU $22010102
menu_register   EQU $23010101
menu_unregister EQU $24010100   ;ab GEM 2.0

objc_add        EQU $28020101
objc_delete     EQU $29010101
objc_draw       EQU $2A060101
objc_find       EQU $2B040101
objc_offset     EQU $2C010301
objc_order      EQU $2D020101
objc_edit       EQU $2E040201
objc_change     EQU $2F080101

form_do         EQU $32010101
form_dial       EQU $33090100
form_alert      EQU $34010101
form_error      EQU $35010100
form_center     EQU $36000501
form_keybd      EQU $37030301
form_button     EQU $38020201

graf_rubberbox  EQU $46040300
graf_rubbox     EQU $46040300   ;dies ist der richtige Name!
graf_dragbox    EQU $47080300
graf_movebox    EQU $48060100
graf_mbox       EQU $48060100   ;dies ist der richtige Name!
graf_growbox    EQU $49080100
graf_shrinkbox  EQU $4A080100
graf_watchbox   EQU $4B040101
graf_slidebox   EQU $4C030101
graf_handle     EQU $4D000500
graf_mouse      EQU $4E010101
graf_mkstate    EQU $4F000500

srcp_read       EQU $50000101
srcp_write      EQU $51000101
scrp_clear      EQU $52000100   ;ab GEM 2.0

fsel_input      EQU $5A000202
fsel_exinput    EQU $5B000203   ;ab TOS 1.4

wind_create     EQU $64050100
wind_open       EQU $65050100
wind_close      EQU $66010100
wind_delete     EQU $67010100
wind_get        EQU $68020500
wind_set        EQU $69060100
wind_find       EQU $6A020100
wind_update     EQU $6B010100
wind_calc       EQU $6C060500
wind_new        EQU $6D000000   ;ab TOS 1.4

rsrc_load       EQU $6E000101
rsrc_free       EQU $6F000100
rsrc_gaddr      EQU $70020100
rsrc_saddr      EQU $71020101
rsrc_obfix      EQU $72010101

shel_read       EQU $78000102
shel_write      EQU $79030102
shel_get        EQU $7A010101
shel_put        EQU $7B010101
shel_find       EQU $7C000101
shel_envrn      EQU $7D000102
shel_rdef       EQU $7E000102   ;ab GEM 2.0
shel_wdef       EQU $7F000002   ;ab GEM 2.0

xgrf_stepcalc   EQU $82060600   ;ab GEM 2.0
xgrf_2box       EQU $83090100   ;ab GEM 2.0

; Die Messages des AES
MN_SELECTED     EQU 10          ;Menüeintrag angewählt
WM_REDRAW       EQU 20          ;Teil eines Windows muß neu gezeichnet werden
WM_TOPPED       EQU 21          ;Window ist nun das aktuelle Fenster
WM_CLOSED       EQU 22          ;Window soll geschlossen werden
WM_FULLED       EQU 23          ;Window soll auf max.Größe gebracht werden
WM_ARROWED      EQU 24          ;Scollbalken angeklickt
WM_HSLID        EQU 25          ;Der horizontale Slider wurde bewegt
WM_VSLID        EQU 26          ;Der vertikale Slider wurde bewegt
WM_SIZED        EQU 27          ;Die Größe des Windows wurde geändert
WM_MOVED        EQU 28          ;Das Window wurde bewegt
WM_NEWTOP       EQU 29          ;Das Fenster wurde aktiviert (siehe WM_TOPPED)
WM_UNTOPPED     EQU 30          ;Der Fenster wird gleich inaktiv (erst ab GEM 2.0!)
AC_OPEN         EQU 40          ;Ein Acc wurde angeklickt.(30 bzw. 31 ist FALSCH!)
AC_CLOSE        EQU 41          ;Prg wurde beendet, ACC soll seinen Speicher freigeben.
CT_UPDATE       EQU 50
CT_MOVE         EQU 51          ;Funktion unbekannt
CT_NEWTOP       EQU 52

; WM_ARROWED angeklickt (nun die genauere Definition)
WA_UPPAGE       EQU 0           ;Balken oberhalb des Sliders
WA_DNPAGE       EQU 1           ;Balken unterhalb des Sliders
WA_UPLINE       EQU 2           ;Pfeil nach oben
WA_DNLINE       EQU 3           ;Pfeil nach unten
WA_LFPAGE       EQU 4           ;Balken links vom Slider
WA_RTPAGE       EQU 5           ;Balken rechts vom Slider
WA_LFLINE       EQU 6           ;Pfeil nach links
WA_RTLINE       EQU 7           ;und Pfeil nach rechts

; Die Objekttypen des Resource-Baumes
G_BOX           EQU 20
G_TEXT          EQU 21
G_BOXTEXT       EQU 22
G_IMAGE         EQU 23
G_PROGDEF       EQU 24
G_IBOX          EQU 25          ;Bitte in entsprechender Literatur nachschlagen
G_BUTTON        EQU 26
G_BOXCHAR       EQU 27
G_STRING        EQU 28
G_FTEXT         EQU 29
G_FBOXTEXT      EQU 30
G_ICON          EQU 31
G_TITLE         EQU 32

; Object-Flags bei einem Objekt
NONE_FLG        EQU $00
SELECTABLE_FLG  EQU $01
DEFAULT_FLG     EQU $02
EXIT_FLG        EQU $04
EDITABLE_FLG    EQU $08
RBUTTON_FLG     EQU $10         ;Bitte ebenfalls in der Literatur nachlesen
LASTOB_FLG      EQU $20
TOUCHEXIT_FLG   EQU $40
HIDETREE_FLG    EQU $80
INDIRECT_FLG    EQU $0100

; Objekt-Status bei einem Objekt
NORMAL          EQU $00
SELECTED        EQU $01
CROSSED         EQU $02
CHECKED         EQU $04         ;s.o.
DISABLED        EQU $08
OUTLINED        EQU $10
SHADOWED        EQU $20

; Die einzelnen Bits bei evnt_multi()
MU_KEYBD        EQU $01         ;Tastaturereignis
MU_BUTTON       EQU $02         ;Maustastenereignis
MU_M1           EQU $04         ;1.Mausereignis
MU_M2           EQU $08         ;2.Mausereignis
MU_MESAG        EQU $10         ;Message des AES
MU_TIMER        EQU $20         ;Timer-Ereignis

; form_dial()
FMD_START       EQU $00         ;Bildschirmhintergrund reservieren
FMD_GROW        EQU $01         ;Ausdehnende Box zeichnen
FMD_SHRINK      EQU $02         ;Schrumpfende Box zeichnen
FMD_FINISH      EQU $03         ;Bildschirmbereich wieder freigeben

; graf_mouse()
ARROW           EQU $00
TEXT_CRSR       EQU $01
HOURGLASS       EQU $02
BUSYBEE         EQU $02
POINT_HAND      EQU $03
FLAT_HAND       EQU $04
THIN_CROSS      EQU $05
THICK_CROSS     EQU $06
OUTL_CROSS      EQU $07
USER_DEF        EQU $FF
M_OFF           EQU $0100
M_ON            EQU $0101

; Parameter bei wind_create()
WI_NAME         EQU $01
WI_CLOSE        EQU $02
WI_FULL         EQU $04
WI_MOVE         EQU $08
WI_INFO         EQU $10
WI_SIZE         EQU $20
WI_UPARROW      EQU $40
WI_DNARROW      EQU $80
WI_VSLIDE       EQU $0100
WI_LFARROW      EQU $0200
WI_RARROW       EQU $0400
WI_HSLIDE       EQU $0800

; Parameter bei wind_get() & wind_set()
WF_KIND         EQU 1
WF_NAME         EQU 2
WF_INFO         EQU 3
WF_WORKXYWH     EQU 4
WF_CURRXYWH     EQU 5
WF_PREVXYWH     EQU 6
WF_FULLXYWH     EQU 7
WF_HSLIDE       EQU 8
WF_VSLIDE       EQU 9
WF_TOP          EQU 10
WF_FIRSTXYWH    EQU 11
WF_NEXTXYWH     EQU 12
WF_NEWDESK      EQU 14
WF_HSLSIZE      EQU 15
WF_VSLSIZE      EQU 16

; wind_update()
END_UPDATE      EQU 0
BEG_UPDATE      EQU 1
END_MCTRL       EQU 2
BEG_MCTRL       EQU 3

************************************************************************
* Die VDI-"Library"                                                    *
* Wer näheres dazu wissen möchte, sollte sich im Profibuch von Sybex   *
* die Informationen dazu besorgen.                                     *
************************************************************************
;1. Kontrollfunktionen
v_opnwk         EQU $010B0000   ;Open workstation
v_clswk         EQU $02         ;Close workstation
v_opnvwk        EQU $640B0000   ;Open virtual screen workstation
v_clsvwk        EQU $65         ;Close virtual screen workstation
v_clrwk         EQU $03         ;Clear workstation
v_updwk         EQU $04         ;Update workstation
vst_load_fonts  EQU $77010000   ;Load fonts
unload_fonts    EQU $78010000   ;Unload fonts
vs_clip         EQU $81010002   ;Set clipping rectangle
;2. Ausgabefunktionen
v_pline         EQU $06000000   ;Polyline (Byte 0=count(n))
v_pmarker       EQU $07000000   ;Polymarker (Byte 0=count(n))
v_gtext         EQU $08000001   ;Text (Byte 2=n)
v_fillarea      EQU $09000000   ;Filled area (Byte 0=count(n))
v_cellarray     EQU $0A000002   ;Cell array (Byte 2=n)
v_contourfill   EQU $67010001   ;Contour fill
vr_recfl        EQU $72000002   ;Fill rectangle
v_bar           EQU $0B000102   ;Bar
v_arc           EQU $0B020204   ;Arc
v_pieslice      EQU $0B020304   ;Pie
v_circle        EQU $0B000403   ;Circle
v_ellipse       EQU $0B000502   ;Ellipse
v_ellarc        EQU $0B020602   ;Elliptical arc
v_ellpie        EQU $0B020702   ;Elliptical pie
v_rbox          EQU $0B000802   ;Rounded rectangle
v_rfbox         EQU $0B000902   ;Filled rounded rectangle
v_justified     EQU $0B020A02   ;Justified graphics text (Byte 2=n+2)
;3. Attribut-Funktionen
vswr_mode       EQU $20010000   ;Set writing mode
vs_color        EQU $0E040000   ;Set color representation
vsl_type        EQU $0F010000   ;Set polyline line type
vsl_udsty       EQU $71010000   ;Set user-defined line style pattern
vsl_width       EQU $10000001   ;Set polyline line width
vsl_color       EQU $11010000   ;Set polyline color index
vsl_ends        EQU $6C020000   ;Set polyline end styles
vsm_type        EQU $12010000   ;Set polymarker type
vsm_height      EQU $13000001   ;Set polymarker height
vsm_color       EQU $14010000   ;Set polymarker color index
vst_height      EQU $0C000001   ;Set character height, absolute mode
vst_point       EQU $6B010000   ;Set character height, points mode
vst_rotation    EQU $0D010000   ;Set character baseline vector
vst_font        EQU $15010000   ;Set text face
vst_color       EQU $16010000   ;Set graphic text color index
vst_effects     EQU $6A010000   ;Set graphic text special effects
vst_alignment   EQU $27020000   ;Set graphic text alignment
vsf_interior    EQU $17010000   ;Set fill interior index
vsf_style       EQU $18010000   ;Set fill style index
vsf_color       EQU $19010000   ;Set fill color index
vsf_perimeter   EQU $68010000   ;Set fill perimeter visibility
vsf_udpat       EQU $70000000   ;Set user-defined fill pattern (Byte 2=16*planes)
;4. Rasteroperationen
vro_cpyfm       EQU $6D010004   ;Copy raster, opaque
vrt_cpyfm       EQU $79030004   ;Copy raster, transparent
vr_trnfm        EQU $6E000000   ;Transform form
v_get_pixel     EQU $69000001   ;Get pixel
;5. Eingabefunktionen
vsin_mode       EQU $21020000   ;Set input mode
vrq_locator     EQU $1C000001   ;Input locator, request mode
vsm_locator     EQU $1C000001   ;Input locator, sample mode
vrq_valuator    EQU $1D010000   ;Input valuator, request mode
vsm_valuator    EQU $1D010000   ;Input valuator, sample mode
vrq_choice      EQU $1E010000   ;Input choice, request mode
vsm_choice      EQU $1E010000   ;Input choice, sample mode
vrq_string      EQU $1F020001   ;Input string, request mode
vsm_string      EQU $1F020001   ;Input string, sample mode
vsc_form        EQU $6F250000   ;Set mouse form
vex_timv        EQU $76         ;Exchange timer interrupt vector
v_show_c        EQU $7A010000   ;Show cursor
v_hide_c        EQU $7B         ;Hide cursor
vq_mouse        EQU $7C         ;Sample mouse button state
vex_butv        EQU $7D         ;Exchange button change vector
vex_motv        EQU $7E         ;Exchange mouse movement vector
vex_curv        EQU $7F         ;Exchange cursor change vector
vq_key_s        EQU $80000000   ;Sample keyboard state information
;6. Auskunftsfunktionen
vq_extnd        EQU $66010000   ;Extended inquire function
vq_color        EQU $1A020000   ;Inquire color representation
vql_attributes  EQU $23         ;Inquire current polyline attributes
vqm_attributes  EQU $24         ;Inquire current polymarker attributes
vqf_attributes  EQU $25         ;Inquire current fill area attributes
vqt_attributes  EQU $26         ;Inquire current graphic text attributes
vqt_extent      EQU $74         ;Inquire text extent (Byte 2=n)
vqt_width       EQU $75010000   ;Inquire character cell width
vqt_name        EQU $82010000   ;Inquire face name and index
vq_cellarray    EQU $1B000002   ;Inquire cell array
vqin_mode       EQU $73010000   ;Inquire input mode
vqt_fontinfo    EQU $83000000   ;Inquire current face information
vqt_justified   EQU $84020002   ;Inquire just.graph.text (Byte 2=n+2) GEM 2.0!
;7. Escapes
vq_chcells      EQU $05000100   ;Inquire addressable alpha character cells
v_exit_cur      EQU $05000200   ;Exit alpha mode
v_enter_cur     EQU $05000300   ;Enter alpha mode
v_curup         EQU $05000400   ;Alpha cursor up
v_curdown       EQU $05000500   ;Alpha cursor down
v_curright      EQU $05000600   ;Alpha cursor right
c_curleft       EQU $05000700   ;Alpha cursor left
v_curhome       EQU $05000800   ;Home alpha cursor
v_eeos          EQU $05000900   ;Erase to end of alpha screen
v_eeol          EQU $05000A00   ;Erase to end of alpha text line
v_curaddress    EQU $05020B00   ;Direct alpha cursor address
v_curtext       EQU $05000C00   ;Output cursor addressable alpha text (Byte 2=n)
v_rvon          EQU $05000D00   ;Reverse video on
v_rvoff         EQU $05000E00   ;Reverse video off
vq_curaddress   EQU $05000F00   ;Inquire current alpha cursor address
vq_tabstatus    EQU $05001000   ;Inquire tablet status
v_hardcopy      EQU $05001100   ;Hardcopy
v_dspcur        EQU $05001201   ;Place graphic cursor at location
v_rmcur         EQU $05001300   ;Remove last graphic cursor
v_form_adv      EQU $05001400   ;Form advance
v_output_window EQU $05001500   ;Output window
v_clear_disp_list EQU $05001600 ;Clear display list
v_bit_image     EQU $05051702   ;Output bit image file (Byte 2=n+5)
vq_scan         EQU $05001800   ;Inquire printer scan
v_alpha_text    EQU $05001900   ;Output alpha text (Byte 2=n)
vs_palette      EQU $05013C00   ;Select palette
v_sound         EQU $05023D00   ;Generate specified tone
vs_mute         EQU $05013E00   ;Set/clear tone muting flag
vt_resolution   EQU $05025100   ;Set tablet axis resolution in lines/inch
vt_axis         EQU $05025200   ;Set table axis resolution in lines
vt_origin       EQU $05025300   ;Set tablet x and y origin
vq_tdimensions  EQU $05005400   ;Return tablet x and y dimensions
vt_alignment    EQU $05025500   ;Set tablet alignment
vsp_film        EQU $05025B00   ;Set camera file type and exposure time
vqp_filename    EQU $05015C00   ;Inquire camera file name
vsc_expose      EQU $05015D00   ;Disable or enable file exposure for frame preview
v_meta_extents  EQU $05006202   ;Update metafile extents
v_write_meta    EQU $05006300   ;Write metafile item (Byte 0=num_ptsin, Byte 2=num_intin)
vm_pagesize     EQU $05036300   ;Physical page size
wm_coords       EQU $05056300   ;Coordinate window
vm_filename     EQU $05006400   ;Change gem vdi filename (Byte 2=n)
v_offset        EQU $05016500   ;Set line offset
v_fontinit      EQU $05026600   ;Init system font
;v_escape2000(times) -> (klappt mit dem Konzept leider nicht...)
                ENDPART
                TEXT
                >PART 'Header'
anfang:         jmp     ganz_ans_ende
                DC.L zscan      ;Zeiger auf Scantabelle
alt_flags:      DC.W 8,8        ;ALTERNATE beim Start gedrückt
                DC.L $130000    ;Prüfsumme + Seriennummer
                DC.L ^^RANDOM

                DXSET 31,0
prginfo_7:      DX.B 'Shareware-Basisversion'
                DX.B 'Markus Fritze, Birkhahnkamp 38'
                DX.B '2000 Norderstedt 1'
                EVEN
                ENDPART
************************************************************************
*  Scancodes und Zeiger auf Routinen für den Editor                    *
************************************************************************
                >PART 'zscan'
zscan:          DC.L $4B0000,zleft-zleft ;Crsr left
                DC.L $4D0000,zright-zleft ;Crsr right
z_left:         DC.L $044B0000,zc_left-zleft ;Control + Crsr left
z_right:        DC.L $044D0000,zc_right-zleft ;Control + Crsr right
                DC.L $014B0034,zc_left-zleft ;Shift + Crsr left
                DC.L $014D0036,zc_right-zleft ;Shift + Crsr right
                DC.L $0F0009,ztabulator-zleft ;Tab
                DC.L $010F0009,ztabulatorx-zleft ;Shift Tab
                DC.L $04140074,zdelwort-zleft ;Control T
                DC.L $05140074,zdelrest-zleft ;Shift Control T
                DC.L $0860003C,zdelrest-zleft ;Alt <
                DC.L $520000,zinsert-zleft ;Insert
                DC.L $0E0008,zdelete-zleft ;Backspace
                DC.L $53007F,zdelete-zleft ;Delete
z_swit:         DC.L $01520030,zswitch0-zleft ;Shift + Insert
                DC.L $80000005,s_repeat-zleft ;Repeatfunktion
                DC.L $80000010,s_editor_2-zleft ;Spezialmenü
                DC.L $80000004,s_calc-zleft ;Rechner
                DC.L $01001B,zesc-zleft ;ESC-Sequenzen
kbd_patch4:     DC.L $041B002B,s_char_out-zleft ;Control +
                DC.L $610000,zundo-zleft ;Undo
setcrsr_key:    DC.L $800000,zpos_cur-zleft ;Cursor positionieren
                DC.L $041C000D,zc_return-zleft ;Control Return

                DC.L $80000013,faquit-zleft ;Quit
                DC.L $042D0078,fbquit-zleft ;Control X
                DC.L $0453007F,s_del_line-zleft ;Control Del
                DC.L $042C0079,s_del_line-zleft ;Control Y

                DC.L $1C000D,s_return-zleft ;Return
                DC.L $1C0000,s_return02-zleft ;für Control Return
                DC.L $011C000D,s_return1-zleft ;Shift Return
                DC.L $470000,s_home-zleft ;Home
z_home:         DC.L $01470037,s_pgstart-zleft ;Shift + Home
                DC.L $08140074,s_pgstart2-zleft ;Alt + T
                DC.L $08120065,s_pgend-zleft ;Alt + E
                DC.L $480000,s_up-zleft ;Crsr up
                DC.L $500000,s_down-zleft ;Crsr down
                DC.L $04480000,s_pgup-zleft ;Control + Crsr up
                DC.L $04500000,s_pgdown-zleft ;Control + Crsr down
                DC.L $04130072,s_pgup-zleft ;Control + Crsr up
                DC.L $042E0063,s_pgdown-zleft ;Control + Crsr down
                DC.L $08480000,s_10pgup-zleft ;Alt + Crsr up
                DC.L $08500000,s_10pgdown-zleft ;Alt + Crsr down
                DC.L $09480000,s_lab_up-zleft ;Shift Alt up
                DC.L $09500000,s_lab_down-zleft ;Shift Alt down
                DC.L $04300062,s_block_anf-zleft ;Control B
                DC.L $0425006B,s_block_ende-zleft ;Control K
z_banf:         DC.L $08300062,s_block_start-zleft ;Alt B
z_bend:         DC.L $0825006B,s_block_end-zleft ;Alt K
z_bhid:         DC.L $04230068,s_block_hide-zleft ;Control H
                DC.L $08230068,s_part_hide-zleft ;Alt H
                DC.L $620000,s_part_hide-zleft ;HELP
                DC.L $04620000,s_apart_hide-zleft ;Control HELP
                DC.L $04520000,s_ins_line-zleft ;Control Ins
                DC.L $082C0079,s_del_block-zleft ;Alt Y
                DC.L $042F0076,s_move_block-zleft ;Control V
                DC.L $082E0063,s_copy_block-zleft ;Alt C
z_last:         DC.L $0415007A,s_jump_last-zleft ;Control Z
                DC.L $0824006A,s_jump_error-zleft ;Alt J
                DC.L $0924006A,s_jump_error2-zleft ;Shift Alt J
                DC.L $0424006A,s_kill_error-zleft ;Control J
z_line:         DC.L $0815007A,s_jump_line-zleft ;Alt Z
                DC.L $0915007A,s_jump_linea-zleft ;Shift Alt Z
                DC.L $08190070,s_jump_pc-zleft ;Alt P
                DC.L $081F0073,s_jump_synt-zleft ;Alt S
                DC.L $091F0073,s_jump_synt2-zleft ;Shift Alt S
                DC.L $041F0073,s_jump_user-zleft ;Control S
                DC.L $051F0073,s_jump_user2-zleft ;Shift Control S
                DC.L $04200064,s_dup_line-zleft ;Control D
                DC.L $01480038,s_scroll_up-zleft ;Shift up
                DC.L $01500032,s_scroll_dn-zleft ;Shift down
sftcrsrup_key:  DC.L $05480000,s_scroll2_up-zleft ;Control Shift up
sftcrsrdown_key:DC.L $05500000,s_scroll2_dn-zleft ;Control Shift down
kbd_patch3:     DC.L $042B007E,s_protect-zleft ;Control ~
asc_show_key:   DC.L $041A0081,s_asc_show-zleft ;Control ü
                DC.L $8000FFFF,s_loadsym-zleft ;Shift-Fxxx
                DC.L $8000FFFE,s_ascii_saveblk-zleft ;Shift-Fyyy
                DC.L $04170069,s_info-zleft ;Contrl I
                DC.L $05170069,s_info2-zleft ;Shift Control I
                DC.L $08170069,s_info3-zleft ;Alt I
                DC.L $04110077,s_change_wert-zleft ;Control W
                DC.L $010E0008,s_link_before-zleft ;Shift Backspace
                DC.L $0153007F,s_link_line-zleft ;Shift Del
                DC.L $0432006D,s_merk_line-zleft ;Control M
                DC.L $0832006D,s_ins_merk-zleft ;Alt M
                DC.L $0426006C,s_such_alert-zleft ;Control L
                DC.L $0826006C,s_such_next-zleft ;Alt L
z_repl:         DC.L $04120065,s_replace3-zleft ;Control E
                DC.L $05120065,s_replacea0-zleft ;Shift Control E
z_such:         DC.L $04210066,s_such_sym-zleft ;Control F
                DC.L $08210066,s_such_sym3-zleft ;Alt F
                DC.L $041E0061,s_assemble-zleft ;Control A
                DC.L $081E0061,s_assemblex-zleft ;Alt A
                DC.L $04100071,s_quell_save2-zleft ;Control Q
                DC.L $04220067,s_reorg-zleft ;Control G
                DC.L $04160075,s_search_unused-zleft ;Control U
                DC.L $800001,s_pos_cur-zleft ;Cursor positionieren
blockm_chg_key: DC.L $800002,s_change_def-zleft ;Blockmarken ändern
blockm_mrk_key: DC.L $800003,s_start_def-zleft ;Block markieren
blockm_up_key:  DC.L $800004,s_change_defu-zleft ;Blockmarken ändern + up
blockm_down_key:DC.L $800005,s_change_defd-zleft ;Blockmarken ändern + down
jmplabel_key:   DC.L $800006,s_jump_l-zleft ;Sprung zur Zeile
                DC.L $800007,s_kill_file-zleft ;Datei löschen
                DC.L $800008,s_save_inf-zleft ;Einstellungen sichern
                DC.L $800010,s_editor_3-zleft ;Editor3-Menü
                DC.L $80000A,s_print_block-zleft ;Block drucken
                DC.L $80000B,s_load_dbg-zleft ;Debugger nachladen
                DC.L $08200064,s_load_dbg-zleft ; -"-
                DC.L $80000C,s_kill_dbg-zleft ;Debugger löschen
                DC.L $80000D,s_load_cfg-zleft
                DC.L $0418006F,s_optim-zleft ;CTRL-O
                DC.L $08110077,s_warnflag-zleft ;ALT-W : Warnungen anspringen
                DC.L $0C200064,scanner-zleft ;nur vorläufig
                DC.L $0C25006B,keycode-zleft ;nur vorläufig
zscanend:       DC.L 0,0
                DC.W 8          ;die letzten 8 nicht änderbar
                ENDPART
************************************************************************
* Sprungleiste der Menüfunktionen                                      *
************************************************************************
                >PART 'f_jumpsa'
f_jumpsa:       DC.L s_assemble ;F1     - Assemble
                DC.L s_debugger ;F2   - Debugger
                DC.L s_such_sym ;F3   - Suchen
                DC.L s_editor_1 ;F4   - Editor
                DC.L s_calc     ;F5     - Rechner
                DC.L main_loop  ;F6     - Wiederholung
                DC.L s_print    ;F7     - Drucken
                DC.L s_load     ;F8     - Laden
                DC.L s_save     ;F9     - Sichern
                DC.L fahelp     ;F10    - Uhr stellen
                DC.L s_accs     ;S+F1   - Accessories
                DC.L main_loop  ;S+F2   - ---
                DC.L s_replacea ;S+F3 - Ersetzen
                DC.L sourceinfo ;S+F4 - Info
                DC.L s_darstellung ;S+F5   - Darstellung
                DC.L fanew      ;S+F6   - Löschen
                DC.L s_editor_2 ;S+F7 - Spezial
                DC.L s_merge    ;S+F8   - Zuladen
                DC.L s_ascii_save ;S+F9   - A-Sichern
                DC.L faquit     ;S+F10  - Ende
                ENDPART
                >PART '_trap3'
_screenadr:     DS.L 1
                DC.L 'XBRA'
                DC.L 'TASS'
old_trap3:      DS.L 1
_trap3:         ori.w   #$2000,(SP)
                rte
                ENDPART
************************************************************************
* Hier geht's erst richtig los ...                                     *
************************************************************************
                >PART 'anfang2'
anfang2:        movea.l 4(SP),A0        ;Basepageadr
                lea     varbase,A4
                move.l  A0,basepage(A4)
                movea.l A4,A1
                adda.l  #ende,A1
                suba.l  #anfang-256,A1  ;Programmlänge + Basepage
                move.l  A1,-(SP)        ;= Länge
                move.l  A0,-(SP)        ;Anfangsadresse
                move.l  #$4A0000,-(SP)
                trap    #1              ;Mshrink()
                lea     12(SP),SP

                pea     _trap3(PC)
                move.l  #$050023,-(SP)
                trap    #13             ;Trap #3 setzen (auf OR #$2000,(SP):RTE)
                addq.l  #8,SP
                move.l  D0,old_trap3
                trap    #3              ;Supervisormodus an
                move.l  SP,old_stack(A4) ;alten SSP retten

                bsr     set_clock_fix   ;Uhrzeit übernehmen (ohne Test)

                lea     aes_pb,A0
                move.l  A4,D1
                moveq   #5,D0
do_aes0:        add.l   D1,(A0)+        ;AES-Parameterblock relozieren
                dbra    D0,do_aes0
                lea     vdi_pb,A0
                moveq   #4,D0
do_aes00:       add.l   D1,(A0)+        ;VDI-Parameterblock relozieren
                dbra    D0,do_aes00

                movea.l A4,A0
                adda.l  #ende,A0
                movea.l A0,SP           ;neuen SSP setzen
                lea     8.w,A0
                lea     save_data(A4),A1
                movea.l A1,A2
                move.w  #323,D1
initcop:        move.l  (A0)+,(A1)+     ;$8-$517 retten
                dbra    D1,initcop
                move.l  D0,$84(A2)      ;Trap #3 einsetzen

                bsr     load_moduls     ;Module laden

                move.l  #$05550000,col0(A4) ;Hintergrund/Schriftfarbe
                move.b  #'.',local_char(A4)
                bsr     set_clock
                jsr     init
                sf      testwrd(A4)
                jsr     c_clrhome
                move.l  SP,ass_stack(A4)
                moveq   #-1,D0
                move.l  D0,menü_titel(A4)
                move.w  D0,sel_menü_titel(A4)
                move.w  D0,menü_save_titel(A4)
                lea     menü_baum,A0
                move.l  A0,menü_baum_adr(A4) ;Menübaum setzen
                jsr     menü_bar
                bsr     asc_code_out    ;ASCII-Code oben rechts darstellen
                clr.w   block_anf(A4)
                clr.w   block_end(A4)
                clr.w   top_line(A4)
                sf      ins_mode(A4)
                sf      sym_flag(A4)
                sf      s_such_flag(A4)
                clr.w   save_pos(A4)
                clr.b   s_exit_flag(A4)
                sf      maustast_flag(A4)
                move.b  #$80,start_flag(A4)
                moveq   #$FF,D0
                move.w  D0,block_anf(A4)
                move.w  D0,block_end(A4)
                moveq   #0,D0           ;kein Fehler
                jsr     error_out
                jsr     print_top       ;Kopfzeile ausgeben
                clr.w   scr_z(A4)
                jsr     ass_init        ;Speicher initialisieren
                bclr    #7,sym_flag(A4)
                bsr     s_new           ;Sourcetext löschen
                lea     fname_src(A4),A0
                move.l  #'NONA',(A0)+
                move.l  #'ME.S',(A0)+
                move.w  #'RC',(A0)+
                clr.b   (A0)+
                bsr     s_copy_name     ;Defaultfilenamen in Anzeige kopieren
                moveq   #0,D6
                clr.w   undo_buff(A4)
                lea     serial_no(PC),A0
                st      testwrd(A4)
                moveq   #3,D4
                moveq   #0,D1
                move.w  anfang+16(PC),D1 ;Seriennummer (BCD)
                jsr     hexwout
                sf      testwrd(A4)
                move.w  #$1B,optim_flag(A4)
                btst    #1,editor3_flag(A4) ;Debugger nachladen?
                beq.s   no_load         ;nein
                tst.b   debugger_da(A4) ;Debugger schon resident da?
                bne.s   no_load         ;Ja! => nicht laden
                st      block_pointer(A4) ;Flag für 'beim Start nachladen'
                bsr     s_load_dbg2     ;Debugger nachladen
no_load:        movea.l basepage(A4),A0 ;Adresse der Basepage
                lea     128(A0),A0      ;Zeiger auf Commandline
                tst.b   (A0)            ;vorhanden ?
                bne.s   s_autoload      ;ja
                tst.b   1(A0)
                bne.s   s_autoload
                lea     infobutt_(PC),A1
                move.w  (A1),D1
                move.w  #-1,(A1)
                moveq   #10,D0          ;max.10 Sekunden anzeigen
                lea     infoasm_(PC),A0
                subq.w  #2,6(A0)
                jsr     object_do
                addq.w  #2,6(A0)
                move.w  D1,(A1)
                moveq   #0,D7
                bra     main_loop3
s_autoload:     moveq   #0,D1
                clr.b   (A0)+
                move.l  A0,D0
                lea     upper_tab,A1
s_autoload1:    move.b  (A0),D1         ;Zeichen holen
                move.b  0(A1,D1.w),(A0)+ ;und in groß wandeln
                bne.s   s_autoload1
                movea.l D0,A0
                lea     fpath_src+2(A4),A1 ;Zeiger auf Pfadname
                cmpi.b  #':',1(A0)      ;Laufwerksangabe
                bne.s   s_autoload2     ;nein
                moveq   #0,D0
                move.b  (A0)+,D0
                move.b  D0,-2(A1)       ;Laufwerk übertragen
                subi.w  #'A',D0
                move.w  D0,-(SP)
                move.w  #$0E,-(SP)
                jsr     do_trap_1       ;Dsetdrv
                addq.l  #4,SP
                clr.b   (A0)+           ;':' überlesen und löschen
                move.l  A0,D0
s_autoload2:    move.b  (A0)+,D1        ;Ende des Pfads+Namen suchen
                cmp.b   #13,D1          ;Return
                beq.s   s_autoload3
                cmp.b   #' ',D1
                beq.s   s_autoload3
                tst.b   D1
                bne.s   s_autoload2
                subq.l  #1,A0
s_autoload3:    move.b  -(A0),D1        ;Anfang des Filenamens suchen
                beq.s   s_autoload4
                cmp.b   #'\',D1
                bne.s   s_autoload3
s_autoload4:    move.l  A0,D1
                addq.l  #1,A0
                lea     fname_src(A4),A2
s_autoload5:    move.b  (A0),(A2)+      ;Name übertragen
                cmpi.b  #' ',(A0)+
                bhi.s   s_autoload5
                clr.b   -(A2)           ;Nullbyte
                movea.l D0,A0           ;zeigt auf Pfad
                cmp.l   D1,D0
                bhi.s   s_autoload11    ;kein Pfad
s_autoload6:    move.b  (A0)+,(A1)+     ;Pfad kopieren
                cmpa.l  D1,A0
                blo.s   s_autoload6
                clr.b   (A1)
                pea     fpath_src+2(A4)
                move.w  #$3B,-(SP)
                jsr     do_trap_1       ;Dsetpath
                addq.l  #6,SP
                cmpi.b  #'\',-1(A1)
                beq.s   s_autoload7     ;verhindert 2 '\' hintereinander
                move.b  #'\',(A1)+
s_autoload7:    move.b  #'*',(A1)+
                move.b  #'.',(A1)+
                move.b  #'*',(A1)
s_autoload8:    move.b  -(A2),D0
                beq.s   s_autoload10
                cmp.b   #'.',D0
                bne.s   s_autoload8
                addq.l  #1,A2
s_autoload9:    move.b  (A2)+,(A1)+     ;Extension in Pfad kopieren
                bne.s   s_autoload9
s_autoload10:   clr.b   1(A1)           ;Abschluß durch Nullbyte
                bra     s_loadx
s_autoload11:   tst.b   (A1)+
                bne.s   s_autoload11    ;Ende des Pfadstrings bestimmen
s_autoload12:   cmpi.b  #'\',-(A1)
                bne.s   s_autoload12    ;Backslash suchen
                addq.l  #1,A1
                bra.s   s_autoload7

infoasm_:       DC.W 0,0,33,11,1
                DC.W 6,1
                DC.L infoasm__0
                DC.W $08
                DC.W 2,4
                DC.L infoasm__1
                DC.W $08
                DC.W 13,5
                DC.L infoasm__2
                DC.W $08
                DC.W 2,6
                DC.L infoasm__3
                DC.W $08
                DC.W 13,7
                DC.L infoasm__4
                DC.W $08
                DC.W 7,2
                DC.L infoasm__5
                DC.W $08
infobutt_:      DC.W 13,9
                DC.L ok_button
                DC.W $26
                DC.W -1

infoasm__0:     DC.B 'TurboAss V'
                DC.B (version>>8)&$0F+'0'
                DC.B '.'
                DC.B (version>>4)&$0F+'0'
                DC.B version&$0F+'0'
                DC.B ' #'
serial_no:      DC.B '0000  ',0
                SWITCH sprache
                CASE 0
infoasm__1:     DC.B 'Autoren:   Sören Hellwig',0
infoasm__2:     DC.B 'Markus Fritze',0
infoasm__3:     DC.B 'Anleitung: Christoph Pagalies',0
                CASE 1
infoasm__1:     DC.B 'Authors:   Sören Hellwig',0
infoasm__2:     DC.B 'Markus Fritze',0
infoasm__3:     DC.B 'Manual:    Christoph Pagalies',0
                ENDS
infoasm__4:     DC.B 'Markus Fritze',0
infoasm__5:     DC.B '©1989/90 by ∑-soft',0
ok_button:      DC.B '   OK   ',0
                EVEN
                ENDPART
                >PART 'main_loop3'
main_loop3:     movea.l ass_stack(A4),SP
                moveq   #0,D1
                clr.w   top_line(A4)
                movea.l z_info_base(A4),A5
                movea.l program_base(A4),A6
                movea.l comment_base(A4),A3
                movem.l A3/A5-A6,top_ptr(A4) ;Zeiger auf Textanfang
                jsr     jump_line       ;zur ak. Zeile
main_loop:      IF ^^SYMTAB
                movea.l SP,A0
                ENDC
                movea.l ass_stack(A4),SP
                IF ^^SYMTAB
                cmpa.l  A0,SP
                beq.s   main_loop1
                lea     sp_wrong_rsc(PC),A0
                jsr     _form_do
                bra.s   main_loop
main_loop1:     ENDC
                move.l  checksum_1(A4),D0
                cmp.l   checksum_2(A4),D0
                beq     main_loop_ok
                clr.l   checksum_1(A4)
                clr.l   checksum_2(A4)
                lea     checksum_rsc(PC),A0
                jsr     _form_do
                bra.s   main_loop
checksum_rsc:   DC.W 0,0,37,10,1
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W 7,1
                DC.L checksum_1_rsc
                DC.W $08
                DC.W 7,3
                DC.L checksum_2_rsc
                DC.W $08
                DC.W 7,4
                DC.L checksum_3_rsc
                DC.W $08
                DC.W 7,5
                DC.L checksum_4_rsc
                DC.W $08
                DC.W 7,6
                DC.L checksum_5_rsc
                DC.W $08
                DC.W 13,8
                DC.L checksum_6_rsc
                DC.W $26
                DC.W -1
                SWITCH sprache
                CASE 0
checksum_1_rsc: DC.B 'Herzlichen Glückwunsch!',0
checksum_2_rsc: DC.B 'Sie sind ein großartiger',0
checksum_3_rsc: DC.B 'Programmierer! Der Assembler',0
checksum_4_rsc: DC.B 'ist beim Debuggen beschädigt',0
checksum_5_rsc: DC.B 'worden!',0
checksum_6_rsc: DC.B ' OH GRAUS! ',0
                CASE 1
checksum_1_rsc: DC.B 'What a happy day...',0
checksum_2_rsc: DC.B 'You are a fantastic',0
checksum_3_rsc: DC.B 'programmer! The assembler',0
checksum_4_rsc: DC.B 'has been damaged during',0
checksum_5_rsc: DC.B 'debugging!',0
checksum_6_rsc: DC.B ' WHY ME! ',0
                ENDS
                EVEN
sp_wrong_rsc:   DC.W 0,0,29,6,1
                DC.W 8,1
                DC.L sp_wrong_rsc1
                DC.W $08
                DC.W 8,2
                DC.L sp_wrong_rsc2
                DC.W $08
                DC.W 11,4
                DC.L sp_wrong_rsc3
                DC.W $26
                DC.W 2,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1
sp_wrong_rsc1:  DC.B 'SP beim Einsprung',0
sp_wrong_rsc2:  DC.B 'in mainloop falsch!',0
sp_wrong_rsc3:  DC.B ' WEITER ',0
                EVEN
main_loop_ok:   sf      bell_flag(A4)   ;Pling bei neuem Label
                move.w  scr_z(A4),D0    ;ak. Screenzeile
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Zeile muß upgedatet werden
                movea.l (SP)+,A0
                movem.l D0-A6,-(SP)
                clr.w   error_pos(A4)
                pea     zeingabe+2(A4)  ;Buffer setzen
                jsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP           ;Stack korregieren
                move.l  A0,D0
                sub.l   A4,D0
                subi.w  #zeingabe+2,D0  ;Länge der Zeile berechnen
clr_loop2:      cmpi.b  #' ',-(A0)
                dbne    D0,clr_loop2
                bne.s   clr_loop22
                addq.l  #1,A0
                addq.w  #1,D0
clr_loop22:     addq.l  #1,A0
                clr.b   (A0)
                lea     zeingabe(A4),A1
                move.w  #255,D1
                cmp.w   D1,D0
                blo.s   clr_loop24
                move.w  D1,D0
clr_loop24:     move.w  D0,(A1)+        ;und in Buffer eintragen
                clr.w   254(A1)
                sub.w   D0,D1
                bmi.s   clr_loop23
                adda.w  D0,A1
clr_loop:       clr.b   (A1)+           ;Rest des Buffer löschen
                dbra    D1,clr_loop
clr_loop23:     moveq   #63,D0
                lea     dbuffer+300(A4),A0
                lea     zeingabe(A4),A1
zcr4:           move.l  (A1)+,(A0)+     ;Zeile in zwischenspeichern
                dbra    D0,zcr4
                moveq   #$7F,D0
                and.b   8(A5),D0
                jsr     error_out       ;wenn Fehler in der Zeilen, ausgeben
                movem.l (SP)+,D0-A6
inp_loop1:      sf      action_fl(A4)
inp_loop2:      sf      load_fl(A4)
                movea.l ass_stack(A4),SP
                moveq   #0,D1           ;ak. Zeile
                move.w  D6,D1
                move.w  #-1,zeile(A4)
                move.w  #2,spalte(A4)
                moveq   #4,D4
                jsr     dezw_out        ;ausgeben
                jsr     draw_lines
                clr.w   D4              ;X-Offset für Scrolling
                bsr     edit            ;Zeile editieren
                move.w  D2,cursor_spalte(A4)
                move.l  D0,-(SP)        ;Tastencode retten
                tst.b   action_fl(A4)   ;wurde in der Zeile was verändert
                bpl.s   no_change       ;nein
                st      change_flag(A4) ;Sourcetext geändert
                moveq   #63,D0
                lea     undo_buff(A4),A0
                move.w  #1,(A0)+        ;Flag für geänderte Zeile
                lea     dbuffer+300(A4),A1
zcr5:           move.l  (A1)+,(A0)+     ;Zeile in UNDO-Buffer sichern
                dbra    D0,zcr5
                move.w  D2,save_pos(A4) ;ak. Position speichern
                move.w  D6,letzte_zeile(A4) ;Zeile merken
                move.w  D6,s_undo_zeile(A4)
                move.w  D3,zeingabe(A4) ;Länge in Buffer speichern
                tst.w   error_pos(A4)   ;<>0, wenn Fehler
                bne.s   zcr3
                tst.b   action_fl(A4)
                beq.s   zcr2
zcr3:           jsr     code_line       ;Zeile in Buffer assemblieren
                jsr     error_out       ;Fehler in D0 ausgeben
                tst.w   D0
                beq.s   zcr2            ;kein Fehler, weiter
                bra.s   inp_loop2       ;Fehler, dann erneutes Anzeigen
zcr2:           sf      load_fl(A4)
                lea     op_buffer(A4),A2 ;assemblierte Zeile
                bsr     change_line     ;ins Programm übernehmen
                tst.b   part_flag(A4)
                beq.s   no_change       ;Kein PART oder ENDPART
                jsr     search_part     ;Tabelle aktualisieren
                bsr     redraw_all
no_change:      clr.w   D4
                move.w  scr_z(A4),D0    ;ak. Screenzeile
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Updateflag setzen
                move.l  (SP)+,D0        ;Tastencode zurückholen
                lea     zscan(PC),A0    ;Tabelle der Tastencodes
                move.w  #(zscanend-zscan)/8-1,D1
key_find:       cmp.l   (A0)+,D0        ;Code vergleichen
                movea.l (A0)+,A1        ;Sprungoffset nach A1
                dbeq    D1,key_find
                beq.s   key_jump        ;Code in Tabelle gefunden
                tst.l   D0
                bmi     fun_keys        ;Funktionstaste
                tst.w   D0
                bmi     tmarker         ;Marker
                bra     inp_loop1
key_jump:       lea     zleft(PC),A0
                adda.l  A1,A0
                jmp     (A0)            ;Sprung in Routine
                ENDPART
************************************************************************
* Zeile editieren                                                      *
************************************************************************
                >PART 'edit'
edit:           lea     zeingabe(A4),A1 ;Zeiger auf Eingabebuffer
                move.w  (A1)+,D3        ;d3 = Länge der Zeile
                move.w  save_pos(A4),D2 ;gemerkte Spalte
                tst.w   error_pos(A4)   ;Fehlerposition
                beq.s   edit01          ;kein Fehler
                move.w  scr_z(A4),D0    ;ak. Screenzeile
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A0
                move.w  error_pos(A4),D2 ;Fehlerposition
edit01:         cmp.w   D3,D2
                bls.s   edit02
                move.w  D3,D2           ;D2=ak. Position
                bra.s   edit02
edit06:         st      action_fl(A4)
edit08:         move.w  scr_z(A4),D0    ;ak. Screenzeile
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A0
edit02:         moveq   #0,D1
                move.w  D2,D1
                move.w  D4,-(SP)
                move.w  #-1,zeile(A4)
                move.w  #11,spalte(A4)
                moveq   #2,D4
                jsr     dezw_out        ;ak. Spalte ausgeben
                move.w  (SP)+,D4
                jsr     draw_lines
                move.w  scr_z(A4),D0    ;ak. Bildschirmzeile
                move.w  D0,zeile(A4)
                cmp.w   D4,D2
                bhs.s   edit03
                move.w  D2,D4
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)
                movea.l (SP)+,A0
edit03:         move.w  sdrv_maxcur_x(A4),D5
                IF slider
                sub.w   #slsize,D5
                ENDC
                add.w   D5,D4
                cmp.w   D2,D4
                bhs.s   edit04
                move.w  D2,D4
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)
                movea.l (SP)+,A0
edit04:         sub.w   D5,D4
                sub.w   D4,D2
                move.w  D2,spalte(A4)
                add.w   D4,D2
edit05:         lea     zeingabe+2(A4),A1 ;Zeiger auf Eingabebuffer
                bsr.s   get_key
                lea     zscan(PC),A0    ;Tabelle der Scancodes
                move.w  #(zscanend-zscan)/8-1,D1
key_find2:      cmp.l   (A0)+,D0        ;Tastencode
                movea.l (A0)+,A2        ;Sprungadresse
                dbeq    D1,key_find2
                beq.s   key_jump2
                tst.l   D0
                bmi.s   key_jump4       ;Funktionstasten
                tst.w   D0
                bmi.s   key_jump4       ;Marker
                tst.b   D0
                beq.s   edit05
                move.b  D0,last_char(A4) ;Zeichen merken
                pea     edit06(PC)      ;Rücksprungadresse
zset_char2:     tst.b   ins_mode(A4)    ;Insertmodus
                bne.s   zins_mode       ;ja
                cmp.w   D3,D2
                blo.s   zset_cha1
                cmp.w   #254,D3
                bhi.s   zset_cha_r
                addq.w  #1,D3
zset_cha1:      move.b  D0,0(A1,D2.w)   ;Zeichen in Buffer
                addq.w  #1,D2
zset_cha_r:     rts
zins_mode:      cmp.w   #254,D3
                bhi.s   zset_cha_r
                bsr     zinserth        ;Buffer aufrücken
                bra.s   zset_cha1
key_jump2:      cmp.w   #(zscanend-zscan)/8-1-23,D1
                bgt.s   key_jump3       ;einfache Editorroutine ausführen
                cmp.w   #(zscanend-zscan)/8-1-27,D1
                bgt     edit07          ;Ctrl-Del sollen nicht abspeichern
key_jump4:      rts
key_jump3:      lea     zleft(PC),A0
                adda.l  A2,A0
                jmp     (A0)            ;Routine ausführen
                ENDPART
************************************************************************
* wartet auf Taste / Mausaktion und updatet nebenbei den Screen        *
************************************************************************
                >PART 'get_key'
get_key:        clr.l   screen_time(A4)
                jsr     cursor_on       ;Cursor darstellen
                move.l  zeile(A4),-(SP)
get_key1:       bsr.s   redraw_screen
                bsr     asc_code_out    ;ASCII-Code oben rechts darstellen
                jsr     tastchk         ;Tastencode holen
                bmi.s   get_key2        ;Taste wurde gedrückt
                jsr     mauschk         ;Maus auswerten
                bmi.s   get_key2        ;Mausreaktion
                jsr     menüchk         ;Menü auswerten
                bmi.s   get_key2        ;Menüpunkt angewählt
                bra.s   get_key1
get_key2:       move.l  (SP)+,zeile(A4)
                jmp     cursor_off      ;Cursor aus
                ENDPART
                >PART 'redraw_screen'
redraw_screen:  move.w  scr_z(A4),D0    ;ak. Screenzeile(a4)
                lea     lin_tab(A4),A0
                tas.b   0(A0,D0.w)      ;Zeile upzudaten?
                bne.s   redraw_screen3  ;Nein! =>
                jsr     cursor_off      ;Cursor aus
                lea     0(A1,D4.w),A0   ;Zeiger auf Zeile+X-Offset
                cmp.w   anz_zeilen(A4),D6
                beq.s   redraw_screen1
                cmp.w   block_end(A4),D6
                bhs.s   redraw_screen1
                cmp.w   block_anf(A4),D6
                blo.s   redraw_screen1
                jsr     write_mline     ;markierte Zeile ausgeben
                bra.s   redraw_screen2
redraw_screen1: jsr     write_line      ;Zeile ausgeben
redraw_screen2: jsr     cursor_on       ;Cursor ein
redraw_screen3: lea     lin_tab(A4),A0  ;Tabelle der Updatebytes
                move.w  sdrv_zanz(A4),D1
redraw_screen4: tst.b   (A0)+           ;ersten Eintrag =0 finden
                dbeq    D1,redraw_screen4
                bne.s   redraw_screen7  ;alle Zeilen ok
                st      -(A0)           ;$FF eintragen
                move.w  sdrv_zanz(A4),D0
                sub.w   D1,D0
                move.w  D0,D7           ;Screenzeilennummer retten
                lea     lin_tab2(A4),A0 ;Tabelle der Zeilennummern
                add.w   D0,D0           ;mal 2
                move.w  0(A0,D0.w),D0   ;Zeilennummer holen
                cmp.w   anz_zeilen(A4),D0 ;mit Anzahl vergleichen
                bhs.s   redraw_screen6  ;größer, kein Update
                movem.l D0-D7/A1-A6,-(SP)
                jsr     calc_pointer    ;berechnet Zeiger auf Programm
                pea     redraw_buf+2(A4) ;Buffer setzen
                jsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP           ;Stack korregieren
                movem.l (SP)+,D0-D7/A1-A6
                clr.b   (A0)            ;Zeile mit Nullbyte abschließen
                lea     redraw_buf+2(A4),A0
                exg     D7,D0
                cmp.w   block_end(A4),D7 ;D7=Zeilennummer, D0=Screenzeile
                bhs.s   redraw_screen5
                cmp.w   block_anf(A4),D7
                blo.s   redraw_screen5
                jsr     write_mline     ;markierte Zeile ausgeben
                bra.s   redraw_screen3
redraw_screen5: jsr     write_line      ;Zeile ausgeben
                bra.s   redraw_screen3
redraw_screen6: lea     redraw_buf+2(A4),A0 ;Zeile löschen
                clr.b   (A0)
                move.w  D7,D0
                jsr     write_line
                bra.s   redraw_screen3
redraw_screen7: rts
                ENDPART
                >PART 'asc_code_out'
asc_code_out:   move.l  zeile(A4),-(SP)
                movem.l D0-A6,-(SP)
                tst.b   asc_show_flag(A4)
                bmi.s   asc_code_out2
                beq.s   asc_code_out0
                move.l  #'    ',asc_code ;ASCII-Code löschen
                st      asc_show_flag(A4)
                bra.s   asc_code_out3
asc_code_out0:  jsr     calc_crsr
                moveq   #0,D1
                move.b  (A0),D1         ;ASCII-Zeichen holen
                cmp.b   save_asc_code(A4),D1
                beq.s   asc_code_out2   ;Code ist gleich
                move.b  D1,save_asc_code(A4)
                moveq   #2,D4
                lea     asc_code(PC),A0
                st      testwrd(A4)
                jsr     dezw_out
asc_code_out3:  sf      testwrd(A4)
                move.w  #-2,zeile(A4)
                move.w  sdrv_maxcur_x(A4),D0
                sub.w   #11,D0
                move.w  D0,spalte(A4)
                moveq   #-1,D1
                moveq   #0,D2
                moveq   #-1,D3
                lea     asc_code(PC),A0
                moveq   #3,D4
asc_code_out1:  moveq   #0,D0
                move.b  (A0)+,D0
                jsr     light_char
                addq.w  #1,spalte(A4)
                dbra    D4,asc_code_out1
asc_code_out2:  movem.l (SP)+,D0-A6
                move.l  (SP)+,zeile(A4)
                rts
asc_code:       DC.B '    '
                ENDPART
                >PART 'scr_off/scr_on'
************************************************************************
* Automatische Bildschirmabschaltung                                   *
************************************************************************
scr_off:        move.l  screen_time(A4),D0
                cmp.l   screen_delay(A4),D0 ;Zeit abgelaufen?
                blo.s   scr_off3        ;Nein, noch nicht! =>
                cmp.l   next_stime(A4),D0 ;toggeln?
                blo.s   scr_off3        ;noch nicht =>
                add.l   #15*200,D0      ;alle 15s toggeln
                move.l  D0,next_stime(A4)
                move.l  scr_color(A4),D0
                swap    D0              ;Farben drehen
                move.l  D0,scr_color(A4)
                move.l  scr_color(A4),D0
                bsr.s   set_color
scr_off3:       rts

scr_on:         move.l  D0,-(SP)
                move.l  col0(A4),D0
                bsr.s   set_color       ;normale Farben setzen
                move.l  (SP)+,D0
                move.l  col0(A4),scr_color(A4) ;Farben zurück
                clr.l   screen_time(A4)
                clr.l   next_stime(A4)
                rts

set_color:      move    SR,-(SP)
                ori     #$0700,SR       ;alle IRQs aus
                movem.l D0-D1/A1,-(SP)
                lea     $FFFF8240.w,A1
                move.l  D0,(A1)+
                moveq   #13,D1
set_color1:     move.w  D0,(A1)+        ;Die Farben zurücksetzen
                dbra    D1,set_color1
                movem.l (SP)+,D0-D1/A1
                move    (SP)+,SR
                rts
                ENDPART
************************************************************************
* einfache Editorrroutinen                                             *
************************************************************************
;D6 : aktuelle Programmzeile
;A6 : Zeiger auf Opcode der aktuellen Zeile
;A5 : Zeiger auf Zeileninfo der aktuellen Zeile
;A3 : Zeiger auf Remark der aktuellen Zeile
;A4 : Zeiger auf BSS Bereich
                >PART 'ztabulatorx'
ztabulatorx:    lea     tabs-2(A4),A0
                moveq   #2,D0
ztab_loop2:     addq.l  #2,A0
                cmp.w   (A0),D2
                dbcs    D0,ztab_loop2
                bhs.s   zerror
                move.w  (A0),D2
                cmp.w   D3,D2
                bls.s   ztabulator3
                cmp.w   #254,D2
                blo.s   ztabulator2
                move.w  #254,D2
                bra.s   ztabulator2
ztabulator:     lea     tabs-2(A4),A0
                moveq   #2,D0
ztab_loop:      addq.l  #2,A0
                cmp.w   (A0),D2
                dbcs    D0,ztab_loop
                bhs.s   zerror
                tst.b   ins_mode(A4)
                bne.s   ztabulator4     ;Insertmodus
                move.w  (A0),D2
                cmp.w   D3,D2
                blo.s   ztabulator3
                cmp.w   #254,D2
                blo.s   ztabulator2
                move.w  #254,D2
ztabulator2:    move.b  #' ',0(A1,D3.w)
                addq.w  #1,D3
                cmp.w   D2,D3
                bls.s   ztabulator2
                move.w  D2,save_pos(A4)
                bra     edit06
ztabulator4:    bsr     zinserth
                move.b  #' ',0(A1,D2.w)
                addq.w  #1,D2
                cmp.w   (A0),D2
                blo.s   ztabulator4
                move.w  D2,save_pos(A4)
                bra     edit06
ztabulator3:    move.w  D2,save_pos(A4)
                bra     edit02
zerror:         bra     edit05
                ENDPART
                >PART 'zesc'
zesc:           jsr     cursor_off
                jsr     cursor_on
zesc2:          jsr     tastchk         ;wartet auf Taste
                bpl.s   zesc2
                jsr     cursor_off
                sub.w   #'A',D0
                bmi.s   zesc3
                cmp.w   #26,D0
                blo.s   zesc4
                sub.w   #$20-26,D0      ;Kleinbuchstabe
                cmp.w   #26,D0
                blo.s   zesc3
                cmp.w   #52,D0
                bhs.s   zesc3
zesc4:          lea     cmd_tab,A0      ;Zeiger auf die Offsets
                add.w   D0,D0
                lea     0(A0,D0.w),A0
                tst.w   (A0)            ;Offset testen
                beq.s   zesc3           ;nicht belegt
                adda.w  (A0),A0         ;Zeiger auf Befehlstext
                moveq   #0,D0
zesc5:          move.b  (A0)+,D0
                bsr     zset_char2      ;Text übertragen
                cmp.b   #$20,D0         ;Space beendet den Befehl
                beq     edit06
                bra.s   zesc5
zesc3:          bra     edit02
                ENDPART
                >PART 'zleft'
zleft:          tst.w   D2
                beq.s   zerror
                subq.w  #1,D2
                move.w  D2,save_pos(A4)
                bra     edit02
                ENDPART
                >PART 'zright'
zright:         cmp.w   #254,D2
                bhi.s   zerror
                cmp.w   D3,D2
                beq.s   zerror
                addq.w  #1,D2
                move.w  D2,save_pos(A4)
                bra     edit02
                ENDPART
                >PART 'zc_left'
zc_left:        moveq   #0,D2
                move.w  D2,save_pos(A4)
                bra     edit02
                ENDPART
                >PART 'zc_right'
zc_right:       move.w  D3,D2
                move.w  D2,save_pos(A4)
                bra     edit02
                ENDPART
                >PART 'edit07'
edit07:         andi.b  #$7F,action_fl(A4)
                move.w  scr_z(A4),D1
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D1.w)
                movea.l (SP)+,A0
                rts
                ENDPART
                >PART 'zundo'
zundo1:         clr.w   undo_buff(A4)   ;UNDO wurde ausgeführt
                bra     main_loop
zundo:          moveq   #0,D0
                jsr     error_out
                tst.b   action_fl(A4)   ;in ak. Zeile
                bne.s   zundo1          ;es wurde etwas geändert
                tst.w   undo_buff(A4)   ;ist etwas im UNDO-Puffer?
                beq     edit02          ;nö
                move.w  D6,letzte_zeile(A4)
                move.w  s_undo_zeile(A4),D6
                jsr     jump_line       ;Zeile anspringen
                tst.b   undo_buff+1(A4)
                bmi.s   zundo4          ;Shift Delete
                move.w  undo_buff(A4),D0
                bpl.s   zundo3          ;keine gelöschte/eingefügte Zeile
                tst.b   D0
                bne.s   zundo5          ;eingefügte Leerzeile
                bsr     insert_line
                bne     no_more_mem
                bsr     s_ins_line2     ;Zeile einfügen
zundo3:         lea     undo_buff+2(A4),A0
                lea     zeingabe(A4),A1 ;gelöschte Zeile zurück
                moveq   #63,D0
zundo2:         move.l  (A0)+,(A1)+
                dbra    D0,zundo2
                clr.w   undo_buff(A4)   ;UNDO wurde ausgeführt
                clr.l   (SP)
                bra     zcr3
zundo5:         bsr     delete_line     ;Leerzeile entfernen
                bsr     s_del_line2
                clr.w   undo_buff(A4)   ;UNDO wurde ausgeführt
                bsr     redraw_all
                bra     main_loop

zundo4:         btst    #0,undo_buff+1(A4) ;Kennung =$81 ?
                beq.s   zundo42         ;nein, keine Zeile einfügen
                bsr     insert_line
                bne     no_more_mem
                bsr     s_ins_line2     ;Zeile einfügen
zundo42:        lea     undo_buff+2(A4),A0
                movea.l A5,A1           ;Zeiger auf Zeileninfo
                moveq   #4,D0
zundo41:        move.l  (A0)+,(A1)+     ;Zeileninfo rekonstruieren
                dbra    D0,zundo41
                clr.w   undo_buff(A4)   ;UNDO wurde ausgeführt
                bsr     redraw_all
                bra     main_loop
                ENDPART
                >PART 'zinsert'
zinsert:        cmp.w   #254,D3
                bhi     zerror
                bsr.s   zinserth
                move.b  #' ',0(A1,D2.w)
                bra     edit06
zinserth:       move.w  D3,D7
                subq.w  #1,D7
zinsert1:       move.b  0(A1,D7.w),1(A1,D7.w)
                subq.w  #1,D7
                cmp.w   D7,D2
                ble.s   zinsert1
                addq.w  #1,D3
                rts
                ENDPART
                >PART 'zdelwort'
zdelwort:       tst.w   D3              ;Zeilenlänge=0
                beq     zerror          ;dann nix löschen
                cmp.w   D3,D2           ;Cursor am Zeilenende
                beq     zerror          ;dann gibt's auch nix zu löschen
                movem.l D0-D2/D7,-(SP)
                move.w  D2,D7           ;Cursorposition retten
                move.b  0(A1,D7.w),D0   ;Zeichen unter dem Cursor holen
                cmp.b   #'0',D0
                bhs.s   zdelwort11      ;ASCII-String löschen
                bra.s   zdelwort21      ;Sonderzeichen löschen
zdelwort10:     addq.w  #1,D7
zdelwort11:     move.b  0(A1,D7.w),D0   ;Zeichen unter dem Cursor holen
                cmp.b   #'0',D0
                bhs.s   zdelwort10      ;das Ende des Strings suchen
                bra.s   zdelwort22
zdelwort20:     addq.w  #1,D7
zdelwort21:     move.b  0(A1,D7.w),D0   ;Zeichen unter dem Cursor holen
                beq.s   zdelrest1       ;Nullbyte=Bis zum Zeilenende löschen
                cmp.b   #'0',D0
                blo.s   zdelwort20      ;das Ende der Sonderzeichen suchen
zdelwort22:     cmp.w   D7,D2
                beq.s   zdelwort3       ;nix gefunden (geht normalerweise nicht)
                move.w  D3,D1
                sub.w   D7,D1
                addq.w  #1,D1
zdelwort2:      move.b  0(A1,D7.w),0(A1,D2.w) ;Wort löschen
                addq.w  #1,D7
                addq.w  #1,D2
                subq.w  #1,D1
                bpl.s   zdelwort2
                sub.w   D2,D7
                sub.w   D7,D3
                move.w  #297,D7
zdelwort31:     clr.b   0(A1,D7.w)      ;Rest des Buffers löschen
                subq.w  #1,D7
                cmp.w   D3,D7
                bhs.s   zdelwort31
zdelwort3:      movem.l (SP)+,D0-D2/D7
                bra     edit06
                ENDPART
                >PART 'zdelrest'
zdelrest1:      movem.l (SP)+,D0-D2/D7
zdelrest:       tst.w   D3
                beq     zerror          ;Zeilenlänge = 0
                cmp.w   D3,D2
                beq     zerror          ;Cursor auf letztem Zeichen
                move.w  D2,D3
                move.w  #297,D7
zdelrest2:      clr.b   0(A1,D7.w)      ;Rest des Buffers löschen
                subq.w  #1,D7
                cmp.w   D2,D7
                bge.s   zdelrest2
                bra     edit06
                ENDPART
                >PART 'zdelete'
zdelete:        tst.w   D3
                beq     zerror
                cmp.w   #8,D0
                bne.s   znbackspc
                tst.w   D2
                beq     zerror
                subq.w  #1,D2
znbackspc:      cmp.w   D3,D2
                bge     zerror
                subq.w  #1,D3
                move.w  D2,D7
zdelete1:       move.b  1(A1,D7.w),0(A1,D7.w)
                addq.w  #1,D7
                cmp.w   #255,D7
                blt.s   zdelete1
                bra     edit06
                ENDPART
                >PART 'zc_return'
zc_return:      clr.w   D2
                bsr     zinserth
                bsr     zinserth
                move.w  #';Ø',(A1)
                move.l  #$1C0000,D0     ;Scancode für Return
                rts
                ENDPART
                >PART 'zpos_cur'
zpos_cur:       move.w  scr_z(A4),D0    ;ak. Screenzeile
                cmp.w   s_zeile(A4),D0  ;gleich der neuen Position ?
                bne.s   zpos_cur2
                move.w  s_spalte(A4),D2
                add.w   D4,D2           ;Cursor innerhalb der Zeile positionieren
                move.w  D2,save_pos(A4)
                cmp.w   D3,D2
                bls     edit02
                move.w  D3,D2
                move.w  D2,save_pos(A4)
                bra     edit02
zpos_cur2:      move.l  #$800001,D0     ;Scancode für Cursor positionieren
                rts                     ;Sprung aus dem 'edit' Unterprogramm, damit
;die Zeile tokenisiert wird
                ENDPART
                >PART 's_pos_cur'
s_pos_cur:      move.w  s_zeile(A4),D0  ;angeklickte Screenzeile
                lea     lin_tab2(A4),A0 ;Tabelle der Zeilenummern
                move.w  D0,D1
                add.w   D0,D0           ;mal 2
                move.w  0(A0,D0.w),D0   ;Zeilennummer holen
                cmp.w   anz_zeilen(A4),D0
                bhi     main_loop       ;hinter dem Ende
                move.w  D1,scr_z(A4)    ;Screenzeile setzen
                move.w  D0,D6           ;ak. Zeilennummer
                jsr     calc_pointer    ;Zeiger berechnen
                move.w  s_spalte(A4),save_pos(A4)
                bra     main_loop
                ENDPART
                >PART 's_start_def'
s_start_def:    move.w  s_zeile(A4),D0  ;Screenzeile
                lea     lin_tab2(A4),A0
                add.w   D0,D0           ;mal 2
                move.w  0(A0,D0.w),D1   ;entsp. Sourcezeile
                cmp.w   anz_zeilen(A4),D1 ;innerhalb des Sourcetextes
                bhs     main_loop       ;nein
                move.w  D1,block_anf(A4)
                move.w  D1,s_spalte(A4) ;Anfangsposition merken
                addq.w  #2,D0           ;eine Zeile weiter
                move.w  0(A0,D0.w),D1
                move.w  D1,block_end(A4) ;Blockende setzen
                jsr     update_screen
                sf      block_fl2(A4)
                bra     main_loop
                ENDPART
                >PART 's_change_def'
s_change_def:   move.w  s_zeile(A4),D0  ;Screenzeile
                lea     lin_tab2(A4),A0
                add.w   D0,D0           ;mal 2
                move.w  0(A0,D0.w),D1   ;entsp. Sourcezeile
                cmp.w   anz_zeilen(A4),D1 ;innerhalb des Sourcetextes
                bhs     main_loop       ;nein
                cmp.w   s_spalte(A4),D1 ;mit Anfangszeile vergleichen
                blo.s   s_change_def2
                move.w  s_spalte(A4),block_anf(A4)
                addq.w  #2,D0
                move.w  0(A0,D0.w),block_end(A4) ;Blockende
                jsr     update_screen
                sf      block_fl2(A4)
                bra     main_loop
s_change_def2:  move.w  D1,block_anf(A4)
                move.w  s_spalte(A4),D1
                addq.w  #1,D1
                move.w  D1,block_end(A4)
                jsr     update_screen
                sf      block_fl2(A4)
                bra     main_loop
                ENDPART
                >PART 's_change_defu'
s_change_defu3: move.w  top_line(A4),D0
                cmp.w   s_spalte(A4),D0
                bhi.s   s_change_defu5
                move.w  D0,block_anf(A4)
                move.w  s_spalte(A4),D0
                addq.w  #1,D0
                move.w  D0,block_end(A4)
                jsr     update_screen
                bra     main_loop
s_change_defu5: move.w  D0,block_end(A4)
                jsr     update_screen
                bra     main_loop
s_change_defu:  tas.b   block_fl2(A4)
                beq.s   s_change_defu3
                tst.w   top_line(A4)
                beq     main_loop
                bsr     scrolld
                lea     lin_tab2(A4),A0
                move.w  scr_z(A4),D0
                add.w   D0,D0           ;mal 2
                move.w  0(A0,D0.w),D6   ;ak. Zeile
                move.w  D6,D0
                jsr     calc_pointer    ;Zeiger auf ak. Zeile berechnen
                movem.l D0-D7/A1-A6,-(SP)
                movem.l top_ptr(A4),A3/A5-A6 ;Zeiger auf oberste Zeile
                pea     dbuffer+2(A4)   ;Buffer setzen
                jsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP           ;Stack korregieren
                clr.b   (A0)
                lea     dbuffer+2(A4),A0
                movea.l sdrv_tscradr(A4),A1
                move.w  sdrv_loffset(A4),D0
                mulu    #menu_offset,D0
                adda.w  D0,A1
                moveq   #79,D0
s_change_defu2: move.b  (A0)+,(A1)+
                dbra    D0,s_change_defu2
                move.w  top_line(A4),D0
                cmp.w   block_anf(A4),D0
                bhi.s   s_change_defu4
                moveq   #0,D0
                jsr     update_mline
                movem.l (SP)+,D0-D7/A1-A6
                subq.w  #1,block_anf(A4)
                bra     main_loop
s_change_defu4: moveq   #0,D0
                jsr     update_line
                movem.l (SP)+,D0-D7/A1-A6
                subq.w  #1,block_end(A4)
                bra     main_loop
                ENDPART
                >PART 's_change_defd'
s_change_defd3: addq.w  #1,D2
                cmp.w   block_end(A4),D2
                blo.s   s_change_defd5
                move.w  D2,block_end(A4)
                jsr     update_screen
                bra     main_loop
s_change_defd5: move.w  D2,block_anf(A4)
                move.w  s_spalte(A4),D0
                addq.w  #1,D0
                move.w  D0,block_end(A4)
                jsr     update_screen
                bra     main_loop
s_change_defd:  lea     lin_tab2(A4),A0
                move.w  sdrv_zanz(A4),D0
                add.w   D0,D0
                move.w  0(A0,D0.w),D2   ;Zeilennummer
                cmp.w   anz_zeilen(A4),D2
                bhs     main_loop
                tas.b   block_fl2(A4)
                beq.s   s_change_defd3
                bsr     scrollu
                lea     lin_tab2(A4),A0
                move.w  scr_z(A4),D0
                add.w   D0,D0           ;mal 2
                move.w  0(A0,D0.w),D6   ;ak. Zeile
                move.w  D6,D0
                jsr     calc_pointer    ;Zeiger auf ak. Zeile berechnen
                move.w  sdrv_zanz(A4),D0
                add.w   D0,D0
                move.w  0(A0,D0.w),D2   ;letzte Zeile
                move.w  D2,D0
                movem.l D0-D7/A1-A6,-(SP)
                jsr     calc_pointer
                pea     dbuffer+2(A4)   ;Buffer setzen
                jsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP           ;Stack korregieren
                clr.b   (A0)
                lea     dbuffer+2(A4),A0
                move.w  sdrv_maxcur_y(A4),D0
                mulu    sdrv_loffset(A4),D0
                movea.l sdrv_tscradr(A4),A1
                adda.w  D0,A1
                moveq   #79,D0
s_change_defd2: move.b  (A0)+,(A1)+
                dbra    D0,s_change_defd2
                movem.l (SP)+,D0-D7/A1-A6
                move.w  sdrv_zanz(A4),D0
                cmp.w   block_end(A4),D2
                blo.s   s_change_defd4
                movem.l D0/A0,-(SP)
                move.w  sdrv_zanz(A4),D0
                addq.w  #1,D0
                add.w   D0,D0
                lea     lin_tab2(A4),A0
                move.w  0(A0,D0.w),block_end(A4)
                movem.l (SP)+,D0/A0
                jsr     update_mline
                bra     main_loop
s_change_defd4: jsr     update_line
                move.w  D2,block_anf(A4)
                bra     main_loop
                ENDPART
                >PART 'zswitch' ;schaltet die Editiermodi um
zswitch0:       bsr.s   zswitch
                bra     edit02
zswitch:        addq.b  #1,ins_mode(A4)
                cmpi.b  #3,ins_mode(A4)
                blo.s   zswitch1
                sf      ins_mode(A4)
zswitch1:       move.l  zeile(A4),-(SP)
                move.b  ins_mode(A4),D0
                ext.w   D0
                lsl.w   #4,D0
                pea     mode_txt(PC,D0.w)
                move.w  #-1,zeile(A4)
                move.w  sdrv_maxcur_x(A4),D0
                sub.w   #12,D0
                move.w  D0,spalte(A4)
                jsr     print_line
                move.l  (SP)+,zeile(A4)
                rts
mode_txt:       SWITCH sprache
                DXSET 16,0
                CASE 0
                DX.B 'Überschreiben'
                DX.B 'Einfügen  I  '
                DX.B 'Einfügen  II '
                CASE 1
                DX.B 'Overwrite    '
                DX.B 'Insert I     '
                DX.B 'Insert II    '
                ENDS
                EVEN
                ENDPART
************************************************************************
*  Editor-Routinen für Steuerkommandos                                 *
************************************************************************
                >PART 's_reorg'
s_reorg:        jsr     garbage_collection
                bra     main_loop
                ENDPART
                >PART 's_change_wert'
s_change_wert:  cmpi.w  #$FFFF,(A5)
                beq     main_loop       ;letzte Zeile
                tst.l   (A5)
                beq     main_loop       ;Leerzeile
                move.l  D5,-(SP)
                bsr     s_such_syms     ;Operandennummer bestimmen (D5,A1)
                tst.w   D5
                bmi.s   s_change_w4     ;kein Operand oder Labeldefinition
                move.b  2(A5),D0
                subq.b  #2,D0           ;Sonderbefehl ?
                bge.s   s_change_w1     ;ja
s_change_w2:    tst.l   D5              ;Formel?
                bpl.s   s_change_w3     ;ja
                move.w  (A1),D0
                bmi.s   s_change_w4     ;Quick-Symbol
                tst.b   (A1)
                bne.s   s_change_w4     ;normales Symbol
s_change_w21:   andi.w  #$FFF8,(A1)
                and.w   #7,D0
                move.b  s_change_tab(PC,D0.w),D0
                or.w    D0,(A1)         ;geänderte Flags eintragen
                move.w  scr_z(A4),D0    ;ak. Screenzeile
                move.l  A1,-(SP)
                lea     lin_tab(A4),A1
                sf      0(A1,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A1
s_change_w4:    move.l  (SP)+,D5
                bra     main_loop
s_change_tab:   DC.B 1,2,4,0,5,0
                EVEN
s_change_w3:    move.w  (A1),D0         ;Formel testen
                tst.b   D0
                bmi.s   s_change_w4     ;Symbol
                bra.s   s_change_w21

s_change_w1:    moveq   #0,D0
                move.b  2(A5),D0
                move.w  s_chg_tab-2(PC,D0.w),D0
                beq.s   s_change_w4
                jmp     s_chg_tab(PC,D0.w)

                BASE DC.W,s_chg_tab
s_chg_tab:      DC.W s_change_dc,s_change_ds,0,0,0,0,s_change_equ
                DC.W 0,0,0,0,s_change_rs,s_change_rsset,0,s_change_ibytes
                DC.W s_change_base,0,0,0,s_change_if,0,0,0
                DC.W 0,s_change_dxs,s_change_ds,0,s_change_org,s_change_w3
                DC.W s_change_rs,0 ;bis $3E
                DC.W s_change_w3,s_change_case,0,0,s_change_w3,0,0,0
                DC.W 0,0,0,0,s_change_equ,0

s_change_dc:    tst.l   D5
                bpl.s   s_change_w3
                move.w  (A1),D0
                bmi     s_change_w4     ;wenn Symbol raus
                andi.w  #$FFF8,(A1)
                and.w   #7,D0
                move.b  s_change_tab2(PC,D0.w),D0
                or.w    D0,(A1)         ;geänderte Flags eintragen
s_change_w11:   move.w  scr_z(A4),D0    ;ak. Screenzeile
                move.l  A1,-(SP)
                lea     lin_tab(A4),A1
                sf      0(A1,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A1
                move.l  (SP)+,D5
                bra     main_loop

s_change_tab2:  DC.B 1,2,4,0,5,6,7,0
                EVEN
s_change_ds:    tst.w   D5
                bne     s_change_c2     ;Füllwert
                tst.l   D5
                bpl     s_change_w3     ;Formel
                moveq   #$30,D0
                and.b   3(A5),D0
                cmp.w   #$30,D0
                beq     main_loop
                andi.b  #$CF,3(A5)
                add.w   #$10,D0
                cmp.w   #$30,D0
                bne.s   s_change_ds3
                moveq   #0,D0
s_change_ds3:   or.b    D0,3(A5)
                bra.s   s_change_w11
s_change_rs:    tst.l   D5
                bpl     s_change_w3     ;Formel
                moveq   #$0C,D0
                and.b   3(A5),D0
                bne     s_change_w4
                bchg    #0,3(A5)
                bra     s_change_w4
s_change_equ:   tst.b   3(A5)
                beq     s_change_w2
                tst.l   D5
                bpl     s_change_w3     ;Formel
                bra     s_change_w4
s_change_rsset: tst.l   D5
                bpl     s_change_w3     ;Formel
                move.w  2(A5),D0
                btst    #6,D0
                bne     s_change_w4     ;Symbol oder Formel
                bchg    #4,3(A5)
                bra     s_change_w4
s_change_if:    cmpi.b  #$0E,3(A5)
                bge     s_change_w4
                bra     s_change_w3
s_change_ibytes:cmp.w   #1,D5
                blt     s_change_w4     ;Cursor auf Filename
                bgt.s   s_change_ibyt2  ;Position
                bchg    #4,3(A5)        ;Anzahl
                bra     s_change_w11
s_change_ibyt2: bchg    #0,3(A5)        ;Position
                bra     s_change_w11
s_change_case:  tst.b   3(A5)           ;folgt Zahl ?
                bmi     s_change_w4     ;nein
s_change_c2:    move.w  (A1),D0
                bra     s_change_w21    ;Zahl ändern
s_change_dxs:   tst.w   D5
                bne.s   s_change_c2     ;Füllwert
                bchg    #4,3(A5)        ;Anzahl
                bra     s_change_w4
s_change_org:   bchg    #0,5(A5)
                bra     s_change_w4
s_change_base:  tst.l   D5
                bmi     s_change_w4     ;keine Formel
                bra     s_change_w3     ;Formel ändern
                ENDPART
                >PART 's_dup_line'
s_dup_line:     lea     op_buffer(A4),A2
                move.w  (A5),D0
                cmp.w   #$FFFF,D0       ;letzte Zeile
                beq     main_loop       ;nichts machen
                cmpi.b  #$52,2(A5)      ;PART ?
                beq     main_loop       ;nichts machen
                move.w  anz_zeilen(A4),D1
                cmp.w   max_lines(A4),D1
                beq.s   no_more_mem     ;Speicher reicht nicht
                move.l  (A5),(A2)       ;Länge und Flags für Operanden
                move.w  4(A5),4(A2)     ;übertragen
                move.l  #$FFFF0000,6(A2) ;kein Label und kein Remark
                move.b  8(A5),8(A2)     ;Fehlernummer kopieren
                bra.s   s_dup_line3
no_more_mem:    lea     outofmem_rsc,A0
                jsr     _form_do
                bra     main_loop
s_dup_line2:    move.b  0(A6,D0.w),14(A2,D0.w) ;Programmcode übertragen
s_dup_line3:    dbra    D0,s_dup_line2
                bsr.s   s_dup_line0
                bpl.s   s_dup_line31
                move.w  6(A5),6(A2)     ;für EQU Labeldefinition übertragen
s_dup_line31:   moveq   #0,D0
                bsr     down
                bsr     insert_line
                bne.s   no_more_mem
                move.b  op_buffer+8(A4),8(A5) ;Fehlernummer übertragen
                bsr     change_line1
                bsr     s_ins_line2
                bra     main_loop
s_dup_line0:    lea     entry_buffer(A4),A1 ;Buffer für Adressen der Einträge
                move.l  A1,entry_pointer(A4) ;Zeiger auf Anfang setzen
                movea.l label_base(A4),A1
                cmpi.b  #2,2(A5)        ;Spezialbefehl
                bge.s   s_dup_line4     ;ja
                moveq   #0,D5           ;erster Operand
                jsr     get_index       ;auf Index prüfen
                bvs.s   s_dup_line5     ;nein
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A1,D0.l) ;Formel?
                bne.s   s_dup_line5
                bsr     s_dup_line6     ;Eintrag kopieren
                jsr     set_index       ;neuen Index eintragen
s_dup_line5:    moveq   #2,D5           ;zweiter Operand
                jsr     get_index       ;auf Index prüfen
                bvs.s   s_dup_line7     ;nein
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A1,D0.l) ;Formel
                bne.s   s_dup_line7     ;nein
                bsr     s_dup_line6     ;Eintrag kopieren
                jsr     set_index       ;neuen Index eintragen
s_dup_line7:    move    #0,CCR
                rts
s_dup_line71:   move    #$FF,CCR
                rts
s_dup_line4:    moveq   #0,D0
                move.b  2(A5),D0
                move.w  s_dupt-2(PC,D0.w),D0
                beq.s   s_dup_line7     ;kein Index
                jmp     s_dupt(PC,D0.w)

                BASE DC.W,s_dupt
s_dupt:         DC.W s_dup_line41,s_dup_line48,0,0,0,0,s_dup_line51
                DC.W 0,0,0,0,s_dup_line47,s_dup_line50,0,s_dup_line46
                DC.W s_dup_line49,s_dup_line46,0,s_dup_line46,s_dup_line42,0,0,0
                DC.W s_dup_line46,0,s_dup_line48,s_dup_line46,0
                DC.W s_dup_lin_set,s_dup_line47,0 ;bis $3E
                DC.W s_dup_line421,0,0,s_dup_line421,s_dup_lin_set,0,0,0
                DC.W 0,s_dup_line46,0,s_dup_line46,s_dup_line51,0

s_dup_line51:   moveq   #0,D0           ;EQU
                move.w  6(A5),D0
                lsl.l   #5,D0
                ori.b   #$80,6(A1,D0.l) ;Flag für doppelte Deklaration
                moveq   #0,D0
                tst.b   3(A5)           ;Index ?
                beq     s_dup_line71    ;nein
                move.w  4(A5),D0        ;Index holen
                and.w   #$3FFF,D0
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A1,D0.l) ;Formel ?
                bne     s_dup_line71    ;nein
                bsr     s_dup_line6     ;Eintrag kopieren
                andi.w  #$C000,4(A2)
                or.w    D0,4(A2)        ;neuen Index setzen
                bra     s_dup_line71

s_dup_line41:   move.l  A3,-(SP)        ;DC
                moveq   #0,D0
                move.w  4(A5),D0        ;Index holen
                andi.w  #$3FFF,D0
                lsl.l   #5,D0
                bsr     s_dup_line6     ;Eintrag kopieren
                andi.w  #$C000,4(A2)
                or.w    D0,4(A2)        ;neuen Index setzen
                ext.l   D0
                lsl.l   #5,D0
                lea     0(A1,D0.l),A3   ;Zeiger auf neuen DC-Eintrag
s_dup_line43:   moveq   #0,D0
                move.w  (A3)+,D0        ;Flagword holen
                bpl.s   s_dup_line44    ;kein Index
                and.w   #$3FFF,D0
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A1,D0.l) ;Formel
                bne.s   s_dup_line43    ;nein
                bsr     s_dup_line6     ;Eintrag kopieren
                ori.w   #$8000,D0
                move.w  D0,-2(A3)       ;neuen Index eintragen
                bra.s   s_dup_line43
s_dup_line44:   and.w   #$C0FF,D0
                cmp.w   #$FF,D0         ;Fortsetzung
                beq.s   s_dup_line45    ;ja
                cmp.w   #$FE,D0         ;Ende ?
                bne.s   s_dup_line43    ;nein
                movea.l (SP)+,A3
                bra     s_dup_line7
s_dup_line45:   moveq   #0,D0
                move.w  -2(A3),D0
                move.b  (A3),D0         ;Folgeindex holen
                lsl.l   #5,D0
                bsr     s_dup_line6     ;Eintrag kopieren
                move.b  D0,(A3)
                move.b  #$FF,D0         ;neuen Folgeindex eintragen
                move.w  D0,-2(A3)
                move.b  (A3),D0
                ext.l   D0
                lsl.l   #5,D0
                lea     0(A1,D0.l),A3   ;Zeiger auf neuen DC-Eintrag
                bra.s   s_dup_line43
s_dup_lin_set:  moveq   #0,D0
                move.w  6(A5),D0        ;Symbolindex holen
                move.w  D0,6(A2)        ;und kopieren
                lsl.l   #5,D0
                bset    #7,6(A1,D0.l)   ;Bit für doppelte Deklaration setzen
                bra.s   s_dup_line421   ;Formeleintrag duplizieren
s_dup_line42:   tst.b   3(A5)
                bne     s_dup_line7     ;keine Formel
s_dup_line421:  moveq   #0,D0
                move.w  4(A5),D0
                and.w   #$3FFF,D0       ;Index holen
                lsl.l   #5,D0
                bsr.s   s_dup_line6     ;Eintrag kopieren
                andi.w  #$C000,4(A2)
                or.w    D0,4(A2)        ;neuen Index setzen
                bra     s_dup_line7
s_dup_line46:   tst.w   4(A5)
                bmi     s_dup_line7     ;kein Eintrag
                moveq   #0,D0
                move.w  4(A5),D0
                lsl.l   #5,D0
                bsr.s   s_dup_line6     ;Eintrag kopieren
                move.w  D0,4(A2)        ;neuen Index setzen
                bra     s_dup_line7
s_dup_line47:   move.b  3(A5),D0
                andi.w  #5,D0
                cmp.w   #5,D0
                beq.s   s_dup_line49
                bra     s_dup_line7
s_dup_line48:   move.b  3(A5),D0        ;DS
                andi.w  #$30,D0
                cmp.w   #$30,D0
                beq.s   s_dup_line49
                bra     s_dup_line7
s_dup_line50:   move.w  2(A5),D0
                btst    #6,D0
                bne.s   s_dup_line49
                bra     s_dup_line7
s_dup_line49:   moveq   #0,D0
                move.w  4(A5),D0
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A1,D0.l) ;Formel ?
                bne     s_dup_line7     ;nein
                bsr.s   s_dup_line6
                move.w  D0,4(A2)        ;neuen Index setzen
                bra     s_dup_line7
s_dup_line6:    move.l  A1,-(SP)
                lea     0(A1,D0.l),A0   ;alter Eintrag
                jsr     next_free_entry ;neuen Eintrag anfordern
                move.l  (A0)+,(A1)+     ;neuer Index in D0
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                movea.l (SP)+,A1
                rts
                ENDPART
                >PART 's_line_before'
s_link_before:  tst.w   D6
                beq     main_loop       ;oberste Zeile
                bsr     up
                ENDPART
                >PART 's_link_line'
s_link_line:    cmpi.w  #$FFFF,(A5)
                beq     main_loop       ;letzte Zeile
                cmpi.w  #$52FF,2(A5)    ;eingeklappter PART ?
                beq     main_loop       ;ja
                cmpi.w  #$52F0,2(A5)    ;geschützter PART ?
                beq     main_loop       ;ja
                tst.l   (A5)            ;Befehl in der Zeile
                bne     s_link2         ;ja
                cmpi.l  #$FFFF,4(A5)    ;Label in der Zeile
                bne.s   s_link3         ;ja
                tst.b   9(A5)           ;Remark in der Zeile
                beq     s_del_line      ;nein, dann Leerzeile einfach löschen
                tst.b   19(A5)          ;in der Folgezeile ein Remark
                bne     main_loop       ;ja
                bsr     s_linksave
                move.l  10(A5),(A5)
                move.l  14(A5),4(A5)    ;Rest der Folgezeile kopieren
                move.b  18(A5),8(A5)
                move.w  scr_z(A4),D0
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A0
                bsr     down
                bra     s_link_del      ;Folgezeile löschen
s_link3:        cmpi.w  #$FFFF,16(A5)   ;in der Folgezeile ein Label
                bne     s_linke         ;ja
                bsr     s_linksave
                move.l  10(A5),(A5)
                move.w  14(A5),4(A5)    ;Befehl der Folgezeile kopieren
                move.b  18(A5),8(A5)
                move.w  scr_z(A4),D0
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A0
                tst.b   9(A5)           ;Remark in der Zeile
                beq.s   s_link5         ;nein
                bsr     down
                tst.b   9(A5)           ;in der Folgezeile ein Remark
                beq.s   s_link_del      ;nein, dann löschen
                clr.l   (A5)
                move.l  #$FFFF,4(A5)    ;sonst Remark in der Zeile lassen
                clr.b   8(A5)
                move.w  scr_z(A4),D0
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A0
                bra     main_loop
s_link5:        move.b  19(A5),9(A5)    ;Remark kopieren
                bsr     down
                bra.s   s_link_del      ;Folgezeile löschen
s_link2:        tst.b   9(A5)           ;Remark in der Zeile
                bne.s   s_linke         ;ja
                tst.l   10(A5)
                bne.s   s_linke
                cmpi.l  #$FFFF,14(A5)   ;enthält die Folgezeile nur
                bne.s   s_linke         ;einen Remark
                bsr.s   s_linksave
                move.b  19(A5),9(A5)    ;Remark umkopieren
                move.w  scr_z(A4),D0
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A0
                bsr     down
                bra.s   s_link_del      ;und Folgezeile löschen
s_linke:        bra     main_loop

s_linksave:     move.w  D6,s_undo_zeile(A4)
                movea.l A5,A1
                lea     undo_buff(A4),A0
                move.w  #$80,(A0)+      ;Kennung für Shift Delete
                moveq   #4,D0
s_linksave2:    move.l  (A1)+,(A0)+
                dbra    D0,s_linksave2
                rts

s_link_del:     move.w  #$81,undo_buff(A4) ;Kennung für gelöschte Zeile
                movea.l A5,A1
                lea     10(A1),A0
                move.w  anz_zeilen(A4),D1
                sub.w   D6,D1
                bra.s   s_link9
s_link8:        move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+
                move.w  (A0)+,(A1)+
s_link9:        dbra    D1,s_link8
                subi.l  #10,z_info_top(A4)
                subq.w  #1,anz_zeilen(A4)
                bsr     s_del_line2
                bra     s_up
                ENDPART
                >PART 's_merk_line'
s_merk_line:    cmpi.w  #$FFFF,(A5)     ;letzte Zeile
                beq     main_loop
                cmpi.b  #$52,2(A5)      ;PART-Befehl?
                beq     main_loop       ;ja
                movem.l D0-D7/A1-A6,-(SP)
                pea     merk_buff+2(A4) ;Puffer für zu merkende Zeile
                jsr     disass          ;hinein disassemblieren
                addq.l  #4,SP
                clr.b   (A0)            ;Nullbyte ans Ende
                move.l  A0,D0
                sub.l   A4,D0
                subi.w  #merk_buff+2,D0 ;Länge der Zeile
                lea     merk_buff(A4),A0
                move.w  D0,(A0)         ;in Buffer eintragen
                movem.l (SP)+,D0-D7/A1-A6
                bra     s_del_line      ;Zeile löschen
                ENDPART
                >PART 's_ins_merk'
s_ins_merk:     bsr     insert_line
                bne     no_more_mem     ;Speicher reicht nicht
                bsr     s_ins_line2     ;Zeile einfügen
                lea     merk_buff(A4),A0
                lea     zeingabe(A4),A1
                moveq   #63,D0
s_ins_merk2:    move.l  (A0)+,(A1)+
                dbra    D0,s_ins_merk2
                movea.l ass_stack(A4),SP
                st      action_fl(A4)
                move.b  #1,load_fl(A4)
                move.l  #$500000,-(SP)  ;Scancode für Crsr down
                bra     zcr3
                ENDPART
                >PART 's_return'
s_return:       cmpi.b  #2,ins_mode(A4) ;Insert II mit Einfügen von Leerzeilen
                beq.s   s_return1       ;ja
s_return02:     clr.w   save_pos(A4)
                bra     s_down
s_return01:     clr.l   (A5)
                move.l  #$FFFF,4(A5)    ;Leerzeile produzieren
                clr.w   8(A5)
                moveq   #$FF,D0
                move.w  D0,10(A5)       ;neue Endekennung setzen
                move.w  D0,16(A5)
                clr.w   18(A5)          ;Fehlernummer löschen
                moveq   #10,D0
                add.l   D0,z_info_top(A4) ;eine Zeile dazu
                addq.w  #1,anz_zeilen(A4)
                bsr     s_ins_line2
                bra     s_down
s_return1:      move.w  scr_z(A4),D0
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;Updateflag setzen
                movea.l (SP)+,A0
                tst.w   (A5)            ;Befehlslänge
                bmi.s   s_return01      ;Endekennung (Sonderfall !!)
                move.w  save_pos(A4),D1 ;Cursorposition beim Verlassen
                beq     s_return23      ;null -> Zeile nach unten
                addq.w  #1,D1
                lea     zeingabe+2(A4),A0 ;Zeiger auf eingegebene Zeile
                clr.w   save_pos(A4)
s_return11:     subq.w  #1,D1
                cmpi.b  #' ',(A0)+
                beq.s   s_return11
                tst.b   -(A0)           ;Leerzeile
                beq.s   s_return23      ;dann Zeilen nach unten
                addq.w  #1,D1
                bmi.s   s_return23      ;gesamte Zeile nach unten
                tst.w   6(A5)           ;Label definiert ?
                bmi.s   s_return18      ;nein
s_return13:     subq.w  #1,D1
                move.b  (A0)+,D0        ;Ende des Symbols suchen
                beq.s   s_return14
                cmp.b   #' ',D0
                beq.s   s_return14
                cmp.b   #':',D0
                bne.s   s_return13
                cmpi.b  #':',(A0)       ;noch ein ':' bei globalen Symbol
                bne.s   s_return14      ;nein
                addq.l  #1,A0           ;sonst überlesen
                subq.w  #1,D1
s_return14:     tst.w   D1
                bmi.s   s_return23      ;gesamte Zeile nach unten
s_return18:     subq.w  #1,D1
                cmpi.b  #' ',(A0)+
                beq.s   s_return18
                tst.w   D1
                ble     s_return24      ;Befehl und Remark nach unten
s_return12:     subq.w  #1,D1
                move.b  (A0)+,D0
                beq.s   s_return19      ;Cursor am Ende der Zeile
                cmp.b   #' ',D0
                bne.s   s_return12      ;sucht nach ' ;'
                cmpi.b  #';',(A0)
                bne.s   s_return12
                subq.w  #1,D1
                bgt.s   s_return19      ;Cursor am Ende der Zeile
                subq.w  #1,D1
s_return15:     addq.w  #1,D1
                cmpi.b  #' ',-(A0)
                beq.s   s_return15
                tst.w   D1
                bmi.s   s_return24      ;Befehl und Remark nach unten
                bra     s_return25      ;nur Remark nach unten
s_return19:     move.w  anz_zeilen(A4),D0
                subq.w  #1,D0
                cmp.w   D0,D6
                bhs     s_down          ;vorletzte Zeile
                bsr     s_return_ins    ;sonst Leerzeile einfügen
                move.w  D2,s_undo_zeile(A4) ;folgende Zeile
                move.w  #$8001,undo_buff(A4) ;Daten für UNDO
                bra     s_down
s_return23:     bsr     s_return_ins1
                move.w  D6,s_undo_zeile(A4)
                move.w  #$8001,undo_buff(A4) ;Daten für Undo
                move.l  (A5),10(A5)
                move.l  4(A5),14(A5)    ;Cursor vor Label->gesamte Zeile nach unten
                move.w  8(A5),18(A5)
                clr.l   (A5)
                move.l  #$FFFF,4(A5)
                clr.w   8(A5)
s_return242:    cmpi.w  #$52FF,12(A5)   ;PART-Zeile ?
                bne.s   s_return241     ;nein
                jsr     search_part     ;PART-Tabelle neu berechnen
                bsr     redraw_all      ;Bildschirm updaten
s_return241:    bra     s_down
s_return24:     move.b  2(A5),D1
                cmp.b   #$0E,D1         ;EQU
                beq.s   s_return241
                cmp.b   #$58,D1         ;==
                beq.s   s_return241
                cmp.b   #$3E,D1         ;SET
                beq.s   s_return241
                cmp.b   #$1C,D1         ;REG
                beq.s   s_return241
                bsr     insert_line     ;Zeile einfügen
                bne.s   no_more_mem2    ;Speicher reicht nicht
                bsr     s_ins_line2     ;Marker anpassen
                move.w  16(A5),6(A5)    ;Symbol übertragen
                move.w  #$FFFF,16(A5)   ;Symbol löschen
;                bsr.s   s_return_ins1
;                move.l  (A5),10(A5)     ;Cursor hinter Label->nur Befehl und Remark
;                move.w  4(A5),14(A5)    ;nach unten
;                move.w  8(A5),18(A5)
                clr.l   (A5)
                clr.w   4(A5)
                clr.w   8(A5)
                bra.s   s_return242
s_return25:     cmpi.w  #$52FF,2(A5)    ;PART-Zeile?
                beq.s   s_return241     ;ja, geht nicht
                cmpi.w  #$52F0,2(A5)    ;geschützter PART?
                beq.s   s_return241
                bsr.s   s_return_ins1
                move.b  9(A5),19(A5)    ;Cursor vor Remark->nur Remark nach unten
                clr.b   9(A5)
                bra     s_down
s_return_ins:   cmpi.w  #$52FF,2(A5)    ;PART-Zeile?
                beq.s   s_return_ins2   ;ja
                cmpi.w  #$52F0,2(A5)
                beq.s   s_return_ins2
s_return_ins1:  lea     10(A5),A5
                addq.w  #1,D6
                move.w  D6,D2           ;Zeilennummer merken
                bsr     insert_line
                bne.s   no_more_mem2    ;Speicher reicht nicht
                bsr     s_ins_line2
                lea     -10(A5),A5
                subq.w  #1,D6
                rts
no_more_mem2:   subq.w  #1,D6
no_more_mem4:   move.w  D6,D0
                jsr     calc_pointer    ;Zeiger auf ak. Zeile neu berechnen
                bra     no_more_mem     ;'Speicher reicht nicht' ausgeben
s_return_ins2:  lea     lin_tab2(A4),A0
                movem.l D6/A5,-(SP)     ;alte Zeilennummer retten
                move.w  scr_z(A4),D0
                add.w   D0,D0           ;mal 2
                move.w  2(A0,D0.w),D2   ;neue Zeilennummer
                move.w  D2,D0
                sub.w   D6,D0           ;Differenz bilden
                mulu    #10,D0          ;ein Eintrag = 10 Bytes
                adda.w  D0,A5           ;Zeiger auf Zeileninfo erhöhen
                move.w  D2,D6
                bsr     insert_line
                bne.s   no_more_mem3    ;Speicher reicht nicht
                bsr     s_ins_line2
                movem.l (SP)+,D6/A5     ;alte Zeilennummer zurückholen
                rts
no_more_mem3:   movem.l (SP)+,D6/A5
                bra.s   no_more_mem4
                ENDPART
                >PART 'check_mem' ;reicht der Speicher? Z=1, wenn ja
check_mem:      moveq   #8,D1
                add.w   label_top_ind(A4),D1 ;Labeleinträge testen
                cmp.w   max_index(A4),D1 ;8 mehr müssen vorhanden sein
                bhs.s   check_mem_err
                moveq   #127,D1
                add.l   program_top(A4),D1 ;Codelänge testen
                cmp.l   program_max(A4),D1 ;128 Byte mehr müssen da sein
                bhs.s   check_mem_err
                moveq   #127,D1
                add.l   comment_top(A4),D1 ;Remarklänge testen
                cmp.l   comment_max(A4),D1 ;128 Byte mehr müssen da sein
                bhs.s   check_mem_err
                move.w  anz_zeilen(A4),D1 ;Zeilenanzahl testen
                addq.w  #1,D1
                cmp.w   max_lines(A4),D1 ;mit max.Anzahl+2 vergleichen
                bhs.s   check_mem_err
                cmp.b   D0,D0           ;Z=1
                rts
check_mem_err:  moveq   #-1,D1          ;Z=0
                rts
                ENDPART
                >PART 'change_line'
change_line:    cmp.w   anz_zeilen(A4),D6 ;an den Source anhängen?
                bne.s   change_line1    ;Nein =>
                bsr     insert_line
                bne     no_more_mem     ;reicht der Speicher? Nein =>
change_line1:   bsr.s   check_mem       ;reicht der Speicher?
                bne     no_more_mem     ;Nein =>
                lea     op_buffer(A4),A2
                jsr     label_abmelden  ;alte Einträge der Zeile rauswerfen
                moveq   #0,D0
                move.w  (A5),D0         ;Länge der alten Zeile merken
                move.l  (A2),(A5)
                move.l  4(A2),4(A5)     ;Zeileninfo übertragen

                sub.w   (A5),D0         ;Platz für Zielcode machen
                bgt.s   change_line8
                beq.s   change_line15
                neg.w   D0
                movea.l program_top(A4),A0
                lea     0(A0,D0.w),A1
                move.w  (A0),(A1)
                move.l  A0,D1
                sub.l   A6,D1
                lsr.l   #2,D1
                bcc.s   change_line2
                move.w  -(A0),-(A1)
change_line2:   lsr.l   #1,D1
                bcc.s   change_line3
                move.l  -(A0),-(A1)
change_line3:   lsr.l   #1,D1
                bcc.s   change_line7
                bra.s   change_line6
change_line4:   swap    D1
change_line5:   move.l  -(A0),-(A1)
                move.l  -(A0),-(A1)
change_line6:   move.l  -(A0),-(A1)
                move.l  -(A0),-(A1)
change_line7:   dbra    D1,change_line5
                swap    D1
                dbra    D1,change_line4
                add.l   D0,program_top(A4)
                bra.s   change_line15
change_line8:   movea.l A6,A0
                move.l  program_top(A4),D1
                sub.l   A0,D1
                lea     0(A0,D0.w),A1
                move.w  (A1)+,(A0)+
                lsr.l   #2,D1
                bcc.s   change_line9
                move.w  (A1)+,(A0)+
change_line9:   lsr.l   #1,D1
                bcc.s   change_line10
                move.l  (A1)+,(A0)+
change_line10:  lsr.l   #1,D1
                bcc.s   change_line14
                bra.s   change_line13
change_line11:  swap    D1
change_line12:  move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
change_line13:  move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
change_line14:  dbra    D1,change_line12
                swap    D1
                dbra    D1,change_line11
                sub.l   D0,program_top(A4)

change_line15:  move.w  (A5),D0
                bra.s   change_line17
change_line16:  move.b  14(A2,D0.w),0(A6,D0.w) ;Zielcode übertragen
change_line17:  dbra    D0,change_line16

************************************************************************
* Remark in Tabelle eintragen                                          *
************************************************************************
                movea.l comment_top(A4),A0
                moveq   #0,D0
                moveq   #0,D1
                move.b  9(A5),D0        ;Länge des derzeitigen Remarks
                move.b  9(A2),D1        ;Länge des neuen Remarks
                sub.w   D1,D0
                beq.s   change_line31   ;gleich
                bpl.s   change_line24   ;der neue ist kürzer
                neg.w   D0
                lea     0(A0,D0.w),A1
                move.w  (A0),(A1)
                move.l  A0,D1
                sub.l   A3,D1
                lsr.l   #2,D1
                bcc.s   change_line18
                move.w  -(A0),-(A1)
change_line18:  lsr.l   #1,D1
                bcc.s   change_line19
                move.l  -(A0),-(A1)
change_line19:  lsr.l   #1,D1
                bcc.s   change_line23
                bra.s   change_line22
change_line20:  swap    D1
change_line21:  move.l  -(A0),-(A1)
                move.l  -(A0),-(A1)
change_line22:  move.l  -(A0),-(A1)
                move.l  -(A0),-(A1)
change_line23:  dbra    D1,change_line21
                swap    D1
                dbra    D1,change_line20
                add.l   D0,comment_top(A4)
                bra.s   change_line31
change_line24:  movea.l A3,A0
                move.l  comment_top(A4),D1
                sub.l   A0,D1
                lea     0(A0,D0.w),A1
                move.w  (A1)+,(A0)+
                lsr.l   #2,D1
                bcc.s   change_line25
                move.w  (A1)+,(A0)+
change_line25:  lsr.l   #1,D1
                bcc.s   change_line26
                move.l  (A1)+,(A0)+
change_line26:  lsr.l   #1,D1
                bcc.s   change_line30
                bra.s   change_line29
change_line27:  swap    D1
change_line28:  move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
change_line29:  move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
change_line30:  dbra    D1,change_line28
                swap    D1
                dbra    D1,change_line27
                sub.l   D0,comment_top(A4)
change_line31:  movea.l A3,A1
                move.b  9(A2),D0
                move.b  D0,9(A5)        ;Länge übertragen
                lsr.w   #1,D0
                movea.l 10(A2),A0       ;Zeiger auf Remark nach A0
                bra.s   change_line33
change_line32:  move.w  (A0)+,(A1)+
change_line33:  dbra    D0,change_line32
                rts
                ENDPART
                >PART 'insert_line'
insert_line:    bsr     check_mem       ;reicht der Speicher?
                bne.s   insert_line3    ;Nein =>
                moveq   #10,D1
                add.l   D1,z_info_top(A4)
                move.w  anz_zeilen(A4),D1 ;Zeilenanzahl testen
                movea.l z_info_top(A4),A2
                sub.w   D6,D1
                blo.s   insert_line2
                lea     10(A2),A1
insert_line1:   move.l  -(A2),-(A1)
                move.l  -(A2),-(A1)
                move.w  -(A2),-(A1)
                dbra    D1,insert_line1
insert_line2:   clr.l   (A5)
                clr.l   4(A5)
                subq.w  #1,6(A5)
                clr.w   8(A5)
                addq.w  #1,anz_zeilen(A4)
                st      change_flag(A4) ;Sourcetext geändert
                cmp.b   D0,D0           ;Z=1, alles ok
insert_line3:   rts
                ENDPART
                >PART 'delete_line'
delete_line:    cmp.w   anz_zeilen(A4),D6
                blo.s   delete_line1
                rts
delete_line1:   bsr     del_entry
                moveq   #0,D0
                moveq   #0,D2
                move.b  9(A5),D2
                move.w  (A5),D0
                movea.l A5,A2
                lea     10(A2),A0
                move.w  anz_zeilen(A4),D1
                sub.w   D6,D1
                bra.s   delete_line3
delete_line2:   move.l  (A0)+,(A2)+
                move.l  (A0)+,(A2)+
                move.w  (A0)+,(A2)+
delete_line3:   dbra    D1,delete_line2
                movea.l A6,A0
                lea     0(A6,D0.w),A1
                move.l  program_top(A4),D1
                sub.l   A0,D1
                lsr.l   #2,D1
                bcc.s   delete_line4
                move.w  (A1)+,(A0)+
delete_line4:   lsr.l   #1,D1
                bcc.s   delete_line5
                move.l  (A1)+,(A0)+
delete_line5:   lsr.l   #1,D1
                bcc.s   delete_line9
                bra.s   delete_line8
delete_line6:   swap    D1
delete_line7:   move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
delete_line8:   move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
delete_line9:   dbra    D1,delete_line7
                swap    D1
                dbra    D1,delete_line6
                sub.l   D0,program_top(A4)
                subi.l  #10,z_info_top(A4)
                movea.l z_info_top(A4),A0
                move.w  #$FFFF,(A0)
                subq.w  #1,anz_zeilen(A4)
                st      change_flag(A4) ;Sourcetext geändert
                tst.w   D2
                beq.s   delete_line16
                move.l  comment_top(A4),D1
                movea.l A3,A0
                lea     0(A0,D2.w),A1   ;D2=Länge des Remarks
                sub.l   A0,D1
                lsr.l   #2,D1
                bcc.s   delete_line10
                move.w  (A1)+,(A0)+
delete_line10:  lsr.l   #1,D1
                bcc.s   delete_line11
                move.l  (A1)+,(A0)+
delete_line11:  lsr.l   #1,D1
                bcc.s   delete_line15
                bra.s   delete_line14
delete_line12:  swap    D1
delete_line13:  move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
delete_line14:  move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+
delete_line15:  dbra    D1,delete_line13
                swap    D1
                dbra    D1,delete_line12
                sub.l   D2,comment_top(A4)
delete_line16:  rts
                ENDPART
                >PART 'del_entryc'
************************************************************************
* Löscht alle Einträge, die eine Zeile benutzt hat                     *
************************************************************************
del_entryc:     movea.l label_base(A4),A0 ;Routine für Zeile ändern
                moveq   #0,D0
                move.w  6(A5),D0        ;Label definiert
                bmi     del_entry2      ;nein
                move.w  D0,D1
                lsl.l   #5,D0
                tst.b   6(A0,D0.l)      ;doppelte Deklaration
                bpl     del_entry03     ;nein
                movem.l D2/A1-A2,-(SP)
                moveq   #-1,D2
                bra.s   del_entryc2
del_entry:      movea.l label_base(A4),A0 ;Routine für Zeile löschen
                moveq   #0,D0
                move.w  6(A5),D0        ;Label definiert
                bmi     del_entry2      ;nein
                move.w  D0,D1
                lsl.l   #5,D0
                tst.b   6(A0,D0.l)      ;doppelte Deklaration
                bpl.s   del_entry03     ;nein=>
                movem.l D2/A1-A2,-(SP)
                moveq   #-2,D2
del_entryc2:    movea.l z_info_base(A4),A1
del_entry01:    cmp.w   6(A1),D1
                bne.s   del_entry02
                addq.w  #1,D2
                cmpa.l  A1,A5           ;ak. Zeile?
                beq.s   del_entry02     ;ja=>
                movea.l A1,A2           ;Zeiger auf Zeile merken
del_entry02:    lea     10(A1),A1       ;nächste Zeile
                tst.w   (A1)            ;Länge testen
                bpl.s   del_entry01
                tst.w   D2              ;Anzahl testen
                bne.s   del_entry04     ;mehr als 1 mal=>
                andi.b  #$7F,6(A0,D0.l) ;Flag für doppelte Deklaration löschen
                bclr    #6,4(A0,D0.l)   ;Konstantenbit löschen
                sf      5(A0,D0.l)      ;relozierbarer Wert
                cmpi.w  #$0200,2(A2)    ;Sonderbefehl?
                blo.s   del_entry04     ;nein=>
                move.b  2(A2),D2        ;Befehl holen
                cmp.b   #$0E,D2         ;EQU?
                beq.s   del_entry05     ;ja=>
                cmp.b   #$1C,D2         ;REG?
                beq.s   del_entry06     ;ja=>
                cmp.b   #$18,D2         ;RS?
                bne.s   del_entry04     ;nein=>
                move.b  #$FC,5(A0,D0.l) ;RS-Konstantenflag setzen
del_entry07:    bset    #6,4(A0,D0.l)   ;Konstantenbit setzen
del_entry04:    movem.l (SP)+,D2/A1-A2
                bra.s   del_entry2
del_entry06:    move.b  #1,5(A0,D0.l)   ;Registerliste
                bra.s   del_entry07
del_entry05:    st      5(A0,D0.l)      ;Konstantenflag setzen
                bra.s   del_entry07
del_entry03:    andi.b  #$7F,4(A0,D0.l) ;defined-flag löschen
del_entry2:     pea     del_entry8(PC)  ;Rücksprungadresse für 2. Opcode
                moveq   #0,D0
                move.w  2(A5),D0
                bmi.s   del_entry4      ;Quick
                cmp.w   #$0200,D0
                bhs.s   del_entry3      ;Sonderbefehle
                cmp.w   #$0100,D0
                bhs.s   del_entry7      ;Labeleintrag
del_entry8:     moveq   #0,D0
                move.w  4(A5),D0
                bmi.s   del_entry4      ;Quick
                cmp.w   #$0100,D0
                blo.s   del_entry6      ;kein Symbol
del_entry7:     move.w  D0,D1
                andi.w  #$0F,D0         ;EOffset
                move.l  0(A6,D0.w),D0   ;Index
                btst    #5,D1
                bne     del_equ2        ;war Long
                swap    D0
                ext.l   D0
                bra     del_equ2
del_entry6:     rts
del_entry4:     btst    #14,D0
                beq.s   del_entry41     ;xx(Ax,Rx)
                andi.w  #$3FFF,D0
                bra     del_equ2
del_entry41:    and.w   #$3FFF,D0
                moveq   #$0F,D1
                and.w   D0,D1           ;EOffset
                move.b  0(A6,D1.w),D0   ;LowByte einsetzen
                bra     del_equ2
del_entry3:     addq.l  #4,SP           ;Rücksprung vom Stack
                lsr.w   #8,D0
                move.w  del_tab-2(PC,D0.w),D0
                beq.s   del_entry6
                jmp     del_tab(PC,D0.w) ;Sprung zur Routine

                BASE DC.W,del_tab
del_tab:        DC.W del_dc,del_ds,del_s,del_s,del_s,0,del_equ
                DC.W 0,0,0,0,del_rs,del_rss,0,del_en
                DC.W del_base,del_en,0,del_en,del_if,0,0,0
                DC.W del_en,0,del_ds,del_fail,0
                DC.W del_en,del_rs,0 ;bis $3E
                DC.W del_en,0,0,del_en,del_en,0,0,0
                DC.W 0,del_fail,0,del_en,del_equ,0

del_s:          lea     text_pointer(A4),A0
                moveq   #0,D0
                move.b  2(A5),D0
                move.w  #$FFFF,-6(A0,D0.w)
                rts
del_en:         moveq   #0,D0           ;einfachen Eintrag löschen
                move.w  4(A5),D0
del_en4:        cmp.w   label_top_ind(A4),D0 ;letzter Eintrag
                beq.s   del_en3         ;ja
                lsl.l   #5,D0
                move.b  #1,31(A0,D0.l)  ;Eintrag als frei deklarieren
                st      entry_free(A4)
                rts
del_en3:        subq.w  #1,label_top_ind(A4) ;letzten Eintrag löschen
                subi.l  #32,label_top(A4)
del_en2:        rts
del_rs:         moveq   #5,D0
                and.b   3(A5),D0
                cmp.w   #5,D0
                bne.s   del_en2
del_if:         moveq   #0,D0
                move.w  4(A5),D0
                andi.w  #$3FFF,D0
                bra.s   del_equ2
del_fail:       moveq   #0,D0
                move.w  4(A5),D0        ;Index holen
                bmi.s   del_en2         ;kein Eintrag
                bra.s   del_en4         ;Eintrag löschen
del_ds:         moveq   #$30,D0
                and.b   3(A5),D0
                cmp.w   #$30,D0
                bne.s   del_en2
                moveq   #0,D0
                move.w  4(A5),D0
                bra.s   del_equ2
del_rss:        move.w  2(A5),D0
                btst    #6,D0
                beq.s   del_en2
                moveq   #0,D0
                move.w  4(A5),D0
                bra.s   del_equ2
del_base:       moveq   #0,D0
                move.w  4(A5),D0
                bpl.s   del_equ2        ;Symbol oder Formel
                rts
del_equ:        moveq   #0,D0
                move.w  4(A5),D0
                bpl.s   del_en2         ;kein Symbol
                andi.w  #$3FFF,D0
del_equ2:       move.w  D0,D1
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A0,D0.l) ;Formel
                bne.s   del_en2         ;nein
                cmp.w   label_top_ind(A4),D1 ;letzter Eintrag
                beq.s   del_en3
                move.b  #1,31(A0,D0.l)  ;Eintrag als frei deklarieren
                st      entry_free(A4)
                rts
del_dc:         moveq   #0,D0
                move.w  4(A5),D0
del_dc5:        andi.w  #$3FFF,D0
                move.l  D0,D1
                bsr     del_en4         ;DC-Eintrag löschen
                lsl.l   #5,D1
                lea     0(A0,D1.l),A1   ;Zeiger auf DC-Eintrag
del_dc3:        move.w  (A1)+,D0
                bmi.s   del_dc2
                cmp.b   #$FF,D0         ;Fortsetzungskennung ?
                beq.s   del_dc4         ;ja
                cmp.w   #$FE,D0         ;Endekennung ?
                bne.s   del_dc3         ;nein
                rts
del_dc2:        andi.w  #$3FFF,D0
                ext.l   D0
                bsr.s   del_equ2        ;Formeleintrag löschen
                bra.s   del_dc3
del_dc4:        move.b  (A1),D0         ;Low-Byte des Index einsetzen
                ext.l   D0              ;high word löschen
                bra.s   del_dc5
                ENDPART
                >PART 's_down'
s_down:         bsr.s   down
                bra     main_loop
                ENDPART
                >PART 'down'
down:           cmp.w   anz_zeilen(A4),D6
                bhi.s   down1           ;sicher ist sicher
                beq.s   down3           ;in letzter Zeile
                move.w  sdrv_zanz(A4),D0
                cmp.w   scr_z(A4),D0
                beq.s   down4
                addq.w  #1,scr_z(A4)
                move.w  scr_z(A4),D0
                add.w   D0,D0           ;mal 2
                lea     lin_tab2(A4),A0
                move.w  0(A0,D0.w),D0   ;Zeilennummer holen
                moveq   #0,D1
down2:          move.b  9(A5),D1
                adda.w  D1,A3
                adda.w  (A5),A6
                lea     10(A5),A5
                addq.w  #1,D6
                cmp.w   D0,D6
                blo.s   down2           ;Zeile noch nicht erreicht
down3:          rts
down1:          jmp     s_pgend
down4:          bsr.s   scrollu
                move.w  sdrv_zanz(A4),D0
                add.w   D0,D0
                lea     lin_tab2(A4),A3
                move.w  0(A3,D0.w),D6   ;unterste Zeile->ak. Zeile
                move.w  D6,D0
                moveq   #0,D1
                movem.l top_ptr(A4),A3/A5-A6 ;berechnet Zeiger der Zeile in D0
                sub.w   top_line(A4),D0 ;auf das Programm
                bra.s   calc_loop22
calc_loop21:    move.b  9(A5),D1
                adda.w  D1,A3
                adda.w  (A5),A6         ;eine Zeile weiter
                lea     10(A5),A5
calc_loop22:    dbra    D0,calc_loop21
                rts
                ENDPART
                >PART 'scrollu'
scrollu:        lea     lin_tab(A4),A0
                lea     1(A0),A1
                move.w  sdrv_zanz(A4),D0
                subq.w  #1,D0
scrolu1:        move.b  (A1)+,(A0)+
                dbra    D0,scrolu1
                sf      (A0)
                lea     lin_tab2(A4),A0
                lea     2(A0),A1
                move.w  sdrv_zanz(A4),D0 ;ein Eintrag mehr als Zeilen da
scrolu2:        move.w  (A1)+,(A0)+
                dbra    D0,scrolu2
                lea     partbuffer-4(A4),A1
                move.w  (A0),D0         ;zu testende Zeilennummer
scrolu3:        addq.l  #4,A1
                tst.l   (A1)
                beq.s   scrolu4         ;Ende der Tabelle
                cmp.w   (A1),D0
                bne.s   scrolu3         ;ungleich
                move.w  2(A1),(A0)      ;auf das Ende des Blocks
scrolu4:        addq.w  #1,(A0)
                jsr     scroll_up
                move.w  lin_tab2(A4),D0 ;neue oberste Zeile
                sub.w   top_line(A4),D0 ;minus der alten
                subq.w  #1,D0           ;wegen DBRA-Schleife
                bra     top_pl2         ;Pointer auf top_line setzen
                ENDPART
                >PART 's_up'
s_up:           cmp.w   anz_zeilen(A4),D6
                bhi     down1           ;sicher ist sicher
                bsr.s   up
                bra     main_loop
                ENDPART
                >PART 'up'
up:             tst.w   D6
                beq.s   up3
                tst.w   scr_z(A4)
                beq.s   up4
                subq.w  #1,scr_z(A4)
                move.w  scr_z(A4),D0
                add.w   D0,D0           ;mal 2
                lea     lin_tab2(A4),A0
                move.w  0(A0,D0.w),D0   ;Zeilenummer holen
                moveq   #0,D1
up2:            lea     -10(A5),A5
                suba.w  (A5),A6
                move.b  9(A5),D1
                suba.w  D1,A3
                subq.w  #1,D6
                cmp.w   D0,D6
                bhi.s   up2             ;Zeile noch nicht erreicht
up3:            rts
up4:            bsr.s   scrolld
                move.w  top_line(A4),D6 ;oberste Zeile->ak. Zeile
                movem.l top_ptr(A4),A3/A5-A6 ;Zeiger auf ak. Zeile
                rts
                ENDPART
                >PART 'scrolld'
scrolld:        move.w  sdrv_zanz(A4),D0
                addq.w  #1,D0
                lea     lin_tab(A4),A0
                adda.w  D0,A0
                lea     -1(A0),A1
                subq.w  #2,D0
scrold1:        move.b  -(A1),-(A0)
                dbra    D0,scrold1
                sf      -(A0)
                move.w  sdrv_zanz(A4),D0
                add.w   D0,D0
                addq.w  #4,D0
                lea     lin_tab2(A4),A0
                adda.w  D0,A0
                lea     -2(A0),A1
                move.w  sdrv_zanz(A4),D0 ;ein Eintrag mehr als Zeilen da
scrold2:        move.w  -(A1),-(A0)
                dbra    D0,scrold2
                lea     partbuffer-4(A4),A1
                subq.w  #1,-(A0)
                move.w  (A0),D0         ;Zeilennummer holen
scrold3:        addq.l  #4,A1
                tst.l   (A1)
                beq.s   scrold4         ;Ende der Tabelle
                cmp.w   2(A1),D0        ;mit Endzeile vergleichen
                bne.s   scrold3
                move.w  (A1),(A0)       ;Block überspringen
scrold4:        jsr     scroll_dn
                move.w  top_line(A4),D0 ;neue top_line
                sub.w   lin_tab2(A4),D0 ;minus der alten
                subq.w  #1,D0
                bra.s   top_mi2         ;Zeiger auf top_line berechnen
                ENDPART
                >PART 'top_pl2'
top_pl2:        movem.l top_ptr(A4),A0-A2
                moveq   #0,D1
top_pl3:        move.b  9(A1),D1
                adda.w  D1,A0
                adda.w  (A1),A2
                lea     10(A1),A1
                addq.w  #1,top_line(A4)
                dbra    D0,top_pl3
                movem.l A0-A2,top_ptr(A4)
                rts
                ENDPART
                >PART 'top_mi2'
top_mi2:        movem.l top_ptr(A4),A0-A2
                moveq   #0,D1
top_mi21:       lea     -10(A1),A1
                suba.w  (A1),A2
                move.b  9(A1),D1
                suba.w  D1,A0
                subq.w  #1,top_line(A4)
                dbra    D0,top_mi21
                movem.l A0-A2,top_ptr(A4)
                rts
                ENDPART
                >PART 's_del_line'
s_del_line:     moveq   #0,D0
                jsr     error_out
                cmp.w   anz_zeilen(A4),D6 ;letzte Zeile
                beq     main_loop       ;ja, zurück
                cmpi.w  #$52F0,2(A5)    ;geschützter PART ?
                beq     main_loop       ;ja
                move.w  D6,s_undo_zeile(A4)
                lea     undo_buff(A4),A1 ;Zeiger auf Puffer
                move.w  #$8000,(A1)+    ;Flag für Zeile gelöscht
                lea     zeingabe(A4),A0 ;ak. Zeile
                moveq   #63,D0
s_del_line3:    move.l  (A0)+,(A1)+     ;Zeile sichern
                dbra    D0,s_del_line3
                bsr     delete_line
                bsr.s   s_del_line2
                bra     main_loop

s_del_line2:    clr.w   error_pos(A4)
                movem.l D1/D6/A3/A5-A6,-(SP)
                move.w  scr_z(A4),D0
                jsr     scroll_up2      ;Screen ab akt. Zeile hochscrollen
                lea     marker(A4),A2
                moveq   #12,D1          ;10 Marker + TEXT,DATA,BSS
s_del2:         move.w  (A2)+,D0
                cmp.w   #$FFFF,D0       ;Marker nicht gesetzt
                beq.s   s_del4
                cmp.w   D6,D0           ;Marker vor zu löschender Zeile
                blo.s   s_del4
                bne.s   s_del3
                moveq   #0,D0           ;Marker = ak. Zeile
s_del3:         subq.w  #1,D0
                move.w  D0,-2(A2)
s_del4:         dbra    D1,s_del2       ;nächsten Marker
                moveq   #$FF,D0
                lea     block_end(A4),A0
                cmp.l   -2(A0),D0
                beq.s   s_del46         ;kein Block definiert
                cmp.w   (A0),D6
                bhs.s   s_del45
                cmp.w   (A0),D0         ;Blockende=$ffff
                beq.s   s_del45
                subq.w  #1,(A0)
s_del45:        cmp.w   -(A0),D6
                bhi.s   s_del46         ;Cursor hinter Anfang
                blo.s   s_del47         ;Cursor vor Block
                cmp.w   2(A0),D6        ;Blockanfang gleich Blockende ?
                bne.s   s_del46         ;nein
                move.l  D0,(A0)         ;Blockmarken löschen
                bra.s   s_del46
s_del47:        subq.w  #1,(A0)
s_del46:        lea     partbuffer-4(A4),A0
s_del50:        addq.l  #4,A0
                tst.l   (A0)
                beq.s   s_del51         ;Ende der Tabelle
                cmp.w   2(A0),D6        ;mit Endzeile vergleichen
                bhi.s   s_del50         ;hinter Block
                cmp.w   (A0),D6         ;mit Startzeile vergleichen
                beq.s   s_del52         ;PART wird gelöscht
                bhi.s   s_del53         ;im Block
s_del54:        subq.w  #1,(A0)+        ;Startzeile erniedrigen
s_del53:        subq.w  #1,(A0)+        ;Endzeile erniedrigen
                tst.l   (A0)            ;Ende erreicht?
                bne.s   s_del54         ;nein
s_del51:        move.w  sdrv_zanz(A4),D0 ;letzte Zeile
                move.l  A0,-(SP)
                lea     lin_tab(A4),A0
                sf      0(A0,D0.w)      ;updaten
                movea.l (SP)+,A0
                bsr     redraw_all2     ;lin_tab2 updaten
                movem.l (SP)+,D1/D6/A3/A5-A6
                rts
s_del52:        jsr     search_part     ;PART-Tabelle updaten
                bsr     redraw_all      ;Bildschirm updaten
                movem.l (SP)+,D1/D6/A3/A5-A6
                rts
                ENDPART
                >PART 'redraw_r' ;ab der aktuellen Zeile neu ausgeben
redraw_rest:    movem.l D1/A0,-(SP)
                move.w  sdrv_zanz(A4),D1
                addq.w  #1,D1
                move.w  scr_z(A4),D0
                lea     lin_tab(A4),A0
redraw_rest1:   sf      0(A0,D0.w)
                addq.w  #1,D0
                cmp.w   D1,D0
                bne.s   redraw_rest1
                movem.l (SP)+,D1/A0
                rts
                ENDPART
                >PART 's_ins_line'
s_ins_line:     bsr     insert_line
                bne     no_more_mem
                move.w  #$8001,undo_buff(A4) ;Kennung für UNDO
                move.w  D6,s_undo_zeile(A4) ;ak. Zeile für UNDO merken
                bsr.s   s_ins_line2
                bra     main_loop

s_ins_line2:    bsr.s   redraw_rest
s_ins_line21:   lea     marker(A4),A2
                moveq   #12,D1          ;alle 13 Marker
s_ins2:         move.w  (A2)+,D0
                cmp.w   D6,D0           ;Marker vor einzufügender Zeile
                blo.s   s_ins4
                addq.w  #1,D0           ;Marker nicht gesetzt
                beq.s   s_ins4
                move.w  D0,-2(A2)
s_ins4:         dbra    D1,s_ins2       ;nächsten Marker
                moveq   #$FF,D0
                lea     block_end(A4),A0
                cmp.l   -2(A0),D0
                beq.s   s_ins45         ;kein Block definiert
                cmp.w   (A0),D6
                bhi.s   s_ins44
                cmp.w   (A0),D0         ;Blockende=$ffff
                beq.s   s_ins44
                addq.w  #1,(A0)
s_ins44:        cmp.w   -(A0),D6
                bhi.s   s_ins45
                addq.w  #1,(A0)
s_ins45:        lea     partbuffer-4(A4),A0
s_ins47:        addq.l  #4,A0
                tst.l   (A0)
                beq.s   s_ins46         ;Ende der Tabelle
                cmp.w   2(A0),D6        ;mit Endzeile vergleichen
                bhi.s   s_ins47         ;hinter Block
                cmp.w   (A0),D6         ;mit Startzeile vergleichen
                bhi.s   s_ins48         ;liegt im Block
s_ins49:        addq.w  #1,(A0)+        ;Startzeile erhöhen
s_ins48:        addq.w  #1,(A0)+        ;Endzeile erhöhen
                tst.l   (A0)            ;Ende erreicht?
                bne.s   s_ins49         ;nein
                bra     redraw_all2     ;lin_tab2 updaten
s_ins46:        rts
                ENDPART
                >PART 's_jump_last'
s_jump_last:    move.w  D6,D0
                move.w  letzte_zeile(A4),D6
                move.w  D0,letzte_zeile(A4)
                jsr     jump_line
                bra     main_loop
                ENDPART
                >PART 's_jump_user2'
s_jump_user2:   move.w  #'; ',D2
                move.b  s_suchz(PC),D2
                bra.s   s_jump_synta2
                ENDPART
                >PART 's_jump_synt2'
s_jump_synt2:   move.w  #';Ø',D2
s_jump_synta2:  movea.l A3,A1
                movea.l A5,A0
                move.w  D6,D1
                moveq   #0,D0
s_jmp5:         cmp.w   #$FFFF,D1       ;erste Zeile?
                beq.s   s_jmp7          ;ja
                lea     -10(A0),A0      ;Zeile zurück
                move.b  9(A0),D0        ;Länge des Remarks
                suba.w  D0,A1
                subq.w  #1,D1
s_jmp6:         cmp.w   D6,D1           ;einmal durch ?
                beq     main_loop       ;ja
                tst.b   9(A0)           ;Remarklänge gleich 0 ?
                beq.s   s_jmp5          ;nächste Zeile
                cmp.w   (A1),D2         ;fehlerhafte Zeile
                bne.s   s_jmp5          ;nein
                move.w  D1,D6
                jsr     jump_line
                bra     main_loop
s_jmp7:         btst    #0,s_edt05+1(PC) ;'von vorne'
                beq.s   s_jmp71         ;nein
                move.w  anz_zeilen(A4),D1
                movea.l z_info_top(A4),A0
                movea.l comment_top(A4),A1
                bra.s   s_jmp6
s_jmp71:        btst    #0,s_edt06+1(PC) ;'letzte Zeile'
                beq     main_loop       ;nein
                moveq   #0,D6
                jsr     jump_line
                bra     main_loop
                ENDPART
                >PART 's_jump_user'
s_jump_user:    move.w  #'; ',D2
                move.b  s_suchz(PC),D2
                bra.s   s_jump_synta
                ENDPART
                >PART 's_jump_synt'
s_jump_synt:    move.w  #';Ø',D2
s_jump_synta:   movea.l A3,A1
                movea.l A5,A0
                move.w  D6,D1
                moveq   #0,D0
                cmp.w   anz_zeilen(A4),D6 ;letzte Zeile
                beq.s   s_jmp2
s_jmp3:         tst.w   (A0)            ;Ende des Texts
                bmi.s   s_jmp2          ;ja
                move.b  9(A0),D0        ;Länge des Remarks
                adda.w  D0,A1
                lea     10(A0),A0       ;nächste Zeile
                addq.w  #1,D1
s_jmp4:         cmp.w   D6,D1           ;einmal durch ?
                beq     main_loop       ;ja
                tst.b   9(A0)           ;Remarklänge gleich 0 ?
                beq.s   s_jmp3          ;nächste Zeile
                cmp.w   (A1),D2         ;fehlerhafte Zeile
                bne.s   s_jmp3          ;nein
                move.w  D1,D6
                jsr     jump_line
                bra     main_loop
s_jmp2:         btst    #0,s_edt05+1(PC) ;'von vorne' ?
                beq.s   s_jmp21         ;nein
                moveq   #0,D1
                movea.l z_info_base(A4),A0
                movea.l comment_base(A4),A1
                bra.s   s_jmp4
s_jmp21:        btst    #0,s_edt06+1(PC) ;'letzte Zeile' ?
                beq     main_loop       ;nein
                move.w  D1,D6
                jsr     jump_line       ;in letzte Zeile springen
                bra     main_loop
                ENDPART
                >PART 's_jump_error2'
s_jump_error2:  tst.w   anz_zeilen(A4)
                beq     main_loop
                movea.l A5,A0
                move.w  D6,D1
s_jump1:        moveq   #0,D0
s_jump9:        lea     -10(A0),A0
                subq.w  #1,D1
                blo.s   s_jump7         ;dann in die letzte
                cmp.w   D6,D1           ;einmal durch ?
                beq     s_kill_error1   ;ja
                moveq   #$7F,D0
                and.b   8(A0),D0        ;Fehlernr. holen
                beq.s   s_jump9         ;kein Fehler
                btst    #0,err_tab(PC,D0.w)
                bne.s   s_jump8         ;Warning
                move.w  D1,D6
                jsr     jump_line
                bra     main_loop
s_jump7:        btst    #0,s_edt05+1(PC) ;'von vorne' ?
                beq.s   s_jump71        ;nein
                move.w  anz_zeilen(A4),D1
                movea.l z_info_top(A4),A0
                cmp.w   D6,D1
                beq     main_loop
                bra.s   s_jump9
s_jump71:       btst    #0,s_edt06+1(PC) ;'letzte Zeile' ?
                beq     main_loop       ;nein
                moveq   #0,D6
                jsr     jump_line
                bra     main_loop
s_jump8:        tst.b   skip_warn(A4)   ;Warning überspringen
                beq.s   s_jump1
                move.w  D1,D6
                jsr     jump_line
                bra     main_loop

err_tab:        DC.B 0,0,0,0,0,0,0,0,0,0 ;Flagtabelle für Fehler/Warnungen
                DC.B 0,0,0,0,0,0,0,0,0,0 ;Bit 0=1 -> Warnung
                DC.B 1,0,0,0,0,1,0,0,0,0 ;Bit 7=1 -> Optimierung freigegeben
                DC.B 0,1,0,0,0,0,0,0,0,0
                DC.B 0,1,1,0,0,0,0,1,1,1
                DC.B 1,1,1,0,1,1,1,1,0,0
                EVEN
                ENDPART
                >PART 's_jump_error'
s_jump_err3:    bsr     down            ;Cursor down
                bsr.s   s_jump_err2
                bra.s   s_jump_err1
s_jump_error:   tst.w   anz_zeilen(A4)  ;Sprung zum nächsten Fehler
                beq     main_loop
                cmpi.w  #$52FF,2(A5)    ;aktiver PART ?
                beq.s   s_jump_err3     ;ja
                bsr.s   s_jump_err2
s_jump_err1:    tst.w   D0
                beq     s_kill_error1   ;nichts gefunden
                move.w  D6,letzte_zeile(A4)
                move.w  D1,D6
                jsr     jump_line       ;in Zeile springen
                bra     main_loop
s_jump_err2:    movea.l A5,A0
                moveq   #0,D0
                move.w  D6,D1
                cmp.w   anz_zeilen(A4),D1 ;letzte Zeile
                beq.s   s_jump3
s_jump0:        moveq   #0,D0
s_jump2:        lea     10(A0),A0
                addq.w  #1,D1
s_jump4:        cmp.w   D6,D1           ;einmal durch ?
                beq.s   s_jump5         ;ja
s_jumpx:        tst.w   (A0)
                bmi.s   s_jump3         ;Ende des Quelltextes
                moveq   #$7F,D0
                and.b   8(A0),D0        ;Fehlernr. holen
                beq.s   s_jump2         ;kein Fehler
                move.l  A0,-(SP)
                lea     err_tab(PC),A0
                btst    #0,0(A0,D0.w)
                movea.l (SP)+,A0
                beq.s   s_jump5         ;Fehler->raus
                tst.b   skip_warn(A4)   ;Warning überspringen ?
                beq.s   s_jump0         ;ja
s_jump5:        rts
s_jump3:        btst    #0,s_edt05+1(PC) ;'von vorne' ?
                beq.s   s_jump31        ;nein
                moveq   #0,D1
                movea.l z_info_base(A4),A0
                bra.s   s_jump4
s_jump31:       btst    #0,s_edt06+1(PC) ;'letzte Zeile' ?
                beq.s   s_jump5         ;nein
                addq.l  #4,SP           ;Rücksprung vom Stack
                move.w  D1,D6
                jsr     jump_line       ;in letzte Zeile springen
                bra     main_loop
                ENDPART
                >PART 's_kill_error'
s_kill_error:   moveq   #$7F,D0
                and.b   8(A5),D0        ;Fehler holen
                beq     s_jump_error    ;kein Fehler in der Zeile
                andi.b  #$80,8(A5)      ;Fehler löschen
                bsr.s   s_jump_err2     ;weiter suchen
                tst.w   D0
                bne.s   s_kill_error2   ;Fehler gefunden
s_kill_error1:  lea     s_kill_err_rsc(PC),A0
                moveq   #1,D0           ;1 Sekunde
                jsr     object_do       ;'keine Fehler' ausgeben
                bra     main_loop
s_kill_error2:  jsr     error_out       ;Fehler ausgeben
                move.w  D1,D6
                jsr     jump_line       ;in Zeile springen
                bra     main_loop
                SWITCH sprache
                CASE 0
s_kill_err_rsc: DC.W 0,0,23,3,1
                DC.W 1,1
                DC.L s_kill_err_1
                DC.W 8
                DC.W -1
s_kill_err_1:   DC.B 'Keine weiteren Fehler',0
                CASE 1
s_kill_err_rsc: DC.W 0,0,16,3,1
                DC.W 1,1
                DC.L s_kill_err_1
                DC.W 8
                DC.W -1
s_kill_err_1:   DC.B 'No more errors',0
                ENDS
                EVEN
                ENDPART
                >PART 's_jump_pc'
s_jump_pc:      lea     jump_pc_rsc(PC),A0
                jsr     _form_do
                tst.w   D0
                bmi     main_loop       ;UNDO
                lea     jump_pc_2(PC),A0 ;Zeiger auf Zahl
                jsr     @hexlin         ;holt Hexzahl
                ble     main_loop       ;fehlerhafte Eingabe
                move.l  D0,D1           ;Offset nach D1
                bsr     s_calc_line     ;Zeile berechnen
                cmp.w   anz_zeilen(A4),D0
                bhi     main_loop
                move.w  D6,letzte_zeile(A4)
                move.w  D0,D6
                jsr     jump_line
                clr.w   save_pos(A4)
                bra     main_loop

jump_pc_rsc:    DC.W 0,0,21,3,1
                DC.W 1,1
                DC.L jump_pc_1
                DC.W 8
                DC.W 14,1
                DC.L jump_pc_2
                DC.W $88
                DC.W -1

jump_pc_1:      DC.B 'PC-offset = $',0
jump_pc_2:      DC.B $FF,'00000',0
                EVEN
                ENDPART
                >PART 's_lab_down'
s_lab_down:     cmp.w   anz_zeilen(A4),D6
                beq     main_loop       ;in letzter Zeile
                movea.l A5,A0           ;Zeiger auf Zeileninfo
                move.w  D6,D0           ;Zeile
s_lab_down2:    addq.w  #1,D0
                lea     10(A0),A0
                cmp.w   anz_zeilen(A4),D0
                beq     main_loop       ;am Ende angekommen
                tst.w   6(A0)           ;Labeldef testen
                bmi.s   s_lab_down2     ;kein Index
s_lab_down3:    move.w  D0,D6
                jsr     jump_line       ;in Zeile springen
                bra     main_loop
                ENDPART
                >PART 's_lab_up'
s_lab_up:       tst.w   D6
                beq     main_loop       ;in oberster Zeile
                movea.l A5,A0
                move.w  D6,D0
s_lab_up2:      subq.w  #1,D0
                bmi     main_loop       ;am Anfang angekommen
                lea     -10(A0),A0
                tst.w   6(A0)
                bmi.s   s_lab_up2       ;kein Index
                bra.s   s_lab_down3
                ENDPART
                >PART 's_jump_l'
s_jump_l:       movem.l D0-D2/A1,-(SP)
                move.w  D6,letzte_zeile(A4)
                move.w  s_spalte(A4),D0
                movea.l A5,A1
                move.w  D6,D1
                cmp.w   anz_zeilen(A4),D1
                beq.s   s_jump_l8
s_jump_l6:      lea     10(A1),A1
                addq.w  #1,D1           ;Zeilennummer
                cmp.w   D6,D1
                beq     s_jump_5        ;einmal durch
s_jump_l9:      tst.w   (A1)
                bmi.s   s_jump_l8       ;Ende des Quelltextes
                cmp.w   6(A1),D0        ;Index vergleichen
                bne.s   s_jump_l6       ;ungleich
                bra     s_jump_3        ;Sprung zur Zeile
s_jump_l8:      movea.l z_info_base(A4),A1 ;an Anfang zurück
                moveq   #0,D1
                bra.s   s_jump_l9
                ENDPART
                >PART 's_jump_linea'
s_jump_linea:   movem.l D0-D2/A1,-(SP)
                bra.s   s_jump_0
s_jump_line:    movem.l D0-D2/A1,-(SP)
                lea     jump_rsc(PC),A0
                jsr     _form_do
                tst.w   D0
                bmi.s   s_jump_5
                cmp.w   #2,D0           ;ABBRUCH
                beq.s   s_jump_5
s_jump_0:       move.w  D6,letzte_zeile(A4)
                lea     jump_rsc_1(PC),A0
                moveq   #0,D1
                moveq   #0,D0
                move.b  (A0),D0
                cmp.w   #'9',D0
                bhi.s   s_jump_2
                cmp.w   #'0',D0
                bhs.s   s_jump_1        ;Ziffer
s_jump_2:       jsr     search_symbols  ;Tabelle erzeugen
                bclr    #7,sym_flag(A4)
                tst.w   D0
                ble.s   s_jump_5        ;nicht gefunden
                movea.l A5,A1
                move.w  D6,D1
                cmp.w   anz_zeilen(A4),D1
                beq.s   s_jump_8
s_jump_6:       lea     10(A1),A1
                addq.w  #1,D1           ;Zeilennummer
s_jump_91:      cmp.w   D6,D1
                beq.s   s_jump_5        ;einmal durch
                tst.w   (A1)
                bmi.s   s_jump_8        ;Ende des Quelltextes
                move.w  6(A1),D0        ;Index holen
                bmi.s   s_jump_6        ;kein Index
                movea.l ass_adr(A4),A0
s_jump_7:       tst.w   (A0)
                bmi.s   s_jump_6        ;nicht gefunden
                cmp.w   (A0)+,D0        ;Index in Tabelle such
                bne.s   s_jump_7
                bra.s   s_jump_3        ;Sprung zur Zeile
s_jump_8:       movea.l z_info_base(A4),A1 ;an Anfang zurück
                moveq   #0,D1
                bra.s   s_jump_91
s_jump_1:       moveq   #5,D2
                bsr     s_get_zahl      ;Dezimalzahl holen
s_jump_3:       move.w  D6,letzte_zeile(A4)
                move.w  D1,D6
                jsr     jump_line       ;Zeile anspringen
                clr.w   save_pos(A4)    ;in Spalte 0
s_jump_5:       movem.l (SP)+,D0-D2/A1
                bsr     redraw_all
                bra     main_loop

jump_rsc:       DC.W 0,0,31,8,1
                SWITCH sprache
                CASE 0
                DC.W 1,2
                CASE 1
                DC.W 3,2
                ENDS
                DC.L jump_rsc_0
                DC.W 8
                DC.W 3,4
                DC.L jump_rsc_1
                DC.W $88
                DC.W 3,6
                DC.L ok_button
                DC.W $26
                DC.W 19,6
                DC.L abbruch_button
                DC.W $24
                DC.W 11,1
                DC.L jump_rsc_4
                DC.W 8
                DC.W -1
jump_rsc_1:     DC.B $FF,'123456789123456789012345',0
                SWITCH sprache
                CASE 0
jump_rsc_0:     DC.B 'Zeilennummer oder Symbolname:',0
abbruch_button: DC.B ' ABBRUCH ',0
jump_rsc_4:     DC.B 'Springe zu',0
                CASE 1
jump_rsc_0:     DC.B 'linenumber or symbolname:',0
abbruch_button: DC.B ' CANCEL ',0
jump_rsc_4:     DC.B 'Jump to',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Dezimalzahl ab A0 nach D1 holen (max. Anz. in D2)                    *
************************************************************************
                >PART 's_get_zahl'
s_get_zahl:     movem.l D0/D3,-(SP)
s_get_zahl1:    moveq   #0,D0           ;Dezimalzahl holen
                move.b  (A0)+,D0
                cmp.b   #' ',D0
                beq.s   s_get_zahl2
                sub.w   #'0',D0
                bmi.s   s_get_zahl3
                cmp.w   #9,D0
                bhi.s   s_get_zahl3
                add.l   D1,D1
                move.l  D1,D3
                lsl.l   #2,D1
                add.l   D3,D1
                add.l   D0,D1
s_get_zahl2:    dbra    D2,s_get_zahl1
s_get_zahl3:    movem.l (SP)+,D0/D3
                rts
                ENDPART
************************************************************************
* Ladealert noch mal ausgeben                                          *
************************************************************************
                >PART 's_info3'
s_info3:        move.l  save_date(A4),D0 ;Erstellungsdatum vorhanden?
                beq.s   s_info31        ;Nein! =>
                moveq   #5,D0           ;5 Sekunden anzeigen
                lea     load_it_rsc(PC),A0
                move.w  #1,8(A0)
                jsr     object_do
s_info31:       bra     main_loop
                ENDPART
************************************************************************
* Info ausgeben                                                        *
************************************************************************
                >PART 's_info'
s_info:         lea     infoasm_(PC),A0
                jsr     _form_do        ;Info anzeigen
                bra     main_loop
                ENDPART
************************************************************************
* Dank an... ausgeben                                                  *
************************************************************************
                >PART 's_info2'
s_info2:        lea     prginfo_7(PC),A0
                lea     user_name(PC),A1
                moveq   #29,D0
s_info21:       move.b  (A0)+,(A1)+     ;Usernamen kopieren
                dbeq    D0,s_info21
                lea     mrfinfo2(PC),A0
                jsr     _form_do        ;Info anzeigen
                bra     main_loop

mrfinfo2:       DC.W 0,0,40,22,1
                DC.W 2,5
                DC.L mrfinfo2_0
                DC.W $08
                DC.W 2,7
                DC.L mrfinfo2_1
                DC.W $08
                DC.W 8,1
                DC.L mrfinfo2_2
                DC.W $48
                DC.W 2,3
                DC.L mrfinfo2_3
                DC.W $08
                DC.W 4,4
                DC.L mrfinfo2_4
                DC.W $08
                DC.W 4,6
                DC.L mrfinfo2_5
                DC.W $08
                DC.W 4,8
                DC.L mrfinfo2_6
                DC.W $08
                DC.W 2,9
                DC.L mrfinfo2_7
                DC.W $08
                DC.W 4,10
                DC.L mrfinfo2_8
                DC.W $08
                DC.W 2,11
                DC.L mrfinfo2_x
                DC.W $08
                DC.W 4,12
                DC.L mrfinfo2_81
                DC.W $08
                DC.W 2,13
                DC.L mrfinfo2_y
                DC.W $08
                DC.W 4,14
                DC.L mrfinfo2_82
                DC.W $08
                DC.W 2,15
                DC.L mrfinfo2_z
                DC.W $08
                DC.W 4,16
                DC.L mrfinfo2_83
                DC.W $08
                DC.W 2,17
                DC.L mrfinfo2_9
                DC.W $08
                DC.W 4,18
                DC.L mrfinfo2_10
                DC.W $08
                DC.W 16,20
                DC.L ok_button
                DC.W $26
                DC.W -1

mrfinfo2_9:     DC.B '- '
user_name:      DC.B '??????????????????????????????',0
mrfinfo2_1:     DC.B '- Blue Byte Software',0
mrfinfo2_3:     DC.B '- Christian Markus',0
mrfinfo2_7:     DC.B '- Laurenz Prüßner',0
mrfinfo2_y:     DC.B '- Karsten Isakovic',0
mrfinfo2_z:     DC.B '- Thomas Quester',0
                SWITCH sprache
                CASE 0
mrfinfo2_x:     DC.B '- allen Usern',0
mrfinfo2_2:     DC.B 'Besonderer Dank gilt:',0
mrfinfo2_0:     DC.B '- der gesamten Schweiz',0
mrfinfo2_4:     DC.B '(für seine VDISK)',0
mrfinfo2_5:     DC.B '(für das Finden von Fehlern)',0
mrfinfo2_6:     DC.B '(für die AMIGA-Schnittstelle)',0
mrfinfo2_8:     DC.B '(für seine vielen Vorschläge)',0
mrfinfo2_81:    DC.B '(für die Geduld beim Versand)',0
mrfinfo2_82:    DC.B '(für AS-OverScan)',0
mrfinfo2_83:    DC.B '(für seine Packer)',0
mrfinfo2_10:    DC.B '(als Besitzer dieses Programms)',0
                CASE 1
mrfinfo2_x:     DC.B '- all our users',0
mrfinfo2_2:     DC.B 'Many thanks to:',0
mrfinfo2_0:     DC.B '- the hole Switzerland',0
mrfinfo2_4:     DC.B '(for his VDISK)',0
mrfinfo2_5:     DC.B '(for finding bugs)',0
mrfinfo2_6:     DC.B '(for the AMIGA-Interface)',0
mrfinfo2_8:     DC.B '(for his suggestions)',0
mrfinfo2_81:    DC.B '(for waiting a long time)',0
mrfinfo2_82:    DC.B '(for AS-OverScan)',0
mrfinfo2_83:    DC.B '(for his packer)',0
mrfinfo2_10:    DC.B '(owner of this program)',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* ASCII-Anzeige oben rechts an-/ausschalten                            *
************************************************************************
                >PART 's_asc_show'
s_asc_show:     moveq   #0,D0
                tst.b   asc_show_flag(A4)
                bne.s   s_asc_show1
                moveq   #1,D0
s_asc_show1:    move.b  D0,asc_show_flag(A4)
                clr.b   save_asc_code(A4)
                bra     main_loop
                ENDPART
************************************************************************
* Passwort ändern                                                      *
************************************************************************
                >PART 's_protect'
s_protect:      lea     save_prot(A4),A1
                tst.w   (A1)
                beq.s   s_protect1
                lea     prot_rsc_2(PC),A0
                move.l  (A1),(A0)+      ;Passwort in die RSC übertragen
                move.l  4(A1),(A0)
s_protect1:     lea     prot_rsc(PC),A0
                jsr     _form_do
                bmi     main_loop       ;UNDO
                subq.w  #2,D0
                bmi.s   s_protect2
                clr.l   (A1)+           ;Passwort löschen
                clr.l   (A1)
                bra.s   s_protect3
s_protect2:     lea     prot_rsc_2(PC),A0
                move.l  (A0)+,(A1)+     ;Passwort übertragen
                move.l  (A0)+,(A1)+
s_protect3:     bra     main_loop

prot_rsc:       DC.W 0,0,24,7,1
                DC.W 4,1
                DC.L prot_rsc_0
                DC.W $08
                DC.W 3,3
                DC.L prot_rsc_1
                DC.W $08
                DC.W 13,3
                DC.L prot_rsc_2
                DC.W $88
                DC.W 1,5
                DC.L prot_rsc_2
                DC.W $24
                DC.W 11,5
                DC.L prot_rsc_5
                DC.W $26
                DC.W -1

                SWITCH sprache
                CASE 0
prot_rsc_0:     DC.B 'Sourcetextschutz:',0
prot_rsc_1:     DC.B 'Passwort:',0
prot_rsc_5:     DC.B ' SCHUTZ AUS ',0
                CASE 1
prot_rsc_0:     DC.B 'Sourceprotection:',0
prot_rsc_1:     DC.B 'Password:',0
prot_rsc_5:     DC.B ' PROT. OFF  ',0
                ENDS
                EVEN
prot_rsc_2:     DC.B $FF,'2345678',0
                EVEN
                ENDPART
************************************************************************
* Symbolsuchroutine                                                    *
************************************************************************
                >PART 's_such_sym'
s_such_sym:     lea     sym_such_a(PC),A0 ;Zeiger auf 'Anfang'-Button
                andi.w  #$FFFE,(A0)     ;Buttons deselekten
                andi.w  #$FFFE,10(A0)
                andi.w  #$FFEF,20(A0)   ;'Block'-Button enablen
                ori.w   #1,20(A0)       ;'Block'-Button selekten
                tst.b   block_fl(A4)    ;Block markiert?
                bne.s   s_such_sym1     ;ja
                andi.w  #$FFFE,20(A0)   ;'Block'-Button deselekten
                ori.w   #$10,20(A0)     ;'Block'-Button disablen
                ori.w   #1,10(A0)       ;'Cursor' selektieren
s_such_sym1:    lea     sym_such_rsc(PC),A0
                jsr     _form_do
                cmp.w   #1,D0
                bne     main_loop       ;ABBRUCH
s_such_sym2:    lea     sym_such_1(PC),A0
                jsr     search_symbols  ;Tabelle erzeugen
                st      sym_flag(A4)
                tst.w   D0
                bmi.s   s_such_sym      ;falsche Eingabe
                beq     main_loop       ;nichts gefunden
                bra.s   s_such_sym5
s_such_sym3:    tst.b   sym_flag(A4)    ;dirty-flag für Tabelle
                beq     main_loop       ;kein Suchname
                bpl.s   s_such_sym2
s_such_sym5:    tst.w   anz_zeilen(A4)
                beq     main_loop
                movem.l D2-D3/D5/A2-A6,-(SP)
                move.w  D6,D2
                move.w  D6,D4           ;Startzeile merken
                move.w  anz_zeilen(A4),block_pointer(A4) ;Ende des Suchbereichs
                btst    #0,sym_such_b+1(PC) ;'Cursor'?
                bne.s   s_such_sym7     ;ja
                moveq   #0,D2
                btst    #0,sym_such_a+1(PC) ;'Anfang'?
                bne.s   s_such_sym6     ;ja
                tst.b   block_fl(A4)    ;sonst Block
                beq     s_such_sym15    ;kein Block definiert
                move.w  block_end(A4),block_pointer(A4) ;Ende des Suchbereichs
                move.w  block_anf(A4),D2
                cmp.w   D2,D6
                blo.s   s_such_sym6     ;Cursor vor Block
                move.w  block_anf(A4),D4
                cmp.w   block_pointer(A4),D6
                bhs.s   s_such_sym11    ;Cursor hinter Block
                move.w  D6,D2
s_such_sym6:    move.w  D2,D4           ;Startzeile merken
                move.w  D2,D0
                jsr     calc_pointer
s_such_sym7:    movea.l label_base(A4),A3
                movea.l ass_adr(A4),A2
                tst.w   (A2)
                bmi     s_such_sym15    ;leere Tabelle
                bsr     s_such_syms     ;bestimmt die Operandennummer (D5)
                moveq   #-2,D0
                cmp.w   D0,D5           ;kein Operand in der Zeile ?
                beq.s   s_such_sym10    ;ja
                tst.l   D5              ;Formel ?(oberes Word<>-1)
                bmi.s   s_such_sym8     ;nein
                swap    D5
                addq.w  #1,D5           ;auf nächsten Operanden in der Formel
                swap    D5
                bra.s   s_such_sym9
s_such_sym8:    and.l   #$FFFF,D5
                addq.w  #1,D5           ;auf nächsten Operanden
s_such_sym9:    cmpi.w  #$52FF,2(A5)    ;eingeklappter PART
                beq.s   s_such_sym16
                cmpi.w  #$52F0,2(A5)    ;geschützter PART
                beq.s   s_such_sym16
                bsr     s_such_syml6    ;durchsucht ak. Zeile
                bpl.s   s_such_sym17    ;passendes Symbol gefunden
s_such_sym10:   move.l  #$FFFF,D5       ;für folgende Zeilen Operandennummer löschen
                adda.w  (A5),A6
                lea     10(A5),A5       ;eine Zeile weiter
                addq.w  #1,D2
                cmp.w   D4,D2
                beq.s   s_such_sym15    ;einmal durch
                cmp.w   block_pointer(A4),D2 ;Ende des Suchbereichs
                blo.s   s_such_sym9
s_such_sym11:   btst    #0,s_edt05+1(PC) ;'von vorne' ?
                beq.s   s_such_sym13    ;nein
                moveq   #0,D2
                btst    #0,sym_such_c+1(PC) ;'Block'
                beq.s   s_such_sym12    ;nein
                move.w  block_anf(A4),D2
s_such_sym12:   cmp.w   D4,D2
                beq.s   s_such_sym15    ;einmal durch
                move.w  D2,D0
                jsr     calc_pointer
                movea.l label_base(A4),A3
                bra.s   s_such_sym9     ;weiter suchen
s_such_sym13:   btst    #0,s_edt06+1(PC) ;'letzte Zeile' ?
                beq.s   s_such_sym15    ;nein
                move.w  anz_zeilen(A4),D6 ;Quelltextende
                btst    #0,sym_such_c+1(PC) ;'Block'
                beq.s   s_such_sym14    ;nein
                move.w  block_end(A4),D6 ;Blockende
s_such_sym14:   jsr     jump_line
s_such_sym15:   movem.l (SP)+,D2-D3/D5/A2-A6
                bra     main_loop
s_such_sym16:   adda.w  (A5),A6
                lea     10(A5),A5       ;eine Zeile weiter
                addq.w  #1,D2
                cmpi.b  #$54,2(A5)      ;ENDPART
                bne.s   s_such_sym16
                bra.s   s_such_sym10
s_such_sym17:   move.w  D6,letzte_zeile(A4)
                move.w  D2,D6
                move.l  D3,such_sym(A4) ;Zeiger auf Operand
                movem.l (SP)+,D2-D3/D5/A2-A6
                jsr     jump_line
                movem.l D0-A6,-(SP)
                pea     dbuffer+2(A4)
                jsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP
                clr.b   (A0)
                movem.l (SP)+,D0-A6
                lea     dbuffer+2(A4),A0 ;Zeiger auf Zeile
                move.w  such_sym+2(A4),D1 ;Zeiger für Operand
                bmi.s   s_such_sym26    ;Symboldefinition (Anfang der Zeile)
                bne.s   s_such_sym27    ;ab 2. Operanden (min. ein ',')
                moveq   #' ',D1         ;erster Operand
                tst.w   6(A5)
                bmi.s   s_such_sym19    ;kein Symbol in der Zeile definiert
s_such_sym18:   cmp.b   (A0),D1         ;Ende, wenn Space
                beq.s   s_such_sym19
                cmpi.b  #':',(A0)+      ;Symbolende suchen
                bne.s   s_such_sym18
s_such_sym19:   cmp.b   (A0)+,D1
                beq.s   s_such_sym19    ;Spaces überlesen
                subq.l  #1,A0
s_such_sym20:   cmp.b   (A0)+,D1
                bne.s   s_such_sym20    ;Befehl überlesen
s_such_sym21:   cmp.b   (A0)+,D1
                beq.s   s_such_sym21    ;Spaces überlesen
                subq.l  #1,A0
s_such_sym22:   move.w  such_sym(A4),D1 ;Zeiger für Formeloperand
                beq.s   s_such_sym25    ;1. Operand, raus
                lea     f_zeichen,A1    ;Tabelle der Formelzeichen
                move.w  D1,D0
                lsr.w   #7,D0
                lea     0(A1,D0.w),A1   ;Zeiger auf Formelzeichen
                move.b  (A1),D0
                move.b  1(A1),D2
s_such_sym23:   cmp.b   (A0)+,D0        ;Zeichen suchen
                bne.s   s_such_sym23
                tst.b   D2
                beq.s   s_such_sym24    ;nur ein Zeichen
                cmp.b   (A0)+,D2        ;2. Zeichen vergleichen
                bne.s   s_such_sym23
s_such_sym24:   subq.b  #1,D1           ;Zähler erniedrigen
                bne.s   s_such_sym23
s_such_sym25:   cmpi.b  #'#',(A0)
                bne.s   s_such_sym26    ;'#' überlesen
                addq.l  #1,A0
s_such_sym26:   move.l  A0,D0
                lea     dbuffer+2(A4),A0
                sub.l   A0,D0
                move.w  D0,save_pos(A4)
                bra     main_loop

s_such_sym27:   move.b  (A0)+,D0
                beq.s   s_such_sym22
                cmp.b   #'(',D0
                beq.s   s_such_sym28
                cmp.b   #',',D0
                bne.s   s_such_sym27
                subq.w  #1,D1
                bne.s   s_such_sym27
                bra.s   s_such_sym22
s_such_sym28:   moveq   #1,D0
s_such_sym32:   tst.b   (A0)
                beq.s   s_such_sym22
                cmpi.b  #'(',(A0)
                beq.s   s_such_sym33
                cmpi.b  #')',(A0)+
                bne.s   s_such_sym32
                subq.w  #1,D0
                beq.s   s_such_sym27
s_such_sym33:   addq.w  #1,D0
                addq.l  #1,A0
                bra.s   s_such_sym32
                ENDPART
************************************************************************
* bestimmt die Operandennummer aus der Cursorposition                  *
* ->A3,A5,A6 (Zeiger auf ak. Zeile), zeingabe (enthält die Zeile)      *
* <-D5: High-Word=Operandennummer innerhalb der Formel (-1=keine F.)   *
*       Low-Word=Operandennummer (-1=Symboldef.,-2=keine Op. in Zeile) *
* <-A1: Zeiger auf Darstellungsbits od. Index des Operanden            *
************************************************************************
                >PART 's_such_syms'
s_such_syms:    movem.l D0-D4/A0/A2-A3,-(SP)
                lea     zeingabe+2(A4),A0 ;Zeiger auf Eingabezeile
                move.w  save_pos(A4),D0 ;Cursorposition
                moveq   #-2,D5
                tst.w   (A5)
                bmi.s   s_such_syms5    ;letzte Zeile
                tst.l   (A5)
                beq.s   s_such_syms5    ;Leerzeile
                moveq   #0,D1
                moveq   #' ',D2
                moveq   #-1,D5
                cmp.w   6(A5),D5        ;Symbol definiert ?
                beq.s   s_such_syms2    ;nein
s_such_syms1:   cmp.b   (A0),D2
                beq.s   s_such_syms2
                cmpi.b  #':',(A0)+
                bne.s   s_such_syms1    ;Symbol überlesen
                cmpi.b  #':',(A0)+
                beq.s   s_such_syms2    ;kein globales Symbol
                subq.l  #1,A0
s_such_syms2:   cmp.b   (A0)+,D2
                beq.s   s_such_syms2    ;Spaces überlesen
                tst.b   -(A0)
                beq.s   s_such_syms5    ;Ende der Zeile
s_such_syms3:   move.b  (A0)+,D1
                beq.s   s_such_syms5    ;Ende der Zeile
                cmp.b   D2,D1
                bne.s   s_such_syms3    ;Befehl überlesen
                subq.l  #1,A0
s_such_syms4:   cmp.b   (A0)+,D2
                beq.s   s_such_syms4    ;Spaces überlesen
                subq.l  #1,A0
                move.l  A0,D2
                sub.l   A4,D2
                subi.w  #zeingabe+2,D2
                cmp.w   D0,D2
                bls.s   s_such_syms8
s_such_syms5:   movem.l (SP)+,D0-D4/A0/A2-A3
                rts
s_such_syms6:   addq.w  #1,D2
                bra.s   s_such_syms10
s_such_syms7:   subq.w  #1,D2
                bra.s   s_such_syms10
s_such_syms8:   movea.l label_base(A4),A3
                clr.w   D5
                sub.w   D2,D0
                move.l  A0,D3
                cmpi.b  #2,2(A5)
                bge     s_such_syms20   ;Sonderbefehle
                moveq   #0,D2
                moveq   #0,D4
s_such_syms9:   move.b  (A0)+,D1
                cmp.b   D4,D1
                beq.s   s_such_syms11   ;Stringende
                tst.b   D4
                bne.s   s_such_syms10   ;im String kein Test auf Sonderzeichen
                cmp.b   #$22,D1
                beq.s   s_such_syms12   ;Stringanfang
                cmp.b   #$27,D1
                beq.s   s_such_syms12   ;Stringanfang
                cmp.b   #';',D1
                beq.s   s_such_syms13   ;Remark
                cmp.b   #'(',D1
                beq.s   s_such_syms6
                cmp.b   #')',D1
                beq.s   s_such_syms7
                tst.w   D2              ;unterste Klammerebene ?
                bne.s   s_such_syms10   ;nein
                cmp.b   #',',D1
                bne.s   s_such_syms10
                addq.w  #1,D5
                move.l  A0,D3
s_such_syms10:  dbra    D0,s_such_syms9
                add.w   D5,D5
                lea     2(A5,D5.w),A1   ;Zeiger auf Operandenflags
                jsr     get_index       ;Index holen
                bvc.s   s_such_syms14   ;gefunden
                lsr.w   #1,D5           ;einfacher Wert
                bra.s   s_such_syms5
s_such_syms11:  moveq   #0,D4           ;Endekennung löschen
                bra.s   s_such_syms10
s_such_syms12:  move.b  D1,D4           ;Endekennung merken
                bra.s   s_such_syms10
s_such_syms13:  moveq   #-2,D5          ;Cursor steht nicht auf Operanden
                bra.s   s_such_syms5
s_such_syms14:  lsl.l   #5,D0
                cmpi.b  #$FF,31(A3,D0.l) ;Formel ?
                bne     s_such_syms5    ;nur Symbol
                swap    D5
                clr.w   D5
                lea     6(A3,D0.l),A1   ;Zeiger auf Formel
                suba.l  D3,A0
                move.w  A0,D2           ;Cursorposition rel. zum Formelanfang
                subq.w  #2,D2
                ble.s   s_such_syms19   ;erster Operand
                movea.l D3,A0           ;Zeiger auf Anfang der Formel
s_such_syms15:  tst.w   D2
                ble.s   s_such_syms19
                moveq   #4,D1
                move.w  (A1),D0         ;Formelflags holen
                btst    #6,D0           ;long-flag
                beq.s   s_such_syms16
                addq.w  #2,D1
s_such_syms16:  move.w  0(A1,D1.w),D0   ;Flags holen
                cmp.b   #$FF,D0         ;Ende der Formel ?
                beq.s   s_such_syms19   ;ja
                lsr.w   #7,D0
                and.w   #$1E,D0         ;Rechenoperation ausmaskieren
                lea     f_zeichen,A2    ;Tabelle mit Rechenzeichen
                lea     0(A2,D0.w),A2
                move.b  (A2)+,D0        ;Rechenzeichen
                move.b  (A2)+,D1        ;2. Zeichen
s_such_syms17:  cmp.b   (A0)+,D0        ;mit Rechenzeichen vergleichen
                dbeq    D2,s_such_syms17
                bne.s   s_such_syms19   ;Cursorposition erreicht
                subq.w  #1,D2           ;Zeichen gefunden
                tst.b   D1
                beq.s   s_such_syms18   ;kein 2.Zeichen
                cmp.b   (A0),D1         ;2. Zeichen vergleichen
                bne.s   s_such_syms17
                addq.l  #1,A0           ;Zeiger auf nächstes Zeichen
                subq.w  #1,D2
s_such_syms18:  addq.w  #1,D5           ;Operandennummer erhöhen
                move.w  (A1)+,D0
                addq.l  #2,A1
                btst    #6,D0           ;ein weiter
                beq.s   s_such_syms15
                addq.l  #2,A1
                bra.s   s_such_syms15
s_such_syms19:  swap    D5
                bra     s_such_syms5
s_such_syms20:  moveq   #0,D2
s_such_syms21:  move.b  (A0)+,D1
                cmp.b   D2,D1
                beq.s   s_such_syms24   ;Stringende
                tst.b   D2
                bne.s   s_such_syms22   ;im String kein Test auf Sonderzeichen
                cmp.b   #';',D1
                beq     s_such_syms13   ;Remark
                cmp.b   #$22,D1
                beq.s   s_such_syms23   ;String
                cmp.b   #$27,D1
                beq.s   s_such_syms23   ;String
                cmp.b   #',',D1
                bne.s   s_such_syms22
                addq.w  #1,D5
                move.l  A0,D3
s_such_syms22:  dbra    D0,s_such_syms21
                moveq   #0,D0
                lea     4(A5),A1
                move.b  2(A5),D0
                move.w  s_tab-2(PC,D0.w),D0
                beq     s_such_syms13   ;Befehl hat keine Operanden
                jmp     s_tab(PC,D0.w)
s_such_syms23:  move.b  D1,D2           ;Endekennung merken
                bra.s   s_such_syms22
s_such_syms24:  moveq   #0,D2
                bra.s   s_such_syms22

                BASE DC.W,s_tab
s_tab:          DC.W s_sdc,s_sds,0,0,0,0,s_sequ
                DC.W 0,0,0,0,s_srs,s_srss,0,s_sds2
                DC.W s_sbase,0,0,0,s_sset,0,0,0
                DC.W 0,s_sds2,s_sds,0,s_sorg,s_sset,s_srs,0 ;bis $3E
                DC.W s_sset,s_scase,0,s_sglob,s_sset,0,0,0
                DC.W 0,0,0,0,s_sequ,0

s_sorg:         bra     s_such_syms5
s_sdc:          moveq   #0,D0
                move.w  (A1),D0         ;Index der DC-Zeile
                and.w   #$3FFF,D0
                move.w  D5,D1
s_sdc4:         lsl.l   #5,D0
                lea     0(A3,D0.l),A1   ;Zeiger auf Eintrag
                moveq   #0,D0
s_sdc3:         subq.w  #1,D1
                bmi.s   s_sdc2
                move.w  (A1)+,D0        ;Flags holen
                bmi.s   s_sdc3
                cmp.b   #$FF,D0         ;Kennung für Folgeeintrag
                beq.s   s_sdc5
                and.w   #7,D0
                subq.w  #6,D0
                bpl.s   s_sdc3          ;ASCII-String nur ein Operand (keine Kommas)
                move.w  -2(A1),D0       ;Flags nochmal holen
                lsr.w   #4,D0           ;Anzahl der Operanden
                sub.w   D0,D1
                bpl.s   s_sdc3
                subq.l  #2,A1
s_sdc2:         move.w  (A1),D0
                bpl.s   s_sdc7          ;einfacher Wert
                and.w   #$3FFF,D0
                bra     s_such_syms14   ;Index auswerten
s_sdc7:         tst.b   D0
                bpl.s   s_sdc8
                subq.l  #2,A1
s_sdc8:         bra     s_such_syms5
s_sdc5:         addq.w  #1,D1
                move.b  (A1),D0         ;Index des Folgeeintrags
                bra.s   s_sdc4
s_sset:         moveq   #0,D0
                move.w  (A1),D0
                and.w   #$3FFF,D0
                bra     s_such_syms14
s_sds:          move.b  3(A5),D0
                tst.w   D5
                bne.s   s_sds2          ;2.Operand
                and.b   #$30,D0
                cmp.b   #$30,D0
                beq.s   s_sset          ;Index auswerten
s_sds2:         lea     2(A5),A1
                bra     s_such_syms5
s_sequ:         tst.w   (A1)
                bmi.s   s_sset          ;Index auswerten
                bra     s_such_syms5
s_srs:          move.b  3(A5),D0
                and.b   #5,D0
                cmp.b   #5,D0
                beq.s   s_sset          ;Index auswerten
                bra.s   s_sds2
s_srss:         move.w  2(A5),D0
                btst    #6,D0
                bne.s   s_sset          ;Index auswerten
                bra.s   s_sds2
s_sbase:        moveq   #0,D0
                move.w  (A1),D0
                bmi.s   s_sds2          ;kein Symbol/Formel
                and.w   #$3FFF,D0
                bra     s_such_syms14   ;Index auswerten
s_sglob:        moveq   #0,D0
                move.w  (A1),D0
                and.w   #$3FFF,D0
                lsl.l   #5,D0
                lea     0(A1,D0.l),A1   ;Zeiger auf Eintrag
                moveq   #0,D0
                move.w  D5,D0           ;Operandennummer
                add.w   D0,D0           ;mal 2
                lea     0(A1,D0.w),A1   ;Zeiger auf Index
                bra     s_such_syms5
s_scase:        tst.b   3(A5)           ;folgt Zahl ?
                bmi     s_such_syms13   ;nein
                bra.s   s_sds2
                ENDPART
************************************************************************
* durchsucht eine Zeile nach Symbolnummer                              *
************************************************************************
                >PART 's_such_syml'
s_such_syml:    move.l  A0,-(SP)
                movea.l A2,A0           ;sucht Index in D0 in der Tabelle
s_such_syml1:   tst.w   (A0)
                bmi.s   s_such_syml2    ;Ende der Tabelle
                cmp.w   (A0)+,D0
                bne.s   s_such_syml1
                movea.l (SP)+,A0
                move    #0,CCR          ;gefunden
                rts
s_such_syml2:   movea.l (SP)+,A0
                move    #$FF,CCR        ;nicht gefunden
                rts
s_such_syml3:   moveq   #0,D0
                lea     6(A5),A1
                move.w  (A1),D0         ;Index holen
                bmi.s   s_such_syml4    ;kein Index
                bsr.s   s_such_syml     ;in Tabelle suchen
                bpl.s   s_such_syml11   ;gefunden
s_such_syml4:   clr.w   D5
                bra.s   s_such_syml7
s_such_syml5:   bsr     s_such_syml39
                bmi.s   s_such_syml8    ;nichts gefunden
                rts
s_such_syml6:   moveq   #$FF,D3
                tst.w   D5
                bmi.s   s_such_syml3    ;Symboldefinition
s_such_syml7:   suba.l  A1,A1
                moveq   #0,D3
                moveq   #0,D0
                move.b  2(A5),D0
                cmp.b   #2,D0
                bge.s   s_such_syml12
                cmp.w   #1,D5           ;Position innerhalb der Zeile
                bgt.s   s_such_syml10   ;mehr als 2 Symbole bei normalen
                beq.s   s_such_syml8    ;Befehlen nicht möglich
                jsr     get_index       ;Index holen
                bvs.s   s_such_syml8    ;kein Index
                move.w  D0,D1
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A3,D0.l) ;Formel ?
                beq.s   s_such_syml5    ;ja
                tst.l   D5
                bne.s   s_such_syml9    ;keine Formel->zum 2. Operanden
                moveq   #0,D0
                move.w  D1,D0
                bsr.s   s_such_syml     ;in Tabelle suchen
                bpl.s   s_such_syml11   ;gefunden
s_such_syml8:   moveq   #1,D3
                move.w  #2,D5           ;2. Operand
                jsr     get_index       ;Index holen
                bvs.s   s_such_syml10   ;kein Index
                move.w  D0,D1
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A3,D0.l) ;Formel ?
                beq     s_such_syml39   ;ja, in Formel suchen
                move.l  D5,D0
                swap    D0
                tst.w   D0
                bne.s   s_such_syml10
                moveq   #0,D0
                move.w  D1,D0
                bra     s_such_syml     ;sucht Index in Tabelle
s_such_syml9:   moveq   #0,D5
                bra.s   s_such_syml8
s_such_syml10:  move    #$FF,CCR        ;nichts gefunden
s_such_syml11:  rts
s_such_syml12:  move.w  s_stab-2(PC,D0.w),D0
                beq.s   s_such_syml13
                lea     4(A5),A1        ;Zeiger auf Index
                jmp     s_stab(PC,D0.w)
                BASE DC.W,s_stab
s_stab:         DC.W s_such_syml14,s_such_syml25,0,0,0,0,s_such_syml32
                DC.W 0,0,0,0,s_such_syml31,s_such_syml33,0,0
                DC.W s_such_syml34,0,0,0,s_such_syml35,0,0,0 ;bis $2E
                DC.W 0,0,s_such_syml25,0,0,s_such_syml38,s_such_syml31,0
                DC.W s_such_syml38,0,0,s_such_syml28,0,0,0,0 ;bis $4E
                DC.W 0,0,0,0,s_such_syml32,0

s_such_syml13:  move    #$FF,CCR
                rts
s_such_syml14:  move.w  4(A5),D0        ;DC
                andi.w  #$3FFF,D0
                move.w  #-1,D3
s_such_syml15:  lsl.l   #5,D0
                lea     0(A3,D0.l),A1
                moveq   #0,D0
s_such_syml16:  subq.w  #1,D5           ;Index innerhalb des DC-Eintrags bestimmen
                bmi.s   s_such_syml19
                addq.w  #1,D3
                move.w  (A1)+,D0
                bmi.s   s_such_syml16
                cmp.b   #$FE,D0         ;Endekennung
                beq.s   s_such_syml13
                cmp.b   #$FF,D0         ;Fortsetzungskennung
                beq.s   s_such_syml17
                lsr.w   #4,D0
                add.w   D0,D3
                sub.w   D0,D5
                bra.s   s_such_syml16
s_such_syml17:  subq.w  #1,D3
                addq.w  #1,D5
                move.b  (A1),D0         ;Index der Fortsetzung holen
                ext.l   D0
                bra.s   s_such_syml15
s_such_syml18:  lsl.l   #5,D0
                lea     0(A3,D0.l),A1
                moveq   #0,D0
s_such_syml19:  addq.w  #1,D3
                move.w  (A1)+,D0
                bmi.s   s_such_syml21
                cmp.b   #$FE,D0         ;Endekennung
                beq.s   s_such_syml13
                cmp.b   #$FF,D0         ;Fortsetzungskennung
                beq.s   s_such_syml20
                lsr.w   #4,D0
                add.w   D0,D3
                bra.s   s_such_syml19
s_such_syml20:  subq.w  #1,D3
                move.b  (A1),D0
                ext.l   D0
                bra.s   s_such_syml18
s_such_syml21:  andi.w  #$3FFF,D0
                move.w  D0,D1           ;Index retten
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A3,D0.l) ;Formel ?
                beq.s   s_such_syml23   ;ja
                move.l  D5,D0
                swap    D0
                tst.w   D0
                bne.s   s_such_syml22   ;keine Formel->nächster Operand
                moveq   #0,D0
                move.w  D1,D0           ;Index zurückholen
                bsr     s_such_syml     ;sucht Index in Tabelle
                bmi.s   s_such_syml19   ;weiter suchen
                subq.l  #2,A1           ;gefunden, A1 zeigt auf Index
                rts
s_such_syml22:  moveq   #0,D0
                andi.l  #$FFFF,D5
                addq.w  #1,D5
                bra.s   s_such_syml19
s_such_syml23:  move.l  A1,-(SP)
                bsr     s_such_syml39   ;sucht in Formel
                bpl.s   s_such_syml24   ;gefunden, A1 zeigt auf Index
                movea.l (SP)+,A1
                bra.s   s_such_syml19   ;weiter suchen
s_such_syml24:  addq.l  #4,SP           ;Stack korregieren
                rts
s_such_syml25:  tst.w   D5              ;DS
                bne.s   s_such_syml27   ;steht nicht auf erstem Operand
                move.w  2(A5),D0
                andi.w  #$30,D0
                cmp.w   #$30,D0
                bne.s   s_such_syml27   ;kein Index
                move.w  (A1),D0
s_such_syml26:  andi.w  #$3FFF,D0
                move.w  D0,D1           ;Index retten
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A3,D0.l) ;Formel ?
                beq     s_such_syml39   ;ja, in Formel suchen
                move.l  D5,D0
                swap    D0
                tst.w   D0
                bne.s   s_such_syml27   ;keine Formel->nächste Zeile
                moveq   #0,D0
                move.w  D1,D0           ;Index zurückholen
                bra     s_such_syml     ;sucht Index in Tabelle
s_such_syml27:  move    #$FF,CCR
                rts
s_such_syml28:  moveq   #0,D0           ;GLOBAL
                move.w  (A1),D0         ;Index holen
                lsl.l   #5,D0
                lea     0(A3,D0.l),A1   ;Zeiger auf Eintrag
                moveq   #0,D0
                move.w  D5,D0
                move.w  D5,D3
                add.w   D0,D0
                lea     0(A1,D0.w),A1
                move.l  D5,D0
                swap    D0
                tst.w   D0
                beq.s   s_such_syml30
                addq.l  #2,A1
s_such_syml29:  addq.w  #1,D3
s_such_syml30:  move.w  (A1)+,D0        ;Index holen
                bmi.s   s_such_syml27   ;kein Index
                bsr     s_such_syml     ;sucht Index in Tabelle
                bmi.s   s_such_syml29   ;nicht gefunden
                subq.l  #2,A1           ;A1 zeigt auf Index
                rts
s_such_syml31:  tst.w   D5              ;RS
                bne.s   s_such_syml27   ;steht nicht auf erstem Operand
                move.w  2(A5),D0
                andi.w  #5,D0
                cmp.w   #5,D0
                bne.s   s_such_syml27   ;kein Index
                move.w  (A1),D0         ;Index holen
                bra.s   s_such_syml26   ;testen
s_such_syml32:  tst.w   D5
                bne.s   s_such_syml36
                tst.b   3(A5)           ;EQU
                beq.s   s_such_syml36   ;kein Index
                move.w  (A1),D0         ;Index holen
                bra.s   s_such_syml26   ;testen
s_such_syml33:  tst.w   D5
                bne.s   s_such_syml36
                btst    #6,3(A5)        ;RSSET
                beq.s   s_such_syml36   ;kein Index
                move.w  (A1),D0         ;Index holen
                bra     s_such_syml26   ;testen
s_such_syml34:  cmp.w   #1,D5
                bhi.s   s_such_syml36   ;größer als 2.Operand
                move.w  (A1),D0         ;BASE
                bmi.s   s_such_syml36   ;kein Index
                moveq   #1,D3           ;2. Operand
                bra     s_such_syml26   ;Index testen
s_such_syml35:  tst.w   D5
                bne.s   s_such_syml36
                move.w  (A1),D0         ;IF
                and.w   #$3FFF,D0
                cmpi.b  #$0E,3(A5)
                bge.s   s_such_syml37   ;IFD und IFND
                lsl.l   #5,D0           ;mal 32
                bra.s   s_such_syml39   ;in Formel suchen
s_such_syml36:  move    #$FF,CCR        ;nicht gefunden
                rts
s_such_syml37:  bra     s_such_syml     ;sucht Index in der Tabelle
s_such_syml38:  move.w  (A1),D0         ;SET
                lsl.l   #5,D0
s_such_syml39:  lea     6(A3,D0.l),A1   ;sucht Index in einer Formel
                moveq   #0,D0
                lea     s_such_syml50(PC),A0
                move.l  D0,(A0)         ;Tabelle mit Zählern
                move.l  D0,4(A0)        ;löschen
                move.l  D0,8(A0)
                move.l  D0,12(A0)
                swap    D3
                swap    D5
                addq.l  #1,A1
                tst.w   D5
                beq.s   s_such_syml44   ;1. Operand
                bra.s   s_such_syml41
s_such_syml40:  move.b  (A1)+,D0
                andi.w  #$0F,D0         ;Rechenoperation
                addq.b  #1,0(A0,D0.w)
s_such_syml41:  move.b  (A1)+,D0
                bmi.s   s_such_syml45
                addq.l  #2,A1
                btst    #6,D0
                beq.s   s_such_syml42
                addq.l  #2,A1
s_such_syml42:  subq.w  #1,D5
                bne.s   s_such_syml40

s_such_syml43:  move.b  (A1)+,D0
                andi.w  #$0F,D0         ;Rechenoperation
                addq.b  #1,0(A0,D0.w)   ;Zähler für entsp. Rechenoperation plus 1
s_such_syml44:  move.b  (A1)+,D0        ;Statusbyte für Wert holen
                bmi.s   s_such_syml46   ;Symbolindex
                addq.l  #2,A1           ;sonst überlesen
                btst    #6,D0           ;Long-flag gesetzt
                beq.s   s_such_syml43   ;nein
                addq.l  #2,A1           ;sonst noch 2 überlesen
                bra.s   s_such_syml43
s_such_syml45:  cmp.b   #$FF,D0         ;Endekennung ?
                beq.s   s_such_syml47   ;ja
                addq.l  #2,A1           ;sonst überlesen
                bra.s   s_such_syml42
s_such_syml46:  cmp.b   #$FF,D0         ;Endekennung ?
                beq.s   s_such_syml47   ;ja
                move.b  -2(A1),D0
                andi.w  #$0F,D0         ;Rechenoperation
                move.b  D0,D3
                lsl.w   #8,D3           ;Rechenzeichen ins obere Byte
                move.b  0(A0,D0.w),D3   ;Anzahl ins untere Byte
                move.w  (A1)+,D0        ;Index holen
                bmi.s   s_such_syml48   ;interne Variablen
                andi.w  #$3FFF,D0       ;Index
                bsr     s_such_syml     ;in Tabelle suchen
                bmi.s   s_such_syml43   ;nicht gefunden -> Formel weiter analysieren
                swap    D3              ;Daten für Formel ins obere Word
                subq.l  #2,A1           ;gefunden, A1 zeigt auf Index
                rts
s_such_syml47:  swap    D3
                clr.w   D5
                swap    D5
                move    #$FF,CCR        ;nichts gefunden
                rts
s_such_syml48:  andi.w  #$3FFF,D0
                bne.s   s_such_syml49
                addq.b  #1,6(A0)        ;'*'
                bra.s   s_such_syml43
s_such_syml49:  addq.b  #2,3(A0)        ;z.b.'^^TIME'
                bra.s   s_such_syml43
s_such_syml50:  DC.W 0,0,0,0,0,0,0,0

sym_such_rsc:   DC.W 0,0,33,11,1
                DC.W 8,1
                DC.L sym_such_0
                DC.W 8
                DC.W 5,3
                DC.L sym_such_1
                DC.W $88
                DC.W 4,9
                DC.L ok_button
                DC.W $26
                DC.W 20,9
                DC.L abbruch_button
                DC.W $24
                DC.W 1,7
                DC.L sym_such_4
sym_such_a:     DC.W $44
                DC.W 12,7
                DC.L sym_such_5
sym_such_b:     DC.W $45
                DC.W 23,7
                DC.L sym_such_6
sym_such_c:     DC.W $44
                DC.W 1,5
                DC.L sym_such_7
                DC.W 8
                DC.W 15,5
                DC.L sym_such_8
                DC.W 8
                DC.W 12,5
                DC.L sym_such_9
                DC.W 8
                DC.W 31,5
                DC.L sym_such_10
                DC.W 8
                DC.W -1

sym_such_1:     DC.B $FF,'1234567890123456789012',0
sym_such_9:     DC.B '*',0
sym_such_10:    DC.B '?',0
                SWITCH sprache
                CASE 0
sym_such_0:     DC.B 'Symbolnamen suchen',0
sym_such_4:     DC.B ' Anfang ',0
sym_such_5:     DC.B ' Cursor ',0
sym_such_6:     DC.B ' Block ',0
sym_such_7:     DC.B 'Allquantor:',0
sym_such_8:     DC.B 'Existenzquantor:',0
                CASE 1
sym_such_0:     DC.B 'Search for symbol',0
sym_such_4:     DC.B ' begin  ',0
sym_such_5:     DC.B ' cursor ',0
sym_such_6:     DC.B ' block ',0
sym_such_7:     DC.B 'allquantor:',0
sym_such_8:     DC.B 'existenzquantor:',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Symbol-Replace                                                       *
************************************************************************
                >PART 's_replace'
s_replace:      moveq   #5,D0
                lea     sym_repl_1(PC),A0
                lea     sym_repl_12(PC),A1
s_replace1:     move.l  (A0),D1
                move.l  (A1),(A0)+      ;Longs vertauschen
                move.l  D1,(A1)+
                dbra    D0,s_replace1
                lea     replaces_rsc(PC),A0
                ori.b   #$80,8(A0)
                bra.s   s_replace4
s_replace2:     lea     replaces1_rsc(PC),A0
                jsr     _form_do        ;nichts gefunden
s_replace3:     lea     replaces_rsc(PC),A0
                andi.b  #$7F,8(A0)
                lea     replaces_a(PC),A0
                ori.w   #1,(A0)
                andi.w  #$FFFE,10(A0)
                ori.w   #$10,10(A0)
                tst.b   block_fl(A4)
                beq.s   s_replace4      ;kein Block markiert
                andi.w  #$FFFE,(A0)
                ori.w   #1,10(A0)       ;'Block' selektieren
                andi.w  #$FFEF,10(A0)   ;und enabeln
s_replace4:     lea     replaces_rsc(PC),A0
                jsr     _form_do
                cmp.w   #5,D0           ;Begriffe vertauschen
                beq.s   s_replace
                cmp.w   #1,D0
                bne     main_loop
                jsr     garbage_collection ;bischen aufräumem
                lea     sym_repl_1(PC),A0 ;Zeiger auf Suchsymbol
                cmpi.w  #'~ ',(A0)      ;ersetzen mit Nummern?
                beq     s_replacenum    ;ja
                jsr     search_symbols  ;Tabelle erzeugen
                bclr    #7,sym_flag(A4) ;Buffer dirty für Symbol-Suchen
                tst.w   D0
                bmi.s   s_replace3      ;falsche Eingabe
                beq.s   s_replace2      ;nichts gefunden
                move.w  D0,block_pointer(A4)
                lea     allowed_chars,A2
                moveq   #0,D0
                lea     sym_repl_12(PC),A0
                move.b  (A0),D0
                cmp.b   #'*',D0
                beq.s   s_replace5
                tst.b   0(A2,D0.w)
                ble     s_replace3      ;falsche Eingabe
s_replace5:     lea     sym_repl_1(PC),A1
                moveq   #5,D0
s_replace6:     cmpm.l  (A0)+,(A1)+     ;die beiden Eingabemasken vergleichen
                dbne    D0,s_replace6
                beq     main_loop       ;gleich, dann Routine verlassen
                moveq   #-1,D2
                lea     sym_repl_1(PC),A0
s_replace7:     move.b  (A0)+,D0
                addq.w  #1,D2
                tst.b   0(A2,D0.w)      ;Zeichen erlaubt?
                bne.s   s_replace7      ;ja
                cmp.b   #'?',D0
                beq.s   s_replace7
                cmp.b   #'*',D0
                beq.s   s_replace8
                moveq   #-1,D2
s_replace8:     btst    #0,replaces_a+1(PC)
                beq     s_replace29     ;ersetzen im Block
                movem.l D4/A3-A6,-(SP)  ;D2 enthält die Position des '*' oder -1
                movea.l label_base(A4),A3
                movea.l ass_adr(A4),A6  ;Zeiger auf Tabelle
                move.w  anz_zeilen(A4),block_pointer+2(A4)
                clr.w   block_pointer(A4) ;Bereich setzen
                sf      block_pointer2(A4)
s_replace9:     moveq   #0,D0
                move.w  (A6)+,D0        ;Index aus Tabelle holen
                bmi     s_replace16     ;Ende der Tabelle
                lsl.l   #5,D0
                lea     8(A3,D0.l),A5   ;Zeiger auf Namen
                lea     spaced(A4),A1   ;Zeiger auf Buffer
                moveq   #0,D0
                move.l  D0,(A1)
                move.l  D0,4(A1)
                move.l  D0,8(A1)        ;Buffer löschen
                move.l  D0,12(A1)
                move.l  D0,16(A1)
                move.l  D0,20(A1)
                lea     sym_repl_12(PC),A0 ;Zeiger auf Ersatzstring
                moveq   #-1,D1
                move.b  (A0),D0         ;erstes Zeichen holen
                cmp.b   #'.',D0
                bne.s   s_replace10     ;kein lokales Symbol
                addq.w  #1,D1
                addq.l  #1,A0
                move.b  D0,(A1)+        ;erstes Zeichen übernehmen
s_replace10:    addq.w  #1,D1
                move.b  (A0)+,D0
                tst.b   0(A2,D0.w)      ;Zeichen erlaubt?
                beq.s   s_replace11     ;nein
                move.b  D0,(A1)+
                bra.s   s_replace10
s_replace11:    cmp.b   #'?',D0
                bne.s   s_replace12
                move.b  0(A5,D1.w),(A1)+ ;altes Zeichen übernehmen
                bra.s   s_replace10
s_replace12:    cmp.b   #'*',D0
                bne.s   s_replace14     ;wenn nicht, dann Endekennung
                move.w  D2,D0
                bmi.s   s_replace14     ;kein '*' in der Suchmaske
s_replace13:    move.b  0(A5,D0.w),(A1)+
                addq.w  #1,D0           ;Rest des Symbols übertragen
                cmp.w   #23,D0
                blt.s   s_replace13
s_replace14:    lea     spaced(A4),A0   ;Zeiger auf gebildetes Symbol
                clr.b   23(A0)          ;Nullbyte als Abschluß
                tst.w   (A0)            ;Symbol verschwunden?
                beq.s   s_replace18     ;ja
                bsr     search_label1   ;in Tabelle suchen
                tst.w   D0
                bpl.s   s_replace19     ;gefunden (Index in D0)
                lea     spaced(A4),A0
                moveq   #5,D0
s_replace15:    move.l  (A0)+,(A5)+     ;Symbolnamen abändern
                dbra    D0,s_replace15
                bra     s_replace9
s_replace16:    movem.l (SP)+,D4/A3-A6
s_replace17:    st      change_flag(A4) ;Sourcetext geändert
                tst.b   block_pointer2(A4)
                beq     main_loop       ;es wurden nur Namen geändert
                jsr     garbage_collection ;es wurden Indizes verändert
                bra     main_loop
s_replace18:    move.l  A5,replaces4    ;Zeiger auf Namen
                lea     replaces4_rsc(PC),A0
                jsr     _form_do        ;Alert 'Symbol verschwindet' ausgeben
                subq.w  #1,D0
                bne.s   s_replace16     ;ABBRUCH
                bra     s_replace9      ;nächstes Symbol
s_replace19:    lea     spaced(A4),A0
                move.l  A0,replaces2    ;Bufferadresse in der Resource setzen
                move.w  D0,D4           ;Index, durch den ersetzt wird
                st      block_pointer2(A4)
                lea     replaces2_rsc(PC),A0
                jsr     _form_do        ;Alert 'trotzdem ersetzen' ausgeben
                tst.w   D0
                bmi.s   s_replace16     ;UNDO->Abbruch
                cmp.w   #3,D0
                beq.s   s_replace16     ;ABBRUCH
                cmp.w   #1,D0
                bne     s_replace9      ;nicht ersetzen
                lea     block_pointer2+2(A4),A2
                move.w  -2(A6),(A2)     ;Index, der gesucht werden muß
                move.w  #$FFFF,2(A2)
                cmp.w   (A2),D4         ;Index gleich -> ersetzen überflüssig
                beq.s   s_replace21
                movem.l D2/D5/A5-A6,-(SP)
                moveq   #0,D2
                movea.l z_info_base(A4),A5
                movea.l program_base(A4),A6
                movea.l label_base(A4),A3
s_replace20:    move.l  #$FFFF,D5       ;Startposition innerhalb der Zeile
                bsr     s_such_syml6    ;Index suchen
                bpl.s   s_replace22     ;passendes Symbol gefunden
                adda.w  (A5),A6
                lea     10(A5),A5       ;eine Zeile weiter
                addq.w  #1,D2
                cmp.w   anz_zeilen(A4),D2 ;Endzeile
                blo.s   s_replace20     ;weiter suchen
                moveq   #0,D0
                move.w  (A2),D0         ;alten Index holen
                lsl.l   #5,D0
                lea     4(A3,D0.l),A5   ;Zeiger auf Eintrag
                andi.b  #$7F,(A5)       ;defined-bit löschen
                andi.b  #$7F,2(A5)      ;Flag für mehrfache Deklaration löschen
                move.b  #1,27(A5)       ;Eintrag freigeben
                movem.l (SP)+,D2/D5/A5-A6
s_replace21:    lea     allowed_chars,A2
                bra     s_replace9
s_replace22:    moveq   #0,D0
                cmpa.l  D0,A1           ;A1 gleich null
                bne.s   s_replace23     ;nein, dann kein Operand eines Opcodes
                move.w  D3,D5
                add.w   D5,D5           ;Operandennummer
                move.w  D4,D0           ;Index
                bsr.s   s_replace24     ;eintragen
                bra.s   s_replace20     ;weiter suchen
s_replace23:    andi.w  #$C000,(A1)
                or.w    D4,(A1)         ;Index hineinschreiben
                bra.s   s_replace20     ;weiter suchen

s_replace24:    moveq   #0,D0           ;Index D4 einsetzen
                move.w  2(A5,D5.w),D0
                bmi.s   s_replace26     ;Quickoperant
                move.w  D0,D1
                andi.w  #$0F,D1         ;EOffset
                btst    #5,D0
                beq.s   s_replace25     ;Word
                move.w  D4,2(A6,D1.w)   ;Labelindex setzen
                rts
s_replace25:    move.w  D4,0(A6,D1.w)   ;Labelindex setzen
                rts
s_replace26:    btst    #14,D0
                beq.s   s_replace27     ;$xx(An,Rx)
                move.w  D4,D0
                ori.w   #$C000,D0
                move.w  D0,2(A5,D5.w)
                rts
s_replace27:    move.w  D0,D1
                andi.w  #$0F,D1         ;EOffset
                btst    #4,D0
                bne.s   s_replace28     ;Registerliste
                move.w  D4,D0
                move.b  D0,0(A6,D1.w)   ;Low-Byte einsetzen
                andi.w  #$C0FF,2(A5,D5.w)
                andi.w  #$3F00,D0
                or.w    D0,2(A5,D5.w)   ;Highbyte einsetzen
                rts
s_replace28:    move.w  D4,2(A6)        ;Index der Registerliste einsetzen
                rts

s_replace29:    tst.b   block_fl(A4)
                beq     main_loop       ;kein Block definiert
                sf      block_pointer(A4) ;Flag löschen
                movem.l D3-D5/A3-A6,-(SP) ;D2 enthält die Position des '*' oder -1
                move.w  block_anf(A4),D4
                move.w  D4,D0
                jsr     calc_pointer    ;Zeiger auf Blockanfang berechnen
                movea.l label_base(A4),A3
                movea.l ass_adr(A4),A2
s_replace30:    move.l  #$FFFF,D5
s_replace31:    bsr     s_such_syml6    ;Zeile durchsuchen
                bpl.s   s_replace34     ;passendes Symbol gefunden
                adda.w  (A5)+,A6
                addq.l  #8,A5           ;eine Zeile weiter
                tst.w   (A5)
                bmi.s   s_replace32     ;Ende erreicht
                addq.w  #1,D4
                cmp.w   block_end(A4),D4 ;Ende erreicht ?
                blo.s   s_replace30     ;nein, weiter suchen
s_replace32:    tst.b   block_pointer(A4) ;wurde etwas gefunden
                bne.s   s_replace33     ;ja
                lea     replaces3_rsc(PC),A0 ;'Es wurde nichts gefunden'
                jsr     _form_do
s_replace33:    movem.l (SP)+,D3-D5/A3-A6
                jsr     garbage_collection ;Verwaltung in Ordnung bringen
                bra     main_loop
s_replace34:    st      block_pointer(A4) ;Flag setzen
                movem.l D3-D4/A2/A5-A6,-(SP)
                ext.l   D0              ;Index in D0
                lsl.l   #5,D0
                lea     8(A3,D0.l),A3   ;Zeiger auf Eintrag
                lea     allowed_chars,A2
                move.l  A1,-(SP)
                lea     spaced(A4),A1   ;Zeiger auf Buffer
                move.l  -8(A3),(A1)+    ;Wert in Buffer schreiben
                move.l  -4(A3),(A1)+    ;Flags in Buffer schreiben
                moveq   #0,D0
                move.l  D0,(A1)
                move.l  D0,4(A1)
                move.l  D0,8(A1)        ;Buffer löschen
                move.l  D0,12(A1)
                move.l  D0,16(A1)
                move.l  D0,20(A1)
                lea     sym_repl_12(PC),A0
                moveq   #-1,D1
s_replace35:    addq.w  #1,D1
                move.b  (A0)+,D0
                tst.b   0(A2,D0.w)      ;Zeichen erlaubt?
                beq.s   s_replace36     ;nein
                move.b  D0,(A1)+
                bra.s   s_replace35
s_replace36:    cmp.b   #'?',D0
                bne.s   s_replace37
                move.b  0(A3,D1.w),(A1)+ ;altes Zeichen übernehmen
                bra.s   s_replace35
s_replace37:    cmp.b   #'*',D0
                bne.s   s_replace39     ;wenn nicht, dann Endekennung
                move.w  D2,D0
                bmi.s   s_replace39     ;kein '*' in der Suchmaske
s_replace38:    move.b  0(A3,D0.w),(A1)+
                addq.w  #1,D0           ;Rest des Symbols übertragen
                cmp.w   #23,D0
                blt.s   s_replace38
s_replace39:    movea.l label_base(A4),A3
                lea     spaced+8(A4),A0 ;Zeiger auf gebildetes Symbol
                clr.b   23(A0)          ;Nullbyte als Abschluß
                bsr     search_label1   ;in Tabelle suchen
                tst.w   D0
                bpl.s   s_replace41     ;gefunden (Index in D0)
                lea     entry_buffer(A4),A0 ;Buffer für Adressen der Einträge
                move.l  A0,entry_pointer(A4) ;Zeiger auf Anfang setzen
                jsr     next_free_entry ;ordert Eintrag
                lea     spaced(A4),A0
                moveq   #7,D1
s_replace40:    move.l  (A0)+,(A1)+     ;Namen und Flags kopieren
                dbra    D1,s_replace40
s_replace41:    move.w  D0,D4           ;Index nach D4
                movea.l (SP)+,A1
                cmp.w   (A1),D4         ;Index gleich ?
                beq.s   s_replace46     ;ersetzen überflüssig
                moveq   #0,D0
                cmpa.l  D0,A1           ;A1 gleich null
                bne.s   s_replace42     ;nein, dann kein Operand eines Opcodes
                move.w  D3,D5
                add.w   D5,D5           ;Operandennummer
                move.w  D4,D0           ;Index
                bsr     s_replace24     ;eintragen
                bra.s   s_replace46     ;weiter suchen
s_replace42:    moveq   #0,D0
                move.w  (A1),D0
                andi.w  #$C000,(A1)
                or.w    D4,(A1)         ;Index hineinschreiben
                tst.w   D3
                bpl.s   s_replace46     ;weiter suchen
                move.w  D0,D1
                lsl.l   #5,D0
                tst.b   6(A3,D0.l)      ;doppelte Deklaration
                bpl.s   s_replace45     ;nein
                movem.l D2/A0,-(SP)
                move.w  #-2,D2
                movea.l z_info_base(A4),A0
                lea     6(A0),A0
s_replace43:    cmp.w   (A0)+,D1
                bne.s   s_replace44
                addq.w  #1,D2
s_replace44:    addq.w  #8,A0
                tst.w   -6(A0)
                bpl.s   s_replace43
                move.w  D2,D1
                movem.l (SP)+,D2/A0
                tst.w   D1
                bne.s   s_replace46     ;mehr als 2 mal,weiter suchen
                andi.b  #$7F,6(A3,D0.l) ;Flag für doppelte Deklaration löschen
                bra     s_replace20     ;weiter suchen
s_replace45:    andi.b  #$7F,4(A3,D0.l) ;defined-flag löschen
s_replace46:    movem.l (SP)+,D3-D4/A2/A5-A6
                move.l  D3,D5           ;Suchzeiger setzen
                bmi.s   s_replace47     ;=$FFFFFFFF (Labeldefinition)
                swap    D5
                addq.w  #1,D5           ;einen Operanden weiter
                swap    D5
                bra     s_replace31
s_replace47:    moveq   #0,D5
                bra     s_replace31

s_replacenum:   btst    #0,replaces_a+1(PC) ;spezielles Ersetzen mit fortlaufenden Nummern
                bne     main_loop       ;'alles ersetzen' nicht erlaubt
                tst.b   block_fl(A4)
                beq     main_loop       ;kein Block definiert
                movem.l D0-D1/D3/A0-A3/A5,-(SP)
                movea.l z_info_base(A4),A5
                moveq   #0,D0
                move.w  block_anf(A4),D0 ;Blockanfang
                mulu    #10,D0          ;mal Eintragslänge
                adda.l  D0,A5           ;Zeiger auf Zeile
                move.w  block_end(A4),D3 ;Blockende
                cmp.w   anz_zeilen(A4),D3 ;mit max. Anzahl vergleichen
                bls.s   s_replacenum1   ;kleiner
                move.w  anz_zeilen(A4),D3 ;Blockende gleich Sourcetextende
s_replacenum1:  sub.w   block_anf(A4),D3 ;Anzahl Zeilen berechnen
                subq.w  #1,D3           ;wegen DBRA
                sf      block_pointer2(A4) ;es werden nur Namen geändert
                movea.l label_base(A4),A3 ;Zeiger auf Symboltabelle
                movem.l D3/A5,-(SP)     ;Zeiger auf Block und Blocklänge retten
                moveq   #0,D0           ;Beginn des ersten Durchlaufs
s_replacenum2:  move.w  6(A5),D0        ;Index der Symboldefinition
                bmi.s   s_replacenum3   ;kein Index
                lsl.l   #5,D0           ;mal 32
                st      9(A3,D0.l)      ;Symbolnamen auf unmöglichen Wert ändern
                moveq   #0,D0
s_replacenum3:  lea     10(A5),A5       ;nächste Zeile
                dbra    D3,s_replacenum2
                movem.l (SP)+,D3/A5     ;Zeiger und Länge zurückholen
                lea     allowed_chars,A2 ;erlaubte Zeichen
                lea     sym_repl_12(PC),A1 ;Zeiger auf Ersatzstring
                lea     spaced(A4),A0   ;Buffer für Namen
                clr.l   (A0)+
                clr.l   (A0)+           ;Buffer löschen
                clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)
                lea     spaced(A4),A0   ;Zeiger zurück
                moveq   #23-5,D1        ;nur maximal 18 Zeichen wegen Nummer
                moveq   #0,D0
s_replacenum4:  move.b  (A1)+,D0        ;Zeichen holen
                move.b  D0,(A0)+        ;und schreiben
                tst.b   0(A2,D0.w)      ;Zeichen erlaubt?
                dbeq    D1,s_replacenum4 ;ja
                clr.b   -(A0)
                tst.w   spaced(A4)      ;Name vorhanden?
                beq.s   s_replacenum10  ;nein->raus
                movea.l A0,A2           ;Zeiger für Nummer
                moveq   #-1,D1          ;Zähler für Nummern
s_replacenum5:  move.w  6(A5),D0        ;Index der Symboldefinition
                bmi.s   s_replacenum9   ;kein Symbol definiert
                ext.l   D0
                lsl.l   #5,D0           ;mal 32
                addq.w  #1,D1           ;Zähler erhöhen
                beq.s   s_replacenum6   ;erstes Symbol ohne Nummer
                movea.l A2,A0           ;Zeiger für Nummer
                bsr     s_dezw_out      ;Nummer ausgeben
                clr.b   (A0)            ;Endekennung
s_replacenum6:  lea     8(A3,D0.l),A1   ;Zeiger auf Symbolname
s_replacenum7:  lea     spaced(A4),A0   ;Zeiger auf neuen Namen
                movem.l A0-A1,-(SP)     ;Zeiger retten
                bsr.s   search_label1   ;prüfen, ob es das Symbol schon gibt
                movem.l (SP)+,A0-A1     ;Zeiger zurückholen
                tst.w   D0              ;enthält Index, wenn es existiert
                bpl.s   s_replacenum11  ;existiert
                moveq   #5,D0           ;24 Bytes
s_replacenum8:  move.l  (A0)+,(A1)+     ;neuen Namen übertragen
                dbra    D0,s_replacenum8
s_replacenum9:  lea     10(A5),A5       ;eine Zeile weiter
                dbra    D3,s_replacenum5 ;nächste Zeile
s_replacenum10: movem.l (SP)+,D0-D1/D3/A0-A3/A5
                bra     s_replace17     ;raus
s_replacenum11: addq.w  #1,D1           ;nächste Nummer
                movea.l A2,A0           ;Zeiger für Nummer
                bsr     s_dezw_out      ;Nummer ausgeben
                clr.b   (A0)            ;Endekennung
                bra.s   s_replacenum7   ;erneut versuchen

search_label1:  movem.l D2-D4/A2,-(SP)
                moveq   #0,D0
                move.l  A0,D3
                movea.l label_base(A4),A1
                move.w  label_top_ind(A4),D2
                addq.l  #8,A1
search_label2:  cmp.w   D2,D0
                beq.s   search_label5   ;Ende der Tabelle
                tst.b   31-8(A1)
                bne.s   search_label4   ;kein Symboleintrag
                movea.l A1,A2
                movea.l D3,A0
                moveq   #5,D4
search_label3:  cmpm.l  (A0)+,(A2)+     ;Symbolnamen vergleichen
                dbne    D4,search_label3
                bne.s   search_label4
                movem.l (SP)+,D2-D4/A2
                rts
search_label4:  addq.w  #1,D0
                lea     32(A1),A1       ;nächster Eintrag
                bra.s   search_label2
search_label5:  moveq   #-1,D0
                movem.l (SP)+,D2-D4/A2
                rts
replaces_rsc:   DC.W 0,0,33,15,1
                DC.W 8,1
                DC.L sym_repl_0
                DC.W 8
                DC.W 5,3
                DC.L sym_repl_1
                DC.W $88
                DC.W 4,13
                DC.L ok_button
                DC.W $26
                DC.W 20,13
                DC.L abbruch_button
                DC.W $24
                DC.W 1,11
                DC.L sym_repl_4
                DC.W 8
                DC.W 13,11
                DC.L sym_repl_5
replaces_a:     DC.W $45
                DC.W 23,11
                DC.L sym_repl_6
                DC.W $44
                DC.W 1,9
                DC.L sym_repl_7
                DC.W 8
                DC.W 15,9
                DC.L sym_repl_8
                DC.W 8
                DC.W 12,9
                DC.L sym_repl_9
                DC.W 8
                DC.W 31,9
                DC.L sym_repl_10
                DC.W 8
                DC.W 8,5
                DC.L sym_repl_11
                DC.W 8
                DC.W 5,7
                DC.L sym_repl_12
                DC.W $88
                DC.W 2,5
                DC.L sym_repl_13
                DC.W $24
                DC.W -1

                SWITCH sprache
                CASE 0
sym_repl_0:     DC.B 'Symbolnamen suchen',0
sym_repl_4:     DC.B 'Bereich:',0
sym_repl_5:     DC.B ' alles ',0
sym_repl_6:     DC.B ' Block ',0
sym_repl_7:     DC.B 'Allquantor:',0
sym_repl_8:     DC.B 'Existenzquantor:',0
sym_repl_11:    DC.B 'und ersetzen durch',0
                CASE 1
sym_repl_0:     DC.B 'Search for symbol',0
sym_repl_4:     DC.B 'area:',0
sym_repl_5:     DC.B ' all ',0
sym_repl_6:     DC.B ' block ',0
sym_repl_7:     DC.B 'allquantor:',0
sym_repl_8:     DC.B 'existenzquantor:',0
sym_repl_11:    DC.B 'and replaces by',0
                ENDS
sym_repl_13:    DC.B '  ',0
sym_repl_9:     DC.B '*',0
sym_repl_10:    DC.B '?',0
                EVEN
sym_repl_1:     DC.B $FF,'12345678901234567890123',0
                EVEN
sym_repl_12:    DC.B $FF,'12345678901234567890123',0
                EVEN
replaces1_rsc:  DC.W 0,0,37,7,1
                DC.W 1,1
                DC.L replaces1_0
                DC.W 8
                DC.W 1,3
                DC.L replaces1_1
                DC.W 8
                DC.W 15,5
                DC.L replaces_5
                DC.W $26
                DC.W -1
replaces2_rsc:  DC.W 0,0,32,7,1
                DC.W 1,1
                DC.L replaces2_0
                DC.W 8
                DC.W 12,1
replaces2:      DC.L 0          ;Adresse des Buffers
                DC.W 8
                DC.W 1,3
                DC.L replaces2_1
                DC.W 8
                DC.W 1,5
                DC.L replaces_4
                DC.W $24
                DC.W 12,5
                DC.L replaces_5
                DC.W $26
                DC.W 21,5
                DC.L abbruch_button
                DC.W $24
                DC.W -1
replaces3_rsc:  DC.W 0,0,36,7,1
                DC.W 1,1
                DC.L replaces3_0
                DC.W 8
                DC.W 3,3
                DC.L replaces3_1
                DC.W 8
                DC.W 14,5
                DC.L abbruch_button
                DC.W $26
                DC.W -1
replaces4_rsc:  DC.W 0,0,34,7,1
                DC.W 1,1
                DC.L replaces2_0
                DC.W 8
                DC.W 12,1
replaces4:      DC.L 0          ;hier wird die Adresse eingesetzt
                DC.W 8
                DC.W 1,3
                DC.L replaces4_0
                DC.W 8
                DC.W 5,5
                DC.L replaces_5
                DC.W $26
                DC.W 20,5
                DC.L abbruch_button
                DC.W $24
                DC.W -1

                SWITCH sprache
                CASE 0
replaces4_0:    DC.B 'würde einen Leerstring ergeben !',0
replaces3_0:    DC.B 'Es konnten keine passenden Symbole',0
replaces3_1:    DC.B 'in dem Block gefunden werden !',0
replaces2_0:    DC.B 'Das Symbol:',0
replaces2_1:    DC.B 'ist bereits verwendet worden !',0
replaces1_0:    DC.B 'Es konnten keine Symbole passend',0
replaces1_1:    DC.B 'zu der Suchmaske gefunden werden !',0
replaces_4:     DC.B ' ERSETZEN ',0
replaces_5:     DC.B ' WEITER ',0
                CASE 1
replaces4_0:    DC.B 'would created an empty string!',0
replaces3_0:    DC.B 'There are no fitting symbols',0
replaces3_1:    DC.B 'in this block!',0
replaces2_0:    DC.B 'The symbol:',0
replaces2_1:    DC.B 'has already been used!',0
replaces1_0:    DC.B 'There are no symbols that fit',0
replaces1_1:    DC.B 'into the given search-mask!',0
replaces_4:     DC.B ' REPLACE ',0
replaces_5:     DC.B ' NEXT ',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* gibt eine Dezimalzahl (bis 65535) ohne führende Nullen/Spaces aus    *
* ->D1: Hexzahl                                                        *
* ->A0: Zeiger auf Buffer                                              *
************************************************************************
                >PART 's_dezw_out'
s_dezw_out:     movem.l D1-D2/A1,-(SP)
                and.l   #$FFFF,D1       ;oberes Word löschen
                beq.s   s_dezw_o2       ;gleich null
                moveq   #0,D2           ;Flag löschen
                lea     s_dezw_o1(PC),A1 ;Zeiger auf Tabelle
s_dezw_o3:      divu    (A1)+,D1        ;durch Stellenwert teilen
                cmp.w   D2,D1
                beq.s   s_dezw_o4       ;null
                add.b   #'0',D1
                move.b  D1,(A0)+        ;Ziffer schreiben
                moveq   #11,D2          ;Flag setzen
s_dezw_o4:      swap    D1              ;Rest holen
                ext.l   D1
                tst.w   (A1)
                bne.s   s_dezw_o3       ;nächste Stelle
                movem.l (SP)+,D1-D2/A1
                rts
s_dezw_o2:      move.b  #'0',(A0)+
                movem.l (SP)+,D1-D2/A1
                rts
s_dezw_o1:      DC.W 10000,1000,100,10,1,0
                ENDPART
************************************************************************
* Repeat-Funktion                                                      *
************************************************************************
                >PART 's_repeat'
s_repeat:       lea     repeat_r_01(PC),A0
                move.b  last_char(A4),(A0)
                lea     repeat_rsc(PC),A0
                jsr     _form_do
                tst.w   D0
                bmi     edit02
                subq.w  #2,D0
                beq     edit02
                move.l  D2,-(SP)
                lea     repeat_r_1(PC),A0
                moveq   #1,D2
                moveq   #0,D1
                bsr     s_get_zahl
                move.l  (SP)+,D2
                subi.w  #1,D1
                bmi     edit02
                cmp.w   #$80,D1
                bhi     edit02
                move.b  last_char(A4),D0
s_repeat2:      bsr     zset_char2
                dbra    D1,s_repeat2
                bra     edit06

repeat_rsc:     DC.W 0,0,39,5,1
                DC.W 2,1
                DC.L repeat_r_0
                DC.W 8
                SWITCH sprache
                CASE 0
                DC.W 18,1
                CASE 1
                DC.W 22,1
                ENDS
                DC.L repeat_r_1
                DC.W $A8
                DC.W 5,3
                DC.L ok_button
                DC.W $26
                DC.W 24,3
                DC.L abbruch_button
                DC.W $24
                SWITCH sprache
                CASE 0
                DC.W 21,1
                CASE 1
                DC.W 24,1
                ENDS
                DC.L repeat_r_4
                DC.W 8
                DC.W -1
                SWITCH sprache
                CASE 0
repeat_r_0:     DC.B "Das Zeichen '"
repeat_r_01:    DC.B "?'",0
repeat_r_4:     DC.B 'mal wiederholen.',0
                CASE 1
repeat_r_0:     DC.B "Repeat the char '"
repeat_r_01:    DC.B "?'",0
repeat_r_4:     DC.B ' times.',0
                ENDS
repeat_r_1:     DC.B $FF,'2',0
                EVEN
                ENDPART
************************************************************************
* Zeichen aus Tabelle ausgeben                                         *
************************************************************************
                >PART 's_char_out'
s_char_out:     bsr     s_char_tab
                tst.w   D0
                beq     edit02
                bsr     zset_char2
                bra     edit06
                ENDPART
************************************************************************
* aktuellen Pfad retten bzw. zurücksetzen (im 2k-Diskbuffer !!!)       *
************************************************************************
                >PART 'save_path'
save_path:      movem.l D0-A6,-(SP)     ;jetzigen Pfad merken
                lea     dbuffer(A4),A6
                move.w  #$19,-(SP)
                jsr     do_trap_1       ;Dgetdrv()
                addq.l  #2,SP
                move.w  D0,(A6)+
                clr.w   -(SP)           ;akt.Drive
                move.l  A6,-(SP)
                move.w  #$47,-(SP)
                jsr     do_trap_1       ;Dgetpath()
                addq.l  #8,SP
save_path1:     tst.b   (A6)+           ;Ende des Pfades suchen
                bne.s   save_path1
                move.b  #'\',-1(A6)     ;und Endekennung dran
                clr.b   (A6)            ;und Pfad abschließen
                movem.l (SP)+,D0-A6
                rts
old_path:       movem.l D0-A6,-(SP)     ;alten Pfad wieder setzen
                lea     dbuffer(A4),A6
                move.w  (A6)+,-(SP)
                move.w  #$0E,-(SP)
                jsr     do_trap_1       ;DSetdrv()
                addq.l  #4,SP
                move.l  A6,-(SP)
                move.w  #$3B,-(SP)
                jsr     do_trap_1       ;DSetpath()
                addq.l  #6,SP
                movem.l (SP)+,D0-A6
                rts
                ENDPART
************************************************************************
* temp.Fileselector-Pfad setzen                                        *
************************************************************************
                >PART 's_fsel_path'
s_fsel_path:    movem.l D0-A6,-(SP)
                lea     s_load_dbg8(PC),A3 ;keinen Filenamen
                bsr     hunt_environment ;Environment-String vorhanden?
                bne.s   s_fsel_path2    ;Nein! =>
                cmpi.b  #':',1(A3)      ;Drivekennung
                bne.s   s_fsel_path1    ;nein
                moveq   #0,D0
                move.b  (A3),D0         ;Buchstaben holen
                sub.w   #'A',D0
                move.w  D0,-(SP)
                move.w  #$0E,-(SP)      ;Dsetdrv()
                jsr     do_trap_1
                addq.l  #4,SP
                tst.l   D0
                bmi.s   s_fsel_path2    ;Fehler in Drivenummer
                addq.l  #2,A3
s_fsel_path1:   move.l  A3,-(SP)        ;Zeiger Pfadnamen
                move.w  #$3B,-(SP)
                jsr     do_trap_1       ;Dsetpath()
                addq.l  #6,SP
s_fsel_path2:   movem.l (SP)+,D0-A6
                rts
                ENDPART
************************************************************************
* Debugger nachladen                                                   *
************************************************************************
                >PART 's_load_dbg'
s_load_dbg:     btst    #1,debugger_entry2 ;disabled ?
                bne     main_loop       ;ja
                sf      block_pointer(A4) ;Flag für Nachladen
                jsr     do_mediach      ;Media-Change wenn nötig
                bsr.s   s_load_dbg2
                bra     main_loop
s_load_dbg1:    lea     outofmem_rsc(PC),A0
                jmp     _form_do
s_load_dbg2:    move.l  memory_gem(A4),D0 ;vorhandener GEM-Speicher
                cmp.l   #240000,D0      ;240k
                blo.s   s_load_dbg1     ;Speicher reicht nicht
                movem.l D0-A6,-(SP)
                lea     fname_temp(A4),A1
                movea.l A1,A0
                move.l  #'BUGA',(A0)+
                move.l  #'BOO.',(A0)+   ;Filenamen setzen
                move.l  #'PRG'<<8,(A0)
                movea.l A1,A3
                lea     fpath_sel(A4),A0
                bsr     save_path       ;aktuellen Pfad retten
                bsr     s_fsel_path     ;Pfad evtl. auf Environment-String setzen
                move.w  #7,-(SP)
                pea     fname_temp(A4)
                move.w  #$4E,-(SP)
                jsr     do_trap_1       ;Fsfrist("BUGABOO.PRG")
                addq.l  #8,SP
                tst.l   D0
                spl     block_pointer(A4)
                tst.b   block_pointer(A4) ;Debugger gefunden?
                bne.s   s_load_dbg3     ;ja
                lea     s_dbg_txt(PC),A2 ;Header für Fsel_exinput()
                move.l  #'GRP',D0       ;keine Extension vorgegeben
                bsr     _fsel_input
                bmi     s_load_dbg7
                tst.w   D7              ;ABBRUCH
                beq     s_load_dbg7
s_load_dbg3:    movea.l screen_adr(A4),A0 ;Adresse der Assemblerseite
                move.l  A0,_screenadr   ;Adresse vor Magic setzen
                jsr     org_driver
                lea     8.w,A0
                lea     save_data(A4),A1
                move.l  $04BA.w,$04BA-8(A1) ;200 Hz-Counter setzen
                move.w  #323,D1
s_load_dbg4:    move.l  (A1)+,(A0)+     ;$8-$517 zurücksetzen
                dbra    D1,s_load_dbg4
                move.l  #_trap3,D7
                move.l  D7,$8C.w        ;Trap #3 wieder auf Assembler setzen
                lea     own_stack(PC),A0
                movem.l D1-D7/A1-A7,8(A0) ;Register retten
                move    USP,A1
                move.l  A1,4(A0)        ;Userstackpointer retten

                move.l  memory_gem(A4),D0 ;verfübarer Speicher
                sub.l   #200000,D0      ;minus 200000 Bytes
                move.l  D0,-(SP)
                move.w  #$48,-(SP)      ;Malloc
                jsr     do_trap_1       ;soviel Speicher allozieren, damit der
                addq.l  #6,SP           ;Debugger ans Ende geladen wird
                move.l  D0,(A0)         ;Adresse des Blocks merken

                clr.l   -(SP)           ;Environmentstring übernehmen
                pea     s_load_dbg8(PC) ;Commandline
                pea     fname_temp(A4)  ;Prgname
                move.l  #$4B0003,-(SP)  ;Load only
                trap    #1              ;Pexec()
                lea     16(SP),SP
                tst.l   D0              ;<=0 ?
                ble.s   s_load_dbg5     ;=> Fehler
                move.l  D0,dbg_basepage(A4) ;Basepageadr des Debuggers

                clr.l   -(SP)           ;Debugger starten
                move.l  D0,-(SP)        ;Basepageadr
                clr.l   -(SP)
                move.l  #$4B0004,-(SP)  ;Run
                trap    #1              ;Pexec()
                lea     16(SP),SP

s_load_dbg5:    lea     own_stack(PC),A0
                movea.l 4(A0),A1
                move    A1,USP          ;USP zurückholen
                movem.l 8(A0),D1-D7/A1-A7 ;Register zurück
                move.l  D7,$8C.w        ;Trap #3 wieder auf Assembler setzen
                move.l  (A0),-(SP)
                move.w  #$49,-(SP)      ;Speicherblock wieder freigeben
                jsr     do_trap_1
                addq.l  #6,SP

                movea.l 8.w,A0          ;Busfehlervektor holen
                cmpi.w  #'∑-',-(A0)
                bne.s   s_load_dbg6     ;Vektor des Debuggers?
                cmpi.l  #'Soft',-(A0)
                bne.s   s_load_dbg6
                move.l  -(A0),debugger_adr(A4) ;Startadresse
                lea     debugger_entry,A0
                moveq   #$FD,D0
                and.b   D0,(A0)
                and.b   D0,debugger_entry3-debugger_entry(A0)
                ori.b   #2,debugger_entry2-debugger_entry(A0)
                st      debugger_da(A4)
                move.w  #10,asm_default(A4) ;Defaultbutton=Debugger
s_load_dbg6:
                jsr     my_driver       ;Assemblertreiber rein
                moveq   #-1,D0
                move.l  D0,-(SP)
                move.w  #$48,-(SP)      ;Malloc(-1)
                jsr     do_trap_1
                addq.l  #6,SP
                move.l  memory_gem(A4),D1 ;alter GEM-Speicher
                move.l  D0,memory_gem(A4) ;neuen GEM-Speicher setzen
                sub.l   D0,D1           ;Länge des Debuggers
                sub.l   D1,memory_free(A4) ;gesamter freier Speicher

s_load_dbg7:    bsr     old_path        ;aktuellen Pfad zurück
                moveq   #0,D0
                jsr     _graf_mouse     ;Maus wieder als Pfeil
                movem.l (SP)+,D0-A6
                rts
s_load_dbg8:    DC.W 0
                ENDPART
************************************************************************
* Debugger wieder löschen                                              *
************************************************************************
                >PART 's_kill_dbg'
s_kill_dbg:     lea     kill_dbg_rsc(PC),A0
                jsr     _form_do
                subq.w  #1,D0
                ble     main_loop       ;ABBRUCH
                bsr.s   kill_debugger
                bra     main_loop
kill_dbg_rsc:   DC.W 0,0,30,5,1
                DC.W 2,1
                DC.L kill_dbg_txt1
                DC.W 8
                DC.W 18,3
                DC.L abbruch_button
                DC.W $24
                DC.W 4,3
                DC.L ok_button
                DC.W $26
                DC.W -1
kill_dbg_txt1:  SWITCH sprache
                CASE 0
                DC.B 'Debugger wirklich löschen?',0
                CASE 1
                DC.B 'Sure to kill the debugger?',0
                ENDS
                EVEN
                ENDPART
                >PART 'kill_debugger'
kill_debugger:  move.l  dbg_basepage(A4),D0
                beq     kill_debugger2
                move.l  D7,-(SP)
                movea.l D0,A0
                move.l  $2C(A0),-(SP)   ;Adresse des Environmentstrings
                move.l  A0,-(SP)
                move.w  #$49,-(SP)
                jsr     do_trap_1       ;ab Basepage freigeben
                addq.l  #6,SP
                move.l  D0,D7
                move.w  #$49,-(SP)
                jsr     do_trap_1       ;Environmentstring freigeben
                addq.l  #6,SP
                or.l    D0,D7
                beq.s   kill_debugger1
                BREAKPT ';Debugger-Speicher nicht freigegeben' ;Fehler bei Mfree()
kill_debugger1: lea     debugger_entry,A0
                moveq   #2,D0
                or.b    D0,(A0)
                or.b    D0,debugger_entry3-debugger_entry(A0)
                andi.b  #$FD,debugger_entry2-debugger_entry(A0)
                sf      debugger_da(A4)
                clr.l   dbg_basepage(A4) ;Adresse löschen
                moveq   #-1,D0
                move.l  D0,-(SP)
                move.w  #$48,-(SP)      ;Malloc(-1)
                jsr     do_trap_1
                addq.l  #6,SP
                move.l  memory_gem(A4),D1
                move.l  D0,memory_gem(A4) ;GEM-Speicher neu setzen
                sub.l   D1,D0
                add.l   D0,memory_free(A4)
                move.l  (SP)+,D7
kill_debugger2: rts
                ENDPART
************************************************************************
* TURBOASS.CFG neu laden                                               *
************************************************************************
                >PART 's_load_cfg'
s_load_cfg:     movem.l D0-A6,-(SP)
                lea     fname_temp(A4),A1
                movea.l A1,A0
                lea     cfg_filename,A2
s_load_cfg2:    move.b  (A2)+,(A0)+     ;'TURBOASS.CFG' als Filenamen
                bne.s   s_load_cfg2
                lea     fpath_temp(A4),A0
                lea     s_cfg_txt(PC),A2 ;Header für Fsel_exinput()
                move.l  #'GFC',D0       ;keine Extension vorgegeben
                bsr     _fsel_input
                bmi.s   s_load_cfg1     ;Fehler =>
                tst.w   D7              ;ABBRUCH
                beq.s   s_load_cfg1
                move.l  #prn_default2,prt_tab1(A4) ;alten Drucker abmelden
                move.l  #prn_default3,prt_tab2(A4)
                lea     prt_type,A0
                moveq   #11,D0
s_load_cfg0:    move.b  #' ',(A0)+      ;alten Druckernamen löschen
                dbra    D0,s_load_cfg0
                moveq   #1,D0           ;Maus als Disk
                jsr     _graf_mouse
                lea     fname_temp(A4),A3 ;Filename
                jsr     do_read_cfg     ;Druckeranpassung laden
                moveq   #0,D0           ;Maus wieder normal
                jsr     _graf_mouse
s_load_cfg1:    movem.l (SP)+,D0-A6
                bra     main_loop

s_cfg_txt:      SWITCH sprache
                CASE 0
                DC.B 'DRUCKERANPASSUNG LADEN',0
                CASE 1
                DC.B 'LOAD PRINTERCONFIGURATION',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* ASCII-Sourcetext zuladen                                             *
************************************************************************
                >PART 's_merge'
s_merge:        st      bell_flag(A4)
                lea     fname_src(A4),A0 ;Name des Sourcecodes
                lea     fname_temp(A4),A1
s_merge_01:     move.b  (A0)+,D0        ;Namen kopieren
                move.b  D0,(A1)+
                beq.s   s_merge_02
                cmp.b   #'.',D0
                bne.s   s_merge_01
s_merge_02:     subq.l  #1,A1           ;Default-Extension einsetzen
                move.l  spezial_11,D0
                rol.l   #8,D0
                cmp.b   #' ',D0
                beq.s   s_merge_04      ;keine Extension
                move.b  #'.',(A1)+
                move.b  D0,(A1)+
s_merge_03:     rol.l   #8,D0
                cmp.b   #' ',D0
                beq.s   s_merge_04
                move.b  D0,(A1)+
                bne.s   s_merge_03
s_merge_04:     clr.b   (A1)+
                lea     fpath_temp(A4),A0 ;Pfadname
                lea     fname_temp(A4),A1
                lea     s_merge_txt(PC),A2 ;Header für Exfsel_input()
                lea     spezial_11+4,A1
                moveq   #3,D1
s_merge0:       rol.l   #8,D0
                move.b  -(A1),D0
                cmp.b   #' ',D0         ;Defaultextension gespiegelt nach D0
                bne.s   s_merge1
                clr.b   D0
s_merge1:       dbra    D1,s_merge0
                lea     fpath_temp(A4),A0 ;Pfadname
                lea     fname_temp(A4),A1
                bsr     _fsel_input     ;Fileselektor aufrufen
                tst.w   D7
                beq     main_loop       ;Abbruch
                moveq   #1,D0
                jsr     _graf_mouse
                clr.w   -(SP)
                pea     fname_temp(A4)
                bsr.s   s_ascii_init    ;Blockzähler initialisieren
                move.w  #$3D,-(SP)      ;Fopen()
                jsr     do_trap_1
                addq.w  #8,SP
                move.w  D0,fhandle(A4)
                bmi     _load_error
                clr.b   dbuffer+2048(A4)
                bsr     s_ascii_read
                clr.w   err_count(A4)
                move.b  #1,load_fl(A4)
                jsr     cursor_off
                move.w  D6,s_zeile(A4)
                move.w  top_line(A4),s_spalte(A4)
                move.w  #30,zei_count(A4)
                bra     s_read_loop2
                ENDPART
                >PART 's_ascii_init'
                SWITCH sprache
                CASE 0
s_merge_txt:    DC.B 'ASCII-SOURCE ZULADEN',0
                EVEN
ascii_load_txt: DC.B '   0kB von '
ascii_load_txt1:DC.B '   0kB',0
                EVEN
                CASE 1
s_merge_txt:    DC.B 'MERGE ASCII-SOURCE',0
                EVEN
ascii_load_txt: DC.B '   0kB of '
ascii_load_txt1:DC.B '   0kB',0
                EVEN
                ENDS
ascii_load_rsc: DC.W 0,0,19,3,1
                DC.W 1,1
                DC.L ascii_load_txt
                DC.W 8
                DC.W -1
s_ascii_init:   movem.l D0-D2/D4/A0-A2,-(SP) ;Blockzähler initialisieren
                move.w  #1,-(SP)
                move.l  34(SP),-(SP)    ;Filename vom Stack holen (7 Register+Rücksprung+1 Word)
                move.w  #$4E,-(SP)      ;Fsfirst
                trap    #1
                addq.l  #8,SP
                tst.w   D0
                bmi.s   s_ascii_in1     ;Datei nicht gefunden
                move.w  #$2F,-(SP)      ;Fgetdta
                trap    #1
                addq.l  #2,SP
                movea.l D0,A0
                move.l  26(A0),D1       ;Dateilänge holen
                moveq   #10,D0
                asr.l   D0,D1           ;durch 1024 dividieren
                bcc.s   s_ascii_in2     ;geht glatt auf
                addq.w  #2,D1
s_ascii_in2:    ext.l   D1
                lea     ascii_load_txt1(PC),A0
                st      testwrd(A4)     ;Ausgabe in Buffer
                moveq   #3,D4           ;4 Stellen
                jsr     dezw_out
                sf      testwrd(A4)
s_ascii_in1:    lea     ascii_load_txt(PC),A0
                move.l  #'   0',(A0)
                lea     ascii_load_rsc+8(PC),A0
                move.w  #1,(A0)
                movem.l (SP)+,D0-D2/D4/A0-A2
                rts
                ENDPART
                >PART 's_ascii_inc'
s_ascii_inc:    move.l  A0,-(SP)        ;Blockanzahl erhöhen und ausgeben
                lea     ascii_load_rsc(PC),A0
                jsr     _objc_draw
                lea     ascii_load_txt+4(PC),A0 ;Zeiger hinter die letzte Ziffer
                addq.b  #2,-(A0)        ;plus 2
                cmpi.b  #'9'+1,(A0)     ;Übertrag?
                blt.s   s_ascii_l11     ;nein
                move.b  #'0',(A0)       ;wieder auf Null setzen
s_ascii_l12:    cmpi.b  #' ',-(A0)      ;Space?
                bne.s   s_ascii_l13     ;nein
                move.b  #'0',(A0)       ;Null einsetzen
s_ascii_l13:    addq.b  #1,(A0)         ;Stelle erhöhen
                cmpi.b  #'9'+1,(A0)
                blt.s   s_ascii_l11     ;kein Übertrag
                move.b  #'0',(A0)       ;wieder auf Null setzen
                bra.s   s_ascii_l12
s_ascii_l11:    lea     ascii_load_rsc+8(PC),A0
                move.w  #2,(A0)         ;Redraw ohne Löschen
                movea.l (SP)+,A0
                rts
                ENDPART
************************************************************************
* ASCII-Sourcetext laden                                               *
************************************************************************
                >PART 's_ascii_load'
s_ascii_load:   jsr     fclose          ;File schließen (wegen Fsfirst)
                clr.w   -(SP)
                pea     fname_src(A4)
                bsr     s_ascii_init    ;Blockzähler initialisieren
                move.w  #$3D,-(SP)      ;Fopen()
                jsr     do_trap_1
                addq.w  #8,SP
                move.w  D0,fhandle(A4)
                bmi     _load_error
                clr.b   dbuffer+2048(A4)
                bsr     s_ascii_read
                lea     0(A1,D0.w),A0
                subq.w  #1,D0
s_asc30:        tst.b   -(A0)           ;sind Nullbytes im Buffer
                dbeq    D0,s_asc30
                beq     _format_error   ;ja->kein ASCII-Text
                clr.w   zeile(A4)
                st      load_fl(A4)
                move.l  ass_adr(A4),local_pointer(A4)
                bclr    #7,sym_flag(A4)
                move.w  #1,zei_count(A4)
                clr.w   err_count(A4)
                jsr     cursor_off
                move.l  label_max(A4),D0
                sub.l   label_base(A4),D0
                lsr.l   #5,D0
                subq.w  #2,D0
                move.w  D0,block_pointer2(A4) ;max. Einträge in der Tabelle
                move.l  program_max(A4),D0
                sub.l   program_base(A4),D0
                move.l  D0,block_pointer+8(A4)
                move.l  z_info_max(A4),D0
                sub.l   z_info_base(A4),D0 ;verfügbaren Speicher
                move.l  D0,block_pointer+4(A4) ;errechnen
                move.l  comment_max(A4),D0
                sub.l   comment_base(A4),D0
                move.l  D0,block_pointer(A4)
s_read_loop2:   lea     dbuffer+2048(A4),A0
                move.l  A0,D3
                lea     zeingabe+2(A4),A0
                jsr     clear_buffer
                move.w  #254,D0         ;Länge des Buffers
                moveq   #-1,D2          ;Spalte=-1 (weiter unten +1)
                clr.w   tab_spalte(A4)  ;Tabulatorspalte=0
s_asc141:       move.b  (A1)+,D4
                cmp.b   #9,D4           ;ein Tabulator?
                bne.s   s_asc140        ;Nein! =>
                moveq   #' ',D4         ;in ein Space wandeln
s_asc140:       addq.w  #1,D2
                cmp.b   #' ',D4         ;ein Space?
                beq.s   s_asc141        ;dann direkt das nächste Zeichen =>
                subq.l  #1,A1           ;Zeiger auf das Zeichen zurück
s_asc14:        moveq   #0,D1           ;keine Anführungszeichen mehr
                bra.s   s_read_loop     ;zum weiteren testen
s_asc15:        move.b  -1(A0),D1       ;Art der Anführungszeichen merken
                bra.s   s_read_loop
s_asc08:        btst    #2,editor3_flag(A4)
                bne.s   s_asc09         ;Tabs stets expandieren
                tst.w   D1              ;in Anführungszeichen ?
                bne.s   s_read_loop     ;ja, dann Tabcode so belassen
s_asc09:        move.b  #' ',-1(A0)
s_asc008:       addq.w  #8,tab_spalte(A4) ;Tab vorrücken
                move.w  tab_spalte(A4),D4
                sub.w   D2,D4
                bls.s   s_asc008
                add.w   D4,D2           ;Spalte erhöhen
                cmp.w   D0,D2
                bhs.s   s_asc11         ;Buffer voll
                subq.w  #2,D4
                bmi.s   s_read_loop
s_asc40:        move.b  #' ',(A0)+      ;D4 Spaces einfügen
                dbra    D4,s_asc40
s_read_loop:    move.b  (A1)+,D4        ;Zeichen in Datenregister
                move.b  D4,(A0)+        ;Zeichen kopieren
                beq     end_of_buffer
                cmp.b   #9,D4           ;Tabulator
                beq.s   s_asc08
                addq.w  #1,D2
                cmp.w   D0,D2
                bhs.s   s_asc11         ;Buffer voll
                cmp.b   D4,D1           ;mit gemerkter Endekennung vergleichen
                beq.s   s_asc14         ;Hochkomma wieder erreicht =>
                cmp.b   #"'",D4
                beq.s   s_asc15         ;ein Hochkomma =>
                cmp.b   #'"',D4
                beq.s   s_asc15
                cmp.b   #10,D4          ;LF = Zeilenende
                beq.s   s_asc11         ;Ja! =>
                cmp.b   #13,D4          ;CR = Zeilenende
                bne.s   s_read_loop     ;Nein! => weiter kopieren
s_asc11:        move.b  #' ',-1(A0)
                clr.b   (A0)+
                lea     zeingabe(A4),A0
                jsr     code_line
                lea     op_buffer(A4),A2
                tst.w   D0
                beq.s   s_no_error
                addq.w  #1,err_count(A4)
                move.w  #';Ø',(A0)      ;Zeile zum Remark machen
                clr.l   (A2)
                move.l  #$FFFF,4(A2)
                move.b  D0,8(A2)        ;Fehlernummer merken
                moveq   #1,D0
s_asc10:        addq.w  #1,D0
                tst.b   0(A0,D0.w)
                bne.s   s_asc10         ;Länge ermitteln
                addq.w  #2,D0
                and.b   #$FE,D0
                move.b  D0,9(A2)        ;Länge eintragen
                move.l  A0,10(A2)       ;Zeiger setzen
s_no_error:     move.l  A1,D7           ;Bufferpointer retten
                tst.b   load_fl(A4)
                bpl     s_merge3        ;Ascii zuladen
                movea.l label_base(A4),A1
                moveq   #0,D0
                move.w  6(A2),D0        ;Index des neuen Labels
                bmi.s   s_asc05
                lsl.l   #5,D0
                ori.b   #$80,4(A1,D0.l) ;Definitionsflag setzen
s_asc05:        move.w  label_top_ind(A4),D0
                cmp.w   block_pointer2(A4),D0
                bhs.s   s_asc21         ;reicht nicht
                moveq   #10,D0
                sub.l   D0,block_pointer+4(A4)
                bmi.s   s_asc21         ;reicht nicht
                move.w  (A2),D0         ;Länge des Opcodes
                sub.l   D0,block_pointer+8(A4)
                bmi.s   s_asc21         ;reicht nicht
                move.l  (A2)+,(A5)+
                move.l  (A2)+,(A5)+     ;Zeileninfo übertragen
                move.w  (A2)+,(A5)+
                movea.l (A2)+,A1        ;Zeiger auf Remark
                lsr.w   #1,D0
                bra.s   s_asc04
s_asc01:        move.w  (A2)+,(A6)+     ;Programmcode übertragen
s_asc04:        dbra    D0,s_asc01
                addq.w  #1,anz_zeilen(A4)
                moveq   #0,D0
                move.b  -1(A5),D0       ;Länge des Remarks
                sub.l   D0,block_pointer(A4)
                bmi.s   s_asc21         ;reicht nicht
                lsr.w   #1,D0
                bra.s   s_asc03
s_asc21:        move.w  #$FFFF,(A5)     ;Endekennung setzen
                lea     outofmem_rsc(PC),A0
                jsr     _form_do        ;'Speicher reicht nicht' ausgeben
                bra     s_fileende
s_asc02:        move.w  (A1)+,(A3)+     ;Remark kopieren
s_asc03:        dbra    D0,s_asc02
                move.w  #$FFFF,(A5)     ;preventiv Enderkennung setzen
                move.l  A5,z_info_top(A4)
                move.l  A6,program_top(A4)
                move.l  A3,comment_top(A4)
                movea.l D7,A1           ;Bufferpointer zurück
                subq.w  #1,zei_count(A4)
                bne.s   s_asc06
                moveq   #0,D1
                move.w  D6,D1
                move.w  #-1,zeile(A4)
                move.w  #2,spalte(A4)
                moveq   #4,D4
                jsr     dezw_out
                jsr     draw_lines
                move.w  #20,zei_count(A4)
                jsr     tastchk
                cmp.l   #$01001B,D0     ;ESC ?
                beq     s_fileende      ;Abbruch
s_asc06:        addq.w  #1,D6           ;Zeilennummer plus 1
s_asc16:        move.b  (A1),D4
                beq.s   s_asc18         ;Ende vom Block =>
                cmpi.b  #10,-1(A1)      ;war die letzte Zeile durch ein LF abgeschlossen?
                beq     s_read_loop2    ;Ja! => weiter
                cmp.b   #10,D4          ;noch ein LF hinter der Zeile (ist normal)
                bne     s_read_loop2    ;Nein => weiter
                addq.l  #1,A1           ;LF ignorieren
                bra     s_read_loop2
s_asc18:        addq.l  #1,A1
                lea     zeingabe+2(A4),A0
end_of_buffer:  subq.l  #1,A0
                cmpa.l  D3,A1
                ble.s   s_fileende
                bsr     s_ascii_read
                move.w  #254,D0         ;Länge des Zeilenbuffers
                bra     s_read_loop
s_asc211:       lea     outofmem_rsc(PC),A0
                jsr     _form_do        ;'Speicher reicht nicht' ausgeben
                bra.s   s_fileende
s_merge3:       move.b  2(A2),D0        ;Opcode der neuen Zeile holen
                btst    #0,D0
                bne.s   s_merge30       ;Nein! =>
                subq.b  #6,D0           ;TEXT, DATA oder BSS eingefügt?
                cmp.b   #4,D0
                bhi.s   s_merge30
                and.w   #$FF,D0
                clr.w   text_pointer(A4,D0.w) ;Pointer löschen (ALT-Key setzt!)
s_merge30:      bsr     insert_line     ;Zeile einfügen
                bne.s   s_asc211        ;Speicher reicht nicht
                bsr     s_ins_line21    ;Marker updaten
                bsr     change_line1
                addq.w  #1,D6
                moveq   #0,D1
                move.b  9(A5),D1
                adda.w  D1,A3
                adda.w  (A5),A6
                lea     10(A5),A5
                movea.l D7,A1           ;Bufferpointer zurück
                subq.w  #1,zei_count(A4)
                bne.s   s_asc16
                jsr     tastchk
                cmp.l   #$01001B,D0     ;ESC ?
                beq.s   s_fileende      ;Abbruch
                move.w  #30,zei_count(A4)
                bra     s_asc16
s_merge4:       move.w  s_spalte(A4),top_line(A4)
                move.w  s_zeile(A4),D6
                bra.s   s_merge5
s_fileende:     jsr     fclose
                moveq   #0,D0
                jsr     _graf_mouse
                tst.b   load_fl(A4)     ;MERGE
                bpl.s   s_merge4        ;ja
                sf      load_fl(A4)
                bsr     s_copy_name
                bsr     s_copy_namec
                moveq   #0,D6
                clr.w   top_line(A4)
s_merge5:       tst.w   D0
                bpl.s   s_asc13
_load_error:    move.l  D0,D1
                moveq   #0,D0
                jsr     _graf_mouse
                sf      load_fl(A4)
s_asc12:        bsr     _load_err_out
s_asc13:        jsr     search_part     ;PART-Tabelle updaten
                tst.w   err_count(A4)   ;fehlerhafte Zeilen ?
                beq     main_loop3      ;nein
                lea     load_rsc_0(PC),A0
                moveq   #0,D1
                move.w  err_count(A4),D1
                moveq   #4,D4
                st      testwrd(A4)
                jsr     dezw_out
                sf      testwrd(A4)
                lea     load_rsc(PC),A0
                jsr     _form_do
                clr.w   err_count(A4)
                bra     main_loop3

s_ascii_read:   lea     dbuffer(A4),A1
                move.l  A1,-(SP)
                pea     2048.w          ;einen 2K-Block einlesen
                move.w  fhandle(A4),-(SP)
                move.w  #$3F,-(SP)      ;Fread
                jsr     do_trap_1
                lea     12(SP),SP
                tst.l   D0
                bmi.s   _load_error2
                clr.b   0(A1,D0.w)      ;Buffer mit einem Nullbyte abschließen
                bsr     s_ascii_inc     ;Blockzähler erhöhen
                rts
_load_error2:   move.l  D0,D1
                moveq   #0,D0
                jsr     _graf_mouse
                sf      load_fl(A4)
                moveq   #0,D6
                clr.w   top_line(A4)
                bra.s   s_asc12

load_rsc:       DC.W 0,0,33,6,1
                DC.W 8,1
                DC.L load_rsc_0
                DC.W 8
                DC.W 8,2
                DC.L load_rsc_1
                DC.W 8
                DC.W 14,4
                DC.L ok_button
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1

                SWITCH sprache
                CASE 0
load_rsc_0:     DC.B '????? Zeilen konnten',0
load_rsc_1:     DC.B 'nicht tokenisiert werden',0
                CASE 1
load_rsc_0:     DC.B '????? lines cannot',0
load_rsc_1:     DC.B 'be tokenized',0
                ENDS
                EVEN

_load_err_out:  lea     load_err_rsc(PC),A1
_load_err_out1: moveq   #0,D0
                jsr     _graf_mouse
                lea     load_err_2(PC),A0 ;Zeiger auf Fehlernummer
                neg.l   D1              ;Fehlernummer ausgeben
                st      testwrd(A4)
                move.l  D4,-(SP)
                moveq   #1,D4
                jsr     dezw_out
                move.l  (SP)+,D4
                sf      testwrd(A4)
                movea.l A1,A0
                jmp     _form_do

_save_err_out:  lea     save_err_rsc(PC),A1
                bra.s   _load_err_out1

_format_error:  moveq   #0,D0
                jsr     _graf_mouse
                lea     illegal_rsc(PC),A0
                jsr     _form_do
                bra     main_loop

illegal_rsc:    DC.W 0,0,31,5,1
                DC.W 8,1
                DC.L illegal_0
                DC.W 8
                DC.W 11,3
                DC.L abbruch_button
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1

load_err_rsc:   DC.W 0,0,29,7,1
                DC.W 8,1
                DC.L load_err_0
                DC.W 8
                DC.W 9,3
                DC.L load_err_1
                DC.W 8
                DC.W 10,5
                DC.L abbruch_button
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1
save_err_rsc:   DC.W 0,0,31,7,1
                DC.W 8,1
                DC.L save_err_0
                DC.W 8
                DC.W 9,3
                DC.L load_err_1
                DC.W 8
                DC.W 10,5
                DC.L abbruch_button
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1

                SWITCH sprache
                CASE 0
illegal_0:      DC.B 'Illegales Fileformat',0
load_err_0:     DC.B 'Fehler beim Laden',0
load_err_1:     DC.B 'TOS-Fehler -'
load_err_2:     DC.B '??',0
save_err_0:     DC.B 'Fehler beim Speichern',0
                CASE 1
illegal_0:      DC.B 'illegal fileformat',0
load_err_0:     DC.B 'load error',0
load_err_1:     DC.B 'TOS-Error -'
load_err_2:     DC.B '??',0
save_err_0:     DC.B 'save error',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Sourcetext als ASCII-File speichern                                  *
************************************************************************
                >PART 's_asci_save\blk'
s_ascii_saveblk:moveq   #1,D0           ;Block sichern
                bra.s   s_ascii_save00
s_ascii_save:   bsr     s_source_da     ;Sourcetext vorhanden?
                beq     main_loop       ;nein
                bsr     s_chk_block     ;'alles' oder 'Block'
s_ascii_save00: move.w  D0,D2           ;Rückgabe merken
                bmi     main_loop       ;UNDO gedrückt
                lea     fname_src(A4),A0 ;Name des Sourcecodes
                lea     fname_temp(A4),A1
s_ascii_save01: move.b  (A0)+,D0        ;Namen kopieren
                move.b  D0,(A1)+
                beq.s   s_ascii_save02
                cmp.b   #'.',D0
                bne.s   s_ascii_save01
s_ascii_save02: subq.l  #1,A1           ;Default-Extension einsetzen
                move.l  spezial_11,D0
                rol.l   #8,D0
                cmp.b   #' ',D0
                beq.s   s_ascii_save04  ;keine Extension
                move.b  #'.',(A1)+
                move.b  D0,(A1)+
s_ascii_save03: rol.l   #8,D0
                cmp.b   #' ',D0
                beq.s   s_ascii_save04
                move.b  D0,(A1)+
                bne.s   s_ascii_save03
s_ascii_save04: clr.b   (A1)+
                lea     spezial_11+4,A1
                moveq   #3,D1
s_ascii_save05: rol.l   #8,D0
                move.b  -(A1),D0
                cmp.b   #' ',D0         ;Defaultextension gespiegelt nach D0
                bne.s   s_ascii_save06
                clr.b   D0
s_ascii_save06: dbra    D1,s_ascii_save05
                lea     fpath_temp(A4),A0
                lea     fname_temp(A4),A1
                lea     s_asc_save(PC),A2 ;Header für Exfsel_input()
                tst.w   D2
                beq.s   s_ascii_save07  ;alles abspeichern
                lea     s_asc_saveb(PC),A2 ;Header für Block
s_ascii_save07: bsr     _fsel_input
                bmi     main_loop
                tst.w   D7              ;ABBRUCH
                beq     main_loop
                lea     fname_temp(A4),A0 ;bei ASCII-Abspeichern keine Sicherheitskopie
                bsr     s_write_file
                bmi     main_loop
                moveq   #1,D0
                jsr     _graf_mouse     ;Hour glass
                clr.w   -(SP)
                pea     fname_temp(A4)
                move.w  #$3C,-(SP)      ;Fcreate
                jsr     do_trap_1
                addq.w  #8,SP
                tst.l   D0
                bmi     _save_error
                move.w  D0,fhandle(A4)
                movem.l D4/D6/A1/A3/A5-A6,-(SP)
                movea.l z_info_base(A4),A5
                movea.l program_base(A4),A6
                movea.l comment_base(A4),A3
                move.w  anz_zeilen(A4),D6
                tst.w   D2
                beq.s   s_ascii_save11  ;alles abspeichern
                move.w  block_end(A4),D0 ;Blockende holen
                addq.w  #1,D0           ;auf $FFFF abtesten
                beq.s   s_ascii_save12  ;ja -> nur Blockanfang gesetzt
                move.w  block_end(A4),D6
s_ascii_save12: sub.w   block_anf(A4),D6 ;Blocklänge
                move.w  block_anf(A4),D0 ;Startzeile
                bsr     calc_pointer
s_ascii_save11: lea     dbuffer(A4),A1
                move.l  A1,D2           ;Vergleichswert Pufferanfang
                lea     1280-160(A1),A2 ;Vergleichswert Pufferende
                bra.s   s_ascii_save2
s_ascii_save1:  moveq   #0,D1
                move.b  9(A5),D1
                adda.w  D1,A3
                adda.w  (A5),A6
                lea     10(A5),A5
s_ascii_save2:  subq.w  #1,D6           ;Anzahl minus 1
                blo.s   s_ascii_save3   ;Ende erreicht
                tst.w   (A5)
                bmi.s   s_ascii_save3   ;Ende des Sourcetextes
                cmpi.w  #$52F0,2(A5)    ;geschützter PART ?
                beq.s   s_ascii_save1   ;ja
                movem.l D0-A6,-(SP)
                pea     zeingabe+2(A4)  ;Buffer setzen
                bsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP           ;Stack korregieren
s_ascii_save4:  cmpi.b  #' ',-(A0)
                beq.s   s_ascii_save4
                clr.b   1(A0)
                movem.l (SP)+,D0-A6
                lea     zeingabe+2(A4),A0
s_write_loop:   move.b  (A0)+,(A1)+
                bne.s   s_write_loop
                move.b  #13,-1(A1)
                move.b  #10,(A1)+
                cmpa.l  A2,A1           ;paßt noch eine Zeile in den Buffer ?
                blt.s   s_ascii_save1
                bsr.s   s_ascii_write
                bra.s   s_ascii_save1
s_ascii_save3:  cmpa.l  D2,A1
                beq.s   s_buffer_empty
                bsr.s   s_ascii_write
s_buffer_empty: movem.l (SP)+,D4/D6/A1/A3/A5-A6
                moveq   #0,D5
                jsr     fclose          ;File schließen
                tst.w   D0
                bmi.s   _save_error
                moveq   #0,D0
                jsr     _graf_mouse
                bra     main_loop
_save_error:    move.l  D0,D1
                bsr     _save_err_out
                clr.b   s_exit_flag(A4)
                bra     main_loop
                SWITCH sprache
                CASE 0
s_asc_save:     DC.B 'ASCII-SOURCE SPEICHERN',0
s_asc_saveb:    DC.B 'ASCII-BLOCK SPEICHERN',0
                CASE 1
s_asc_save:     DC.B 'SAVE ASCII-SOURCE',0
s_asc_saveb:    DC.B 'SAVE ASCII-BLOCK',0
                ENDS
                EVEN

s_ascii_write:  pea     dbuffer(A4)
                move.l  A1,D0           ;Zeiger in Puffer
                sub.l   A4,D0           ;minus BSS Bereich Startadresse
                sub.l   #dbuffer,D0     ;minus Offset
                move.w  D0,D4           ;Anzahl merken
                move.l  D0,-(SP)        ;gleich Anzahl der zu schreibenen Bytes
                move.w  fhandle(A4),-(SP)
                move.w  #$40,-(SP)      ;Fwrite
                jsr     do_trap_1
                lea     12(SP),SP
                tst.l   D0
                bmi.s   _save_error2
                lea     dbuffer(A4),A1
                cmp.l   D4,D0
                blo.s   _disk_full3
                rts
_disk_full3:    movem.l (SP)+,D4/D6/A1/A3/A5-A6
                lea     fname_temp(A4),A1
                bra     _disk_full
_save_error2:   move.w  D0,D1
                addq.w  #4,SP
                move.w  fhandle(A4),-(SP) ;File noch schließen
                move.w  #$3E,-(SP)
                jsr     do_trap_1
                addq.w  #4,SP
                bsr     _save_err_out
                movem.l (SP)+,D4/D6/A1/A3/A5-A6
                bra     main_loop
                ENDPART
************************************************************************
* druckt Sourcetext aus                                                *
************************************************************************
                >PART 's_print\_block'
s_print_block:  moveq   #2,D0           ;Button für Block
                bra.s   s_print00
s_print:        bsr     s_source_da
                beq     main_loop       ;kein Sourcetext
                lea     print_rsc_a(PC),A0
                andi.w  #$FFEF,(A0)     ;Block enablen und default
                andi.w  #$FFFD,-10(A0)  ;alles nicht default
                ori.w   #2,(A0)
                tst.b   block_fl(A4)
                bne.s   s_print01
                ori.w   #$10,(A0)
                andi.w  #$FFFD,(A0)     ;Block disablen und nicht default
                ori.w   #2,-10(A0)
s_print01:      lea     print_rsc(PC),A0
                jsr     _form_do
                tst.w   D0
                bmi     main_loop
                cmp.w   #3,D0
                beq     main_loop       ;Abbruch
s_print00:      jsr     prnstatus
                beq     s_print5        ;Drucker besetzt
                move.w  D0,D1
                moveq   #2,D0           ;Hour glass während des Druckens
                jsr     _graf_mouse
                moveq   #$20,D0         ;Vertical init
                jsr     prn_spezchar
                movem.l D6/A1/A3/A5-A6,-(SP)
                movea.l z_info_base(A4),A5
                movea.l program_base(A4),A6
                movea.l comment_base(A4),A3
                move.w  anz_zeilen(A4),D6
                subq.w  #1,D1
                beq.s   s_print2        ;alles drucken
                move.w  block_end(A4),D0 ;Blockende holen
                addq.w  #1,D0           ;=0, wenn $FFFF
                beq.s   s_print0        ;ja -> nur Blockanfang gesetzt
                move.w  block_end(A4),D6
s_print0:       sub.w   block_anf(A4),D6 ;Blocklänge
                move.w  block_anf(A4),D0 ;Startzeile
                bsr     calc_pointerx   ;Pointer berechnen
                moveq   #0,D0
                bra.s   s_print2
s_print1:       btst    #0,maustast(A4)
                bne.s   s_print3        ;Abbruch durch rechte Maustaste
                moveq   #0,D1
                move.b  9(A5),D1
                adda.w  D1,A3
                adda.w  (A5),A6
                lea     10(A5),A5
s_print2:       subq.w  #1,D6           ;Anzahl minus 1
                blo.s   s_print3        ;Ende erreicht
                tst.w   (A5)
                bmi.s   s_print3        ;Ende des Sourcetextes
                movem.l D0-A6,-(SP)
                pea     zeingabe+2(A4)  ;Buffer setzen
                bsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP           ;Stack korregieren
s_print4:       cmpi.b  #' ',-(A0)
                beq.s   s_print4
                clr.b   1(A0)
                movem.l (SP)+,D0-A6
                moveq   #$1F,D0         ;Horizontal init
                jsr     prn_spezchar    ;(vor der Zeile)
                lea     zeingabe+2(A4),A0
                moveq   #0,D0
s_print_loop:   move.b  (A0)+,D0        ;Zeichen holen
                jsr     prn_char        ;und auf Drucker ausgeben
                tst.b   D0
                bne.s   s_print_loop
                moveq   #1,D0           ;CR/LF senden
                jsr     prn_spezchar    ;(nach einer Zeile)
                cmpi.b  #$52,2(A5)      ;PART-Befehl ?
                bne.s   s_print1        ;nein, nächste Zeile
                tst.b   3(A5)           ;aktiv ?
                bpl.s   s_print1        ;nein, nächste Zeile
                moveq   #0,D1
s_print21:      move.b  9(A5),D1
                adda.w  D1,A3           ;eine Zeile weiter
                adda.w  (A5),A6
                lea     10(A5),A5
                subq.w  #1,D6           ;Anzahl erniedrigen
                cmpi.w  #$5400,2(A5)    ;ENDPART
                bne.s   s_print21       ;nein, nächste Zeile
                bra     s_print1        ;wieder in normale Schleife
s_print3:       moveq   #$21,D0         ;Vertical exit
                jsr     prn_spezchar
                moveq   #0,D0           ;Maus wieder normal
                jsr     _graf_mouse
                movem.l (SP)+,D6/A1/A3/A5-A6
                bra     main_loop
s_print5:       lea     print_rsc2(PC),A0
                jsr     _form_do        ;'Drucker besetzt' Alert ausgeben
                subq.w  #1,D0
                ble     main_loop       ;ABBRUCH
                bra     s_print00       ;NOCHMAL

print_rsc:      DC.W 0,0,27,5,1
                DC.W 4,1
                DC.L print_0
                DC.W 8
                SWITCH sprache
                CASE 0
                DC.W 1,3
                CASE 1
                DC.W 3,3
                ENDS
                DC.L print_1
                DC.W $26
                DC.W 9,3
                DC.L print_2
print_rsc_a:    DC.W $24
                DC.W 17,3
                DC.L abbruch_button
                DC.W $24
                DC.W -1
print_rsc2:     DC.W 0,0,27,5,1
                DC.W 1,1
                DC.L print_4
                DC.W 8
                DC.W 2,3
                DC.L abbruch_button
                DC.W $24
                DC.W 13,3
                DC.L nochmal_button
                DC.W $26
                DC.W -1

                SWITCH sprache
                CASE 0
print_0:        DC.B 'Sourcetext drucken?',0
print_1:        DC.B ' ALLES ',0
print_2:        DC.B ' BLOCK ',0
print_4:        DC.B 'Drucker antwortet nicht',0
nochmal_button: DC.B ' NOCHMAL ',0
                CASE 1
print_0:        DC.B 'Print sourcetext?',0
print_1:        DC.B ' ALL ',0
print_2:        DC.B ' BLOCK ',0
print_4:        DC.B 'Printer do not respond',0
nochmal_button: DC.B ' AGAIN ',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* fragt 'Alles oder Block' <-D0=0-alles,1-Block,-1-Undo                *
************************************************************************
                >PART 's_chk_block'
s_chk_block:    moveq   #0,D0
                tst.b   block_fl(A4)
                beq.s   s_chk_block2
                lea     blockf_rsc(PC),A0
                jsr     _form_do
                subq.w  #1,D0
s_chk_block2:   rts
blockf_rsc:     DC.W 0,0,23,3,1
                DC.W 1,1
                DC.L blockf_0
                DC.W $24
                DC.W 10,1
                DC.L blockf_1
                DC.W 8
                DC.W 15,1
                DC.L blockf_2
                DC.W $26
                DC.W -1
                SWITCH sprache
                CASE 0
blockf_0:       DC.B ' alles ',0
blockf_1:       DC.B 'oder',0
blockf_2:       DC.B ' Block ',0
s_load_txt:     DC.B 'SOURCETEXT LADEN',0
s_sym_txt:      DC.B 'SYMBOLTABELLE LADEN',0
                CASE 1
blockf_0:       DC.B ' all ',0
blockf_1:       DC.B 'or',0
blockf_2:       DC.B ' Block ',0
s_load_txt:     DC.B 'LOAD SOURCETEXT',0
s_sym_txt:      DC.B 'LOAD SYMBOLTABLE',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Sourcetext laden ( mit Überprüfung des Formats )                     *
************************************************************************
                >PART 's_load\sym'
loadwarn_rsc:   DC.W 0,0,25,6,1
                DC.W 1,1
                DC.L loadwarn_txt
                DC.W 8
                DC.W 1,2
                DC.L loadwarn1_txt
                DC.W 8
                DC.W 3,4
                DC.L loadwarn2_txt
                DC.W $26
                SWITCH sprache
                CASE 0
                DC.W 13,4
                CASE 1
                DC.W 14,4
                ENDS
                DC.L abbruch_button
                DC.W $24
                DC.W -1

                SWITCH sprache
                CASE 0
loadwarn_txt:   DC.B 'Der Sourcetext ist noch',0
loadwarn1_txt:  DC.B 'nicht gesichert!',0
loadwarn2_txt:  DC.B ' WEITER ',0
                CASE 1
loadwarn_txt:   DC.B 'The sourcetext has not',0
loadwarn1_txt:  DC.B 'been saved!',0
loadwarn2_txt:  DC.B ' CONTINUE ',0
                ENDS
                EVEN

s_loadsym:      st      s_left_right(A4) ;Symbole laden
                bra.s   s_load0
s_load:         tst.b   change_flag(A4)
                beq.s   s_load0         ;Text wurde nicht geändert
                bsr     s_source_da
                beq.s   s_load0         ;kein Sourcetext vorhanden
                lea     loadwarn_rsc(PC),A0
                jsr     _form_do
                subq.w  #1,D0
                bne     main_loop       ;ABBRUCH
s_load0:        lea     fpath_src(A4),A0 ;Pfadname
                lea     fname_src(A4),A1 ;Filename
                tst.b   s_left_right(A4)
                bmi     s_load_sym      ;rechte Maustaste
                lea     s_load_txt(PC),A2 ;Header für Exfsel_input()
                move.l  #'CRS',D0
                bsr     _fsel_input     ;Fileselektor aufrufen
                bmi     main_loop       ;Fehler beim Laden
                tst.w   D7
                beq     main_loop       ;Abbruch
s_loadx:        moveq   #1,D0
                jsr     _graf_mouse
                clr.w   -(SP)
                pea     fname_src(A4)
                move.w  #$3D,-(SP)      ;OPEN
                jsr     do_trap_1
                addq.w  #8,SP
                move.w  D0,fhandle(A4)
                bmi     _load_error
                pea     dbuffer(A4)     ;Puffer für Disk
                pea     128.w
                move.w  fhandle(A4),-(SP)
                move.w  #$3F,-(SP)      ;Header laden
                jsr     do_trap_1
                lea     12(SP),SP
                tst.l   D0
                bmi     _load_error
                bsr     s_new           ;alles löschen
                lea     dbuffer(A4),A1
                movea.l A1,A0
                move.w  (A0)+,D0        ;Word 0 holen
                moveq   #64-2,D1
s_deco1:        eor.w   D0,(A0)+        ;mit Word 0 decodieren
                ror.w   #1,D0
                dbra    D1,s_deco1
                lea     2(A1),A0
                move.w  (A0)+,D0        ;Word 1 holen
                moveq   #64-3,D1
s_deco2:        eor.w   D0,(A0)+
                rol.w   #1,D0
                dbra    D1,s_deco2
                lea     4(A1),A0
                moveq   #64-3,D1
                moveq   #0,D0
s_deco3:        add.w   (A0)+,D0
                dbra    D1,s_deco3
                sub.w   (A1),D0         ;stimmt die Checksum ?
                bne     s_ascii_load    ;nein, dann ASCII-Laden
                moveq   #0,D0
                jsr     _graf_mouse     ;Pfeil an
                move.l  58(A1),save_date(A4) ;Erstellungsdatum merken
                move.l  92(A1),save_prot(A4)
                move.l  96(A1),save_prot+4(A4)
                lea     load_it_a(PC),A2
                move.l  58(A1),D0       ;Erstellungsdatum
                bsr     set_date
                lea     load_it_b(PC),A2
                move.l  54(A1),D0       ;letzte Änderung
                bsr     set_date
                lea     load_it_c(PC),A0
                move.w  #8,(A0)         ;normalen Baum
                lea     load_it_rsc+6(PC),A2
                move.w  #8,(A2)
                move.l  A0,-(SP)
                lea     no_protect-2(A4),A0
                tst.b   2(A0)
                movem.l (SP)+,A0
                bne.s   s_quell40e      ;Schutz ignorieren
                move.l  92(A1),D0
                or.l    96(A1),D0       ;Passwort vorhanden? 0=NEIN
                bne.s   s_quell40
s_quell40e:     move.w  #-1,(A0)        ;Baum verkürzen
                move.w  #6,(A2)
                moveq   #2,D0           ;max. 2 Sekunden anzeigen
                lea     load_it_rsc(PC),A0
                jsr     object_do
                bra.s   s_quell40a      ;weiter laden, da kein Passwort
s_quell40:      tst.w   92(A1)          ;Seriennummernschutz?
                beq.s   s_quell40d      ;Ja! =>
                lea     passwort_rsc(PC),A0
                movea.l (A0),A0         ;Passwortschutz
                st      (A0)            ;Eingabefeld löschen
                st      passwort_flag(A4) ;Im Dialog nur '*' ausgeben!
                lea     load_it_rsc(PC),A0
                jsr     _form_do
                sf      passwort_flag(A4) ;Dialog wieder normal
                tst.w   D0              ;UNDO bricht ab
                bmi.s   s_quellex
                lea     load_it_rsc_4(PC),A0
                move.l  (A0)+,D0
                cmp.l   92(A1),D0
                bne.s   s_quellex       ;Passwort testen
                move.l  (A0),D0
                cmp.l   96(A1),D0
                beq.s   s_quell40a
s_quellex:      clr.l   save_prot(A4)   ;Password löschen
                clr.l   save_prot+4(A4)
                jsr     fclose
                bra     main_loop       ;zurück in die Hauptschleife
s_quell40d:     move.l  A0,-(SP)
                lea     anfang(PC),A0
                move.l  14(A0),D0       ;Stimmt die Seriennummer?
                movea.l (SP)+,A0
                cmp.l   94(A1),D0
                bne.s   s_quellex       ;NEIN, Ende
                bra.s   s_quell40e      ;Weiter geht's

s_quell40a:     moveq   #1,D0
                jsr     _graf_mouse     ;Disk wieder an
                move.w  8(A1),anz_zeilen(A4)
                move.w  26(A1),label_top_ind(A4)
                moveq   #26,D0
s_quell41:      move.w  28(A1,D0.w),marker(A4,D0.w) ;Marker kopieren
                subq.w  #2,D0
                bpl.s   s_quell41
                move.w  100(A1),optim_flag(A4) ;Flags für Optimierungsdialog
                moveq   #block_end-letzte_zeile,D0
                lea     letzte_zeile(A4),A0
s_quell42:      move.w  62(A1,D0.w),0(A0,D0.w) ;letzte_zeile bis block_end
                subq.w  #2,D0           ;kopieren
                bpl.s   s_quell42
                tst.b   74(A1)          ;wie sind die Tabs abgelegt ?
                beq.s   s_quell421      ;altes Format (3 Words)
                moveq   #4,D0
                lea     tabs+10(A4),A0
s_quell422:     move.b  74(A1,D0.w),-(A0) ;neues Format (5 Bytes)
                subq.l  #1,A0
                dbra    D0,s_quell422
                bra.s   s_quell423
s_quell421:     move.w  74(A1),tabs(A4) ;Befehlstab
                move.w  76(A1),tabs+2(A4) ;Operandentab
                move.w  78(A1),tabs+4(A4) ;Remarktab
                move.w  74(A1),tabs+6(A4) ;Pseudooptab
                move.w  78(A1),tabs+8(A4) ;Remarktab 2
s_quell423:     moveq   #s_suchzeichen-1-hexlen_flag,D0
                lea     hexlen_flag(A4),A0
s_quell43:      move.w  80(A1,D0.w),0(A0,D0.w) ;tabs bis s_suchzeichen kopieren
                subq.w  #2,D0
                bpl.s   s_quell43
                andi.b  #~$10,editor3_flag(A4)
                moveq   #$10,D0
                and.b   110(A1),D0      ;Mac-Mode an?
                or.b    D0,editor3_flag(A4)
                move.b  90(A1),D0
                beq.s   s_quell44
                move.b  D0,start_flag(A4)
s_quell44:      bsr     zswitch1        ;Modus updaten
                bsr     s_check_mem     ;eventuell Autokonfiguration
                lea     dbuffer(A4),A1
                movea.l z_info_base(A4),A0
                move.l  10(A1),D0
                add.l   D0,z_info_top(A4)
                move.l  A0,D1
                add.l   D0,D1
                cmp.l   z_info_max(A4),D1 ;mit max. Größe vergleichen
                bhs     s_quell6        ;paßt nicht
                bsr     s_quell4
                movea.l z_info_top(A4),A0
                move.w  #$FFFF,(A0)
                movea.l program_base(A4),A0
                move.l  14(A1),D0
                add.l   D0,program_top(A4)
                move.l  A0,D1
                add.l   D0,D1
                cmp.l   program_max(A4),D1 ;mit max. Größe vergleichen
                bhs     s_quell6        ;paßt nicht
                bsr     s_quell4        ;Block laden
                movea.l label_base(A4),A0 ;Start der Labeltabelle
                moveq   #0,D0
                move.w  label_top_ind(A4),D0 ;Anzahl der Einträge
                lsl.l   #5,D0           ;mal 32 gleich Länge der Tabelle
                add.l   D0,label_top(A4) ;Endezeiger setzen
                move.l  A0,D1
                add.l   D0,D1
                cmp.l   label_max(A4),D1 ;mit max. Größe vergleichen
                bhs     s_quell6        ;paßt nicht
                cmp.l   18(A1),D0       ;Längen gleich ?
                beq.s   s_quell70       ;dann nicht entcrunchen
                move.l  18(A1),D0       ;Länge der Labeltabelle (gecruncht)
                movea.l label_top(A4),A0 ;Ende der Tabelle
                lea     spaced(A4),A1   ;Buffer
                moveq   #7,D1
s_quell441:     move.l  (A0)+,(A1)+     ;64 Bytes retten
                move.l  (A0)+,(A1)+
                dbra    D1,s_quell441
                movea.l label_top(A4),A0
                move.l  D0,D1
                subq.l  #2,D1           ;2 Byte Endekennung
                sub.l   #60,D1          ;+ 60 Byte Sicherheit
                and.w   #$FFFE,D1       ;Länge begradigen (wegen DMA->schneller)
                suba.l  D1,A0           ;minus gecrunchte Länge->Ladeadresse
                bsr.s   s_quell4        ;Block laden
                movea.l label_base(A4),A1 ;Zieladresse für Entcruncher
                bsr     dcrunch         ;Tabelle entcrunchen
                movea.l label_top(A4),A0
                lea     spaced(A4),A1
                moveq   #7,D0
s_quell442:     move.l  (A1)+,(A0)+     ;64 Bytes zurückholen
                move.l  (A1)+,(A0)+
                dbra    D0,s_quell442
                lea     dbuffer(A4),A1  ;A1 restaurieren
                bra.s   s_quell71
s_quell70:      bsr.s   s_quell4        ;Block laden
s_quell71:      movea.l comment_base(A4),A0 ;Tabelle der Remark
                move.l  22(A1),D0
                add.l   D0,comment_top(A4)
                move.l  A0,D1
                add.l   D0,D1
                cmp.l   comment_max(A4),D1 ;mit max. Größe vergleichen
                bhs.s   s_quell6        ;paßt nicht
                bsr.s   s_quell4        ;Block laden
s_quell7:       moveq   #0,D0
                jsr     _graf_mouse
                move.w  fhandle(A4),-(SP)
                move.w  #$3E,-(SP)      ;Fclose
                jsr     do_trap_1
                addq.w  #4,SP
                bsr     s_copy_name     ;Filename in Kopfzeile
                bsr     s_copy_namec    ;Programmname gleich Sourcetextname
                jsr     search_part     ;PART-Tabelle updaten
                move.w  72(A1),D6       ;ak. Zeile
                bra     main_loop3
s_quell4:       tst.l   D0              ;Laderoutine
                beq.s   s_quell5        ;Länge gleich null
                move.l  A0,-(SP)
                move.l  D0,-(SP)
                move.w  fhandle(A4),-(SP)
                move.w  #$3F,-(SP)
                jsr     do_trap_1
                lea     12(SP),SP
                tst.l   D0
                bmi.s   _load_error4
s_quell5:       rts
_load_error4:   bsr     s_new
                bra     _load_error2
s_quell6:       moveq   #0,D0
                jsr     _graf_mouse
                bsr     s_new
                lea     outofmem_rsc(PC),A0
                jsr     _form_do
                clr.w   72(A1)          ;ak. Zeile gleich null
                bra.s   s_quell7
s_check_mem:    tst.b   autoconfig_flag(A4)
                beq.s   s_check_mem2    ;Autokonfig aus
                move.l  memory_free(A4),D0
                sub.l   106(A1),D0      ;Speicher für GEM
                sub.l   102(A1),D0      ;Speicher für Zielcode
                sub.l   10(A1),D0       ;Länge Zeileninfo
                sub.l   14(A1),D0       ;Länge Programmcode
                sub.l   18(A1),D0       ;Länge Labeltabelle
                sub.l   22(A1),D0       ;Länge der Remarks
                ble.s   s_check_mem2    ;Speicher reicht nicht
                move.l  106(A1),memory_gem(A4) ;Werte übernehmen
                move.l  102(A1),max_code_len(A4)
                move.l  memory_base(A4),-(SP)
                move.w  #$49,-(SP)
                jsr     do_trap_1       ;Mfree
                addq.l  #6,SP
                move.l  memory_free(A4),D3
                sub.l   memory_gem(A4),D3
                move.l  D3,-(SP)        ;Anzahl der Bytes
                move.w  #$48,-(SP)
                jsr     do_trap_1       ;Malloc
                addq.l  #6,SP
                move.l  D0,memory_base(A4)
                bsr     mem_verteilung  ;Speicher für Source aufteilen
s_check_mem2:   rts

set_date:       swap    D0
                move.l  D0,D7           ;Datum merken
                bsr     day_calc_
                move.l  A0,(A2)         ;Wochentag einsetzen
                movea.l 10(A2),A0
                addq.l  #2,A0           ;Hier kommt das Datum hin ...
                moveq   #31,D1
                and.w   D7,D1
                bsr     uhr_out         ;Tag einsetzen
                addq.l  #2,A0
                lsr.w   #5,D7
                moveq   #15,D1
                and.w   D7,D1
                bsr     uhr_out         ;Monat einsetzen
                addq.l  #4,A0
                lsr.w   #4,D7
                moveq   #127,D1
                and.w   D7,D1
                add.w   #80,D1
                bsr     uhr_out         ;Jahr einsetzen
                addq.l  #2,A0
                swap    D7              ;Uhrzeit holen
                lsr.w   #5,D7           ;Sekunden ignorieren
                moveq   #63,D0
                and.w   D7,D0           ;Minuten isolieren
                lsr.w   #6,D7
                moveq   #31,D1
                and.w   D7,D1
                bsr     uhr_out         ;Stunden einsetzen
                addq.l  #2,A0
                moveq   #0,D1
                move.w  D0,D1
                bra     uhr_out         ;Minuten einsetzen

load_it_rsc:    DC.W 0,0,48,8,1
                DC.W 17,1
                DC.L load_it_rsc_0
                DC.W $08
                DC.W 1,3
                DC.L load_it_rsc_1
                DC.W $08
                DC.W 19,3
load_it_a:      DC.L 0
                DC.W $08
                DC.W 29,3
                DC.L load_it_rsc_6
                DC.W $08
                DC.W 1,4
                DC.L load_it_rsc_2
                DC.W $08
                DC.W 19,4
load_it_b:      DC.L 0
                DC.W $08
                DC.W 29,4
                DC.L load_it_rsc_8
                DC.W $08
load_it_c:      DC.W 8,6
                DC.L load_it_rsc_3
                DC.W $08
                DC.W 32,6
passwort_rsc:   DC.L load_it_rsc_4
                DC.W $88
                DC.W -1

                SWITCH sprache
                CASE 0
load_it_rsc_0:  DC.B 'Lade Sourcecode',0
load_it_rsc_1:  DC.B 'Erstellungsdatum:',0
load_it_rsc_6:  DC.B ', 31.12.1988 12:00',0
load_it_rsc_2:  DC.B 'letzte Änderung :',0
load_it_rsc_8:  DC.B ', 31.12.1988 12:00',0
load_it_rsc_3:  DC.B 'Bitte Passwort eingeben:',0
                CASE 1
load_it_rsc_0:  DC.B 'Loading sourcecode',0
load_it_rsc_1:  DC.B 'creationdate:',0
load_it_rsc_6:  DC.B ', 31.12.1988 12:00',0
load_it_rsc_2:  DC.B 'last change :',0
load_it_rsc_8:  DC.B ', 31.12.1988 12:00',0
load_it_rsc_3:  DC.B 'Please enter password:',0
                ENDS
                EVEN
load_it_rsc_4:  DC.B '01234567',0
                EVEN
                ENDPART
************************************************************************
*A0=ab hier wird entcruncht                                            *
*A1=nach hier wird entcruncht                                          *
************************************************************************
                >PART 'dcrunch'
dcrunch:        move.b  (A0)+,D0        ;erstes Byte holen
                beq.s   dfound          ;entcrunchen =>
                move.b  D0,(A1)+        ;direkt übernehmen
                bra.s   dcrunch         ;weiter geht's
dfound:         moveq   #0,D0           ;für DBRA löschen (da Word)
                move.b  (A0)+,D0        ;Anzahl der Nullbytes-1 holen
                bmi.s   dende           ;<0 => Endekennung
dloop2:         clr.b   (A1)+           ;Bereich löschen
                dbra    D0,dloop2       ;schon alle Nullbytes?
                bra.s   dcrunch         ;weiter entcrunchen
dende:          rts                     ;das war's
                ENDPART
************************************************************************
*A0=ab hier wird gecruncht                                             *
*A1=nach hier wird gecruncht                                           *
*A2=letzte Adr+1                                                       *
************************************************************************
                >PART 'crunch'
crunch:         move.b  (A0)+,D0        ;Zeichen zum Crunchen holen
                beq.s   cfound          ;Nullbyte? => kann evtl. gecruncht werden
cjump:          move.b  D0,(A1)+        ;Zeichen direkt übernehmen
                cmpa.l  A2,A0           ;Ende erreicht?
                blo.s   crunch          ;Nein! => weiter geht's
cende2:         clr.b   (A1)+           ;Endekennung setzen:
                st      (A1)+           ;Nullbyte mit negativem Folgebyte
                rts                     ;das war's
cfound:         moveq   #-1,D1          ;Anzahl-2
cloop2:         addq.w  #1,D1           ;und wieder ein Nullbyte mehr
                cmpa.l  A2,A0           ;Ende erreicht?
                beq.s   cjump2          ;dann machen wir Schluß
                move.b  (A0)+,D0        ;das nächste Zeichen holen
                beq.s   cloop2          ;bei Nullbyte weitersuchen
                clr.b   (A1)+           ;Nullbyte als Header
                move.b  D1,(A1)+        ;Anzahl der Nullbytes-1
                bra.s   cjump           ;Folgezeichen<>0 einsetzen
cjump2:         clr.b   (A1)+           ;s.o.
                move.b  D1,(A1)+        ;aber nur für den Fall, daß das Ende naht
                bra.s   cende2          ;game over
                ENDPART
************************************************************************
*A0=ab hier wird gecruncht                                             *
*A1=nach hier wird gecruncht                                           *
*A2=letzte Adr+1                                                       *
************************************************************************
                >PART 'test_crunch'
test_crunch:    tst.b   (A0)+           ;Zeichen zum Crunchen holen
                beq.s   test_cloop2     ;Nullbyte? => kann evtl. gecruncht werden
                addq.l  #1,A1           ;Zeichen direkt übernehmen
test_cjump1:    cmpa.l  A2,A0           ;Ende erreicht?
                blo.s   test_crunch     ;Nein! => weiter geht's
test_cende:     lea     128(A1),A1      ;Sicherheitsbuffer
                rts                     ;das war's
test_cloop2:    cmpa.l  A2,A0           ;Ende erreicht?
                beq.s   test_cende      ;dann machen wir Schluß
                tst.b   (A0)+           ;das nächste Zeichen holen
                beq.s   test_cloop2     ;bei Nullbyte weitersuchen
                addq.l  #3,A1
                bra.s   test_cjump1     ;Folgezeichen<>0 einsetzen
                ENDPART
************************************************************************
* lädt eine Symboltabelle nach                                         *
************************************************************************
                >PART 's_load_sym'
s_load_sym:     move.l  #'MYS',D0       ;.SYM
                lea     fpath_temp(A4),A0
                lea     fname_temp(A4),A1
s_load_sym01:   move.b  (A1)+,D0
                beq.s   s_load_sym02    ;keine Extension
                cmp.b   #'.',D0
                bne.s   s_load_sym01
s_load_sym02:   move.b  #'.',-1(A1)
                move.b  #'S',(A1)+      ;Extension SYM anhängen
                move.b  #'Y',(A1)+
                move.b  #'M',(A1)+
                clr.b   (A1)
                lea     fname_temp(A4),A1
                move.l  #'MYS',D0       ;.SYM
                lea     s_sym_txt(PC),A2 ;Header für Exfsel_input()
                bsr     _fsel_input     ;Fileselektor aufrufen
                bmi     main_loop       ;Fehler beim Laden
                cmp.w   #0,D7
                beq     main_loop       ;Abbruch
                lea     fname_temp(A4),A0 ;Zeiger auf Filename
                bsr.s   s_load_sym0     ;File laden und Symbole updaten
                tst.w   D0              ;Fehlercode
                bmi     _load_error     ;Ladefehler
                bne     _format_error   ;illegales Format
                bsr     redraw_all
                bra     main_loop

s_load_sym0:    movem.l D1-D5/A1-A2,-(SP) ;SYM-File laden und Symbole updaten
                moveq   #1,D0
                jsr     _graf_mouse
                clr.w   -(SP)
                move.l  A0,-(SP)        ;Filename
                move.w  #$3D,-(SP)      ;OPEN
                jsr     do_trap_1
                addq.w  #8,SP
                move.w  D0,fhandle(A4)
                bmi.s   s_load_sym71    ;Fehler
                pea     dbuffer(A4)     ;Puffer für Disk
                pea     4.w
                move.w  fhandle(A4),-(SP)
                move.w  #$3F,-(SP)      ;Header laden
                jsr     do_trap_1
                lea     12(SP),SP
                tst.l   D0
                bmi.s   s_load_sym71    ;Fehler
                lea     dbuffer(A4),A1
                moveq   #1,D0
                cmpi.l  #'∑SYM',(A1)
                bne.s   s_load_sym71    ;illegales Format
                move.w  label_top_ind(A4),D2
                movea.l label_base(A4),A2
s_load_sym8:    pea     dbuffer(A4)     ;Puffer für Disk
                pea     2048.w
                move.w  fhandle(A4),-(SP)
                move.w  #$3F,-(SP)      ;2k laden
                jsr     do_trap_1
                lea     12(SP),SP
                tst.l   D0
                bmi.s   s_load_sym71    ;Ladefehler
                lsr.l   #5,D0           ;Anzahl der geladenen Einträge
                beq.s   s_load_sym7
                lea     dbuffer+8(A4),A1
s_load_sym6:    move.l  (A1),D5
                lea     8(A2),A0        ;Zeiger auf Symboltabelle
                move.w  D2,D1
                bra.s   s_load_sym4

s_load_sym7:    move.w  D2,label_top_ind(A4)
                moveq   #0,D0
s_load_sym71:   move.w  D0,-(SP)        ;Status retten
                jsr     fclose          ;File schließen
                moveq   #0,D0
                jsr     _graf_mouse     ;Maus wieder Pfeil
                move.w  (SP)+,D0        ;Status zurück
                movem.l (SP)+,D1-D5/A1-A2
                rts

s_load_sym2:    cmp.l   (A0),D5
                beq.s   s_load_sym3
s_load_sym21:   lea     32(A0),A0
s_load_sym4:    dbra    D1,s_load_sym2
                move.l  D5,(A0)
                move.l  -4(A1),-4(A0)
                move.l  -8(A1),-8(A0)
                move.l  4(A1),4(A0)     ;Symbol an die Tabelle anhängen
                move.l  8(A1),8(A0)
                move.l  12(A1),12(A0)
                move.l  16(A1),16(A0)
                move.l  20(A1),20(A0)
                move.b  #$FD,-3(A0)     ;Sonderkennung für geladenes Symbol
                addq.w  #1,D2
                moveq   #32,D3
                add.l   D3,label_top(A4)
                bra.s   s_load_sym5

s_load_sym3:    moveq   #23,D4
s_load_sym31:   subq.w  #3,D4
                move.l  0(A1,D4.w),D3
                cmp.l   0(A0,D4.w),D3   ;Namen vergleichen
                dbne    D4,s_load_sym31
                bne.s   s_load_sym21    ;ungleich
                tst.b   -4(A0)          ;schon definiert
                bpl.s   s_load_sym55    ;nein, dann übernehmen
                move.b  -3(A1),D3
                cmp.b   -3(A0),D3       ;Typ gleich ?
                bne.s   s_load_sym5     ;nein, dann nicht übernehmen
                move.l  -8(A1),-8(A0)
                move.b  -4(A1),-4(A0)
s_load_sym5:    lea     32(A1),A1
                subq.w  #1,D0
                bne     s_load_sym6
                bra     s_load_sym8
s_load_sym55:   move.l  -8(A1),-8(A0)
                move.b  -4(A1),-4(A0)
                move.b  #$FD,-3(A0)
                bra.s   s_load_sym5
                ENDPART
************************************************************************
* kopiert ak. Filenamen in die Kopfzeile                               *
************************************************************************
                >PART 's_copy_name'
s_copy_name:    movem.l D0/A0-A1,-(SP)
                lea     _e0,A0
                lea     fpath_src(A4),A1
s_copy_name2:   tst.b   (A0)
                beq.s   s_copy_name3
                move.b  (A1)+,(A0)+
                bne.s   s_copy_name2
                st      -1(A0)
s_copy_name1:   tst.b   -1(A0)
                beq.s   s_copy_name6
                cmpi.b  #'\',-(A0)
                bne.s   s_copy_name1
                addq.l  #1,A0
s_copy_name6:   lea     fname_src(A4),A1
s_copy_name4:   tst.b   (A0)
                beq.s   s_copy_name3
                move.b  (A1)+,(A0)+
                bne.s   s_copy_name4
                st      -(A0)
s_copy_name5:   tst.b   (A0)
                beq.s   s_copy_name3
                move.b  #' ',(A0)+
                bra.s   s_copy_name5
s_copy_name3:   movem.l (SP)+,D0/A0-A1
                rts

s_copy_namec:   movem.l D0/A0-A1,-(SP)
                lea     fname_src(A4),A0
                lea     fname_code(A4),A1 ;Zielcodename gleich
s_copy_namec1:  move.b  (A0)+,D0        ;Sourcetextname
                move.b  D0,(A1)+
                beq.s   s_copy_namec2
                cmp.b   #'.',D0
                bne.s   s_copy_namec1
                move.b  #'P',(A1)+
                move.b  #'R',(A1)+
                move.b  #'G',(A1)+
                clr.b   (A1)+
s_copy_namec2:  movem.l (SP)+,D0/A0-A1
                rts
                ENDPART
************************************************************************
* Sourcetext als .SRC-File speichern                                   *
************************************************************************
                >PART 's_source_da'
s_source_da:    tst.w   anz_zeilen(A4)
                beq.s   s_source_da1    ;kein Quelltext vorhanden
                movea.l z_info_base(A4),A0
s_source_da3:   tst.l   (A0)+
                bmi.s   s_source_da2    ;Source enthält nur Leerzeilen
                bne.s   s_source_da1    ;Test auf Leerzeile
                cmpi.l  #$FFFF,(A0)+
                bne.s   s_source_da1    ;keine Leerzeile
                tst.w   (A0)+
                beq.s   s_source_da3    ;Leerzeile
s_source_da1:   rts
s_source_da2:   move    #4,CCR          ;Zero-Flag
                rts
                ENDPART
                >PART 's_quell_save2'
s_quell_save2:  bsr.s   s_source_da
                beq     main_loop       ;kein Quelltext da
                jsr     garbage_collection
                movem.l D0-D3/A0-A1,-(SP)
                moveq   #1,D0
                jsr     _graf_mouse
                jsr     do_mediach      ;Media-Change wenn nötig
                move.l  SP,D2
                lea     fpath_src(A4),A0
                moveq   #0,D0
                move.b  (A0),D0
                subi.w  #'A',D0
                move.w  D0,-(SP)
                move.w  #$0E,-(SP)
                jsr     do_trap_1       ;Dsetdrv
                addq.l  #4,SP
                movea.l A0,A1
s_quellx1:      tst.b   (A1)+
                bne.s   s_quellx1       ;Ende des Pfads suchen
                subq.l  #1,A1
s_quellx2:      move.b  -(A1),D1
                cmp.b   #'\',D1
                bne.s   s_quellx2
                cmpi.b  #':',-1(A1)
                bne.s   s_quellx3
                addq.l  #1,A1
                move.b  (A1),D1
s_quellx3:      clr.b   (A1)
                pea     fpath_src+2(A4)
                move.w  #$3B,-(SP)
                jsr     do_trap_1       ;Dsetpath
                addq.l  #6,SP
                move.b  D1,(A1)         ;Pfad wiederherstellen
                lea     fname_src(A4),A1 ;Zeiger auf Filename
s_quellx5:      move.b  (A1)+,D0
                beq.s   s_quellx6
                cmp.b   #'.',D0         ;Extension suchen
                bne.s   s_quellx5
s_quellx6:      subq.l  #1,A1
                move.b  #'.',(A1)+
                move.b  #'S',(A1)+      ;Extension in .SRC ändern
                move.b  #'R',(A1)+
                move.b  #'C',(A1)+
                clr.b   (A1)+
                bra.s   s_quellx4
s_save:         bsr     s_source_da
                beq     main_loop
                jsr     garbage_collection
                tst.b   s_left_right(A4)
                bne     s_quell_save2   ;rechte Maustaste
                movem.l D0-D3/A0-A1,-(SP)
                moveq   #1,D0
                jsr     _graf_mouse
                move.l  SP,D2
                lea     fpath_src(A4),A0
                lea     fname_src(A4),A1
s_quell01:      move.b  (A1)+,D0
                beq.s   s_quell02
                cmp.b   #'.',D0
                bne.s   s_quell01
s_quell02:      subq.l  #1,A1           ;Extension in .SRC ändern
                move.b  #'.',(A1)+
                move.b  #'S',(A1)+
                move.b  #'R',(A1)+
                move.b  #'C',(A1)+
                clr.b   (A1)
                lea     fname_src(A4),A1
                lea     s_save_txt(PC),A2 ;Header für Exfsel_input()
                move.l  #'CRS',D0       ;.SRC
                bsr     _fsel_input
                bmi     s_quell23
                tst.w   D7
                beq     s_quell23
                bsr     s_copy_namec    ;Programmname gleich Sourcetextname
s_quellx4:      move.b  #1,maustast_flag(A4)
                lea     fname_src(A4),A0
                tst.b   bak_flag(A4)
                bne.s   s_quell3
                bsr     s_rename_file
s_quell3:       bsr     s_write_file
                bmi     s_quell23
                moveq   #1,D0
                jsr     _graf_mouse
                bsr     s_copy_name
                clr.w   -(SP)
                pea     fname_src(A4)
                move.w  #$3C,-(SP)      ;CREATE
                jsr     do_trap_1
                addq.w  #8,SP
                move.w  D0,fhandle(A4)
                bmi     _save_error3
                lea     dbuffer+128(A4),A1
                moveq   #31,D0
s_quell1:       clr.l   -(A1)           ;128 Bytes löschen
                dbra    D0,s_quell1
                bsr     s_set_date      ;Datum in Header schreiben
                move.w  #version,4(A1)  ;Versionsnummer
                move.w  anz_zeilen(A4),8(A1) ;Anzahl der Zeilen
                move.w  D6,72(A1)       ;ak. Zeile
                move.b  debugger_da(A4),91(A1) ;merken, ob Debugger vorhanden
                moveq   #24,D0
s_quell11:      move.w  marker(A4,D0.w),28(A1,D0.w) ;Marker kopieren
                subq.w  #2,D0
                bpl.s   s_quell11
                move.w  optim_flag(A4),100(A1) ;Flags für Optimierungsdialog
                moveq   #block_end-letzte_zeile,D0
                lea     letzte_zeile(A4),A0
s_quell12:      move.w  0(A0,D0.w),62(A1,D0.w) ;letzte_zeile bis block_end
                subq.w  #2,D0           ;kopieren
                bpl.s   s_quell12
                moveq   #4,D0
                lea     tabs+10(A4),A0
s_quell121:     move.b  -(A0),74(A1,D0.w) ;Tabulatoren kopieren
                subq.l  #1,A0
                dbra    D0,s_quell121
                moveq   #s_suchzeichen-1-hexlen_flag,D0
                lea     hexlen_flag(A4),A0
s_quell13:      move.w  0(A0,D0.w),80(A1,D0.w) ;hexlen_flag bis s_suchzeichen kopieren
                subq.w  #2,D0
                bpl.s   s_quell13
                move.l  max_code_len(A4),102(A1) ;Zielcodelänge
                move.l  memory_gem(A4),106(A1) ;Speicher für GEM
                moveq   #$10,D0
                and.b   editor3_flag(A4),D0
                sne     D0
                move.b  D0,110(A1)      ;Mac-Flag in den Header
                move.l  comment_top(A4),D0
                sub.l   comment_base(A4),D0
                move.l  D0,22(A1)       ;Länge Remarks
                move.l  comment_base(A4),-(SP)
                move.l  D0,-(SP)
                bsr     s_clr_values    ;Labelwerte löschen
                move.l  label_top(A4),D0
                sub.l   label_base(A4),D0 ;Länge der Labeltabelle berechnen
                beq.s   s_quell131      ;keine Labeltabelle!
                movem.l D1/A0-A2,-(SP)
                movea.l label_base(A4),A1 ;Zieladresse für Cruncher
                movea.l A1,A0           ;Startadresse für Cruncher
                movea.l label_top(A4),A2 ;Endadresse
                bsr     test_crunch     ;Tabelle testcrunchen
                cmpa.l  A2,A1           ;Überlauf?
                bhs.s   s_quell130      ;dann nichts tun
                movea.l label_top(A4),A0
                lea     -64(A0),A0
                lea     spaced(A4),A1
                moveq   #15,D1
s_quell132:     move.l  (A0)+,(A1)+     ;letzten 64 Bytes retten
                dbra    D1,s_quell132
                lea     -64(A0),A1
                lsr.l   #4,D0           ;Länge durch 16
                subq.w  #4,D0           ;minus 4*16=64 Bytes
s_quell133:     move.l  -(A1),-(A0)
                move.l  -(A1),-(A0)
                move.l  -(A1),-(A0)     ;Tabelle um 64 Bytes nach oben kopieren
                move.l  -(A1),-(A0)
                dbra    D0,s_quell133
                movea.l label_base(A4),A1 ;Zieladresse für Cruncher
                lea     64(A1),A0       ;Startadresse für Cruncher
                movea.l label_top(A4),A2 ;Endadresse
                bsr     crunch          ;Tabelle crunchen
                subq.l  #2,A1           ;Endekennung des Crunchers löschen
                lea     spaced(A4),A0   ;restliche 64 Bytes
                lea     64(A0),A2
                bsr     crunch          ;durch den Cruncher jagen
                move.l  A1,D0           ;Endadresse des gecrunchten Codes
                sub.l   label_base(A4),D0 ;Länge berechnen
                move.l  D0,crunch_len(A4) ;und merken
s_quell130:     movem.l (SP)+,D1/A0-A2
s_quell131:     move.l  D0,18(A1)       ;Länge Labeltabelle
                move.l  label_base(A4),-(SP)
                move.l  D0,-(SP)
                move.l  program_top(A4),D0
                sub.l   program_base(A4),D0
                move.l  D0,14(A1)       ;Länge Programmcode
                move.l  program_base(A4),-(SP)
                move.l  D0,-(SP)
                move.l  z_info_top(A4),D0
                sub.l   z_info_base(A4),D0
                move.l  D0,10(A1)       ;Länge Zeileninfo
                move.l  z_info_base(A4),-(SP)
                move.l  D0,-(SP)
                move.w  label_top_ind(A4),26(A1)
                move.l  save_prot(A4),92(A1) ;Passwort übertragen
                move.l  save_prot+4(A4),96(A1)
                move.b  start_flag(A4),90(A1)

                lea     4(A1),A0
                moveq   #0,D0
                moveq   #64-3,D1
s_code1:        add.w   (A0)+,D0
                dbra    D1,s_code1
                movea.l A1,A0
                move.w  D0,(A0)+        ;Checksum in D0 nach Word 0
                move.b  $FFFF8207.w,(A0)+ ;Video Adresszähler Midbyte
                move.b  $FFFF8209.w,(A0)+ ;Video Adresszähler Lowbyte ->Word 1
                move.w  -2(A0),D0
                moveq   #64-3,D1
s_code2:        eor.w   D0,(A0)+        ;mit Word 1 codieren
                rol.w   #1,D0
                dbra    D1,s_code2
                movea.l A1,A0
                move.w  (A0)+,D0
                moveq   #64-2,D1
s_code3:        eor.w   D0,(A0)+        ;mit Word 0 codieren
                ror.w   #1,D0
                dbra    D1,s_code3

                pea     dbuffer(A4)
                pea     128.w           ;128 Bytes
                move.w  fhandle(A4),-(SP)
                move.w  #$40,-(SP)
                jsr     do_trap_1       ;Header schreiben
                lea     12(SP),SP
                tst.l   D0
                bmi     _save_error
                lea     fname_src(A4),A1
                moveq   #127,D1
                cmp.l   D1,D0
                ble     _disk_full
                moveq   #3,D1
s_quell2:       move.w  fhandle(A4),-(SP)
                move.w  #$40,-(SP)      ;Fwrite
                moveq   #0,D0
                move.l  4(SP),D3
                beq.s   s_quell22
                jsr     do_trap_1       ;die 4 Bereiche speichern
s_quell22:      lea     12(SP),SP
                tst.l   D0
                bmi.s   _save_error3
                cmp.l   D3,D0
                blo.s   _disk_fulls
                dbra    D1,s_quell2
                jsr     fclose          ;File schließen
                tst.w   D0
                bmi.s   _save_error3
                sf      change_flag(A4)
                bra.s   s_quell24
s_quell23:      clr.b   s_exit_flag(A4)
s_quell24:      moveq   #0,D0
                jsr     _graf_mouse
                movea.l D2,SP
                movem.l (SP)+,D0-D3/A0-A1
                bsr     s_restore       ;Labeltabelle wieder entcrunchen
                tst.b   s_exit_flag(A4)
                beq     main_loop       ;kein Ende
                tst.b   maustast_flag(A4)
                bgt     do_quit         ;Programmende
                clr.b   s_exit_flag(A4)
                sf      maustast_flag(A4)
                bra     main_loop
_save_error3:   move.l  D0,dta_buffer(A4) ;Fehlernummer merken
                jsr     fclose          ;File schließen
                movea.l D2,SP
                movem.l (SP)+,D0-D3/A0-A1
                bsr.s   s_restore
                move.l  dta_buffer(A4),D0 ;Fehlernummer zurück
                bra     _save_error
_disk_fulls:    movea.l D2,SP
                movem.l (SP)+,D0-D3/A0-A1
                bsr.s   s_restore       ;Labeltabelle wieder entcrunchen
                lea     fname_src(A4),A1
_disk_full:     moveq   #0,D0
                jsr     _graf_mouse
                lea     disk_full_rsc(PC),A0
                jsr     _form_do
                jsr     fclose
                move.l  A1,-(SP)
                move.w  #$41,-(SP)      ;Fdelete
                jsr     do_trap_1
                addq.l  #6,SP
                moveq   #0,D6
                move.w  D6,D0
                bsr     calc_pointer
                clr.w   top_line(A4)    ;alles auf Zeile 0
                movem.l A3/A5-A6,top_ptr(A4)
                clr.w   scr_z(A4)
                clr.b   s_exit_flag(A4)
                bsr     redraw_all
                bra     main_loop
_disk_fulla:    movem.l (SP)+,D1-A6     ;Disk full für s_assemble
                lea     fname_code(A4),A1
                bra.s   _disk_full
                ENDPART
                >PART 's_restore' ;Labeltabelle wieder entcrunchen
s_restore:      tst.l   crunch_len(A4)
                beq.s   s_restore3      ;nicht nötig! =>
                movem.l D0-D1/A0-A2,-(SP)
                move.l  crunch_len(A4),D0
                movea.l label_base(A4),A0
                addq.l  #1,D0
                and.b   #$FE,D0         ;Länge für MOVE.L begradigen
                adda.l  D0,A0
                move.l  D0,D1           ;Länge merken
                movea.l label_top(A4),A1
                lea     spaced(A4),A2
                move.l  (A1)+,(A2)+     ;Sicherheitsbereich erhöhen
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)+
                move.l  (A1)+,(A2)
                lsr.l   #2,D0           ;durch 4
                bra.s   s_restore2
s_restore1:     swap    D0
s_restore2:     move.l  -(A0),-(A1)     ;gecrunchten Code hochkopieren
                dbra    D0,s_restore2
                swap    D0
                dbra    D0,s_restore1
                movea.l label_top(A4),A0
                addq.l  #8,A0           ;wegen Sicherheitsbereich
                addq.l  #8,A0
                suba.l  D1,A0           ;Start für Entcruncher
                movea.l label_base(A4),A1 ;Ziel für Entcruncher
                bsr     dcrunch         ;entcrunchen
                movea.l label_top(A4),A0
                lea     spaced(A4),A2
                move.l  (A2)+,(A0)+     ;Werte zurückholen
                move.l  (A2)+,(A0)+
                move.l  (A2)+,(A0)+
                move.l  (A2),(A0)
                clr.l   crunch_len(A4)  ;Damit später nicht mehr entcrunched wird
                movem.l (SP)+,D0-D1/A0-A2
s_restore3:     rts
                ENDPART
                >PART 's_clr_values'
s_clr_values:   movem.l D0/A0,-(SP)     ;Labelwerte löschen
                movea.l label_base(A4),A0
                subq.l  #1,A0
                move.w  label_top_ind(A4),D0 ;Anzahl
s_clr_val1:     subq.w  #1,D0
                bmi.s   s_clr_val2      ;Ende der Tabelle
                lea     32(A0),A0
                tst.b   (A0)            ;Eintragsstatus testen
                bne.s   s_clr_val1      ;kein Symbol
                tst.b   5-31(A0)        ;Typflag
                bne.s   s_clr_val1      ;kein Label
                clr.l   -31(A0)         ;Labelwert löschen
                bra.s   s_clr_val1
s_clr_val2:     movem.l (SP)+,D0/A0
                rts
                ENDPART
                >PART 'Save-RSC'
disk_full_rsc:  DC.W 0,0,33,5,1
                DC.W 8,1
                DC.L disk_ful_0
                DC.W 8
                DC.W 10,3
                DC.L abbruch_button
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1
                SWITCH sprache
                CASE 0
disk_ful_0:     DC.B 'Die Diskette ist voll!',0
s_save_txt:     DC.B 'SOURCETEXT SPEICHERN',0
                CASE 1
disk_ful_0:     DC.B 'The disk is full!',0
s_save_txt:     DC.B 'SAVE SOURCETEXT',0
                ENDS
                EVEN
                ENDPART
                >PART 's_set_date'
s_set_date:     move.l  D2,-(SP)
                move.w  #$2A,-(SP)
                jsr     do_trap_1       ;Tgetdate
                addq.l  #2,SP
                move.w  D0,D2
                swap    D2
                move.w  #$2C,-(SP)
                jsr     do_trap_1       ;Tgettime
                addq.l  #2,SP
                move.w  D0,D2
                move.l  D2,54(A1)       ;letzte Änderung
                move.l  save_date(A4),58(A1) ;Erstellungsdatum ist korrekt?
                bne.s   s_set_date2     ;Ja! =>
                move.l  D2,58(A1)       ;Erstellungsdatum = Heute
s_set_date2:    move.l  (SP)+,D2
                rts
                ENDPART
                >PART 'tmarker'
tmarker:        andi.w  #$FF,D0
                add.w   D0,D0
                btst    #26,D0
                bne.s   tmarke2         ;Control gedrückt
                cmp.w   #18,D0
                bhi.s   tmarke5
tmarke9:        move.w  marker(A4,D0.w),D0
                cmp.w   #$FFFF,D0
                beq     main_loop       ;Marker nicht gesetzt
                cmp.w   anz_zeilen(A4),D0
                bhi.s   tmarke3         ;Marker löschen
                move.w  D0,D6
                bsr     jump_line
                bra     main_loop
tmarke2:        cmp.w   #18,D0
                bhi     main_loop       ;TEXT,DATA,BSS dürfen nicht gesetzt werden
                btst    #24,D0
                bne.s   tmarke3         ;SHIFT
                move.w  D6,marker(A4,D0.w)
                bra     main_loop       ;Marker setzen
tmarke3:        move.w  #-1,marker(A4,D0.w) ;Marker löschen
                bra     main_loop
tmarke5:        movea.l z_info_base(A4),A0
                move.w  tmarke4-20(PC,D0.w),D1
                moveq   #0,D2
                bra.s   tmarke6
tmarke8:        addq.l  #8,A0           ;eine Zeile weiter
                addq.w  #1,D2
tmarke6:        tst.w   (A0)+           ;letzte Zeile?
                bmi.s   tmarke3         ;ja
                cmp.b   (A0),D1         ;Opcode testen
                bne.s   tmarke8         ;ungleich
                move.w  D2,marker(A4,D0.w)
                bra.s   tmarke9
tmarke4:        DC.W 6,8,10
                ENDPART
                >PART 'fun_keys'
fun_keys:       lsl.w   #2,D0
                lea     f_jumpsa(PC),A0 ;Zeiger auf Tabelle
                movea.l 0(A0,D0.w),A0   ;Sprungadresse holen
                jmp     (A0)
                ENDPART
                >PART 'check_hclock'
********************************************************************************
* Testen, ob die Hardwareuhr des Mega-ST vorhanden ist (C=0, wenn ja)          *
********************************************************************************
check_hclock:   move.l  8.w,D2          ;Busfehler-Vektor retten
                movea.l SP,A2           ;den Stackpointer retten
                lea     check_hclock1(PC),A0
                move.l  A0,8.w
                lea     $FFFFFC20.w,A0  ;Adresse der Hardwareuhr
                move.b  $1B(A0),D1      ;Uhrenchip ansprechen
                bset    #0,D1           ;Bank 1 anwählen
                move.b  D1,$1B(A0)      ;Bankregister wieder schreiben
                move.l  D2,8.w          ;Busfehler-Vektor wieder zurücksetzen
                movep.w $05(A0),D2      ;Alarmzeit Minuten auslesen
                move.w  #$0A05,D0
                movep.w D0,$05(A0)      ;Wert in obiges Register schreiben
                movep.w $05(A0),D0      ;und sofort wieder auslesen
                movep.w D2,$05(A0)      ;Alarmzeit Minuten wieder setzen
                and.w   #$0F0F,D0       ;überflüssige Bits ausmaskieren
                cmp.w   #$0A05,D0       ;ist es der richtige Wert?
                bne.s   check_hclock2   ;Nein! => Chip defekt =>
                bclr    #0,D1           ;Bank 0 anwählen
                move.b  D1,$1B(A0)      ;Bankregister wieder schreiben
                move.b  #0,$1D(A0)      ;Test-Register löschen (Warum???, kein CLR!)
                rts
check_hclock1:  movea.l A2,SP           ;Stackpointer zurücksetzen
                move.l  D2,8.w          ;Busfehler-Vektor wieder zurücksetzen
check_hclock2:  ori     #1,CCR          ;C=1 : Fehler melden
                rts
                ENDPART
************************************************************************
* Uhrzeit holen und GEMDOS-Uhr stellen                                 *
************************************************************************
                >PART 'set_clock'
set_clock_fix:  move    SR,-(SP)
                movem.l D0-A6,-(SP)
                bra.s   set_clock0
set_clock:      move    SR,-(SP)
                movem.l D0-A6,-(SP)
                bsr.s   check_hclock    ;Hardware-Uhr vorhanden?
                bcs.s   set_clock1      ;Nein! =>
set_clock0:     move.w  #$17,-(SP)
                andi    #$FBFF,SR
                trap    #14             ;Get Time
                ori     #$0700,SR
                addq.l  #2,SP
                move.l  D0,D3
                move.w  D0,D1
                rol.w   #5,D1
                and.b   #$1F,D1
                move.b  D1,time_h(A4)   ;Stunden setzen
                move.w  D0,D1
                lsr.w   #5,D1
                and.b   #$3F,D1
                move.b  D1,time_m(A4)   ;Minuten setzen
                and.b   #$1F,D0
                add.w   D0,D0
                move.b  D0,time_s(A4)   ;und die Sekunden
                move.w  D3,-(SP)        ;Zeit im unteren Word
                move.w  #$2D,-(SP)
                trap    #1              ;Tsettime()
                addq.l  #4,SP
                swap    D3
                move.w  D3,-(SP)        ;Datum im oberen Word
                move.w  #$2B,-(SP)
                trap    #1              ;Tsetdate()
                addq.l  #4,SP
set_clock1:     movem.l (SP)+,D0-A6
                move    (SP)+,SR
                rts
                ENDPART
************************************************************************
* S+F10 - Quit?                                                        *
************************************************************************
                >PART 'faquit/fbquit'
fbquit:         tst.b   maustast_flag(A4)
                bmi.s   faquit4         ;rechte Maustaste gedrückt
                sf      maustast_flag(A4)
                tst.b   change_flag(A4) ;Änderungen am Sourcetext ?
                bne.s   faquit          ;ja
                tst.b   action_fl(A4)   ;Änderungen in ak. Zeile ?
                beq     do_quit         ;nein, dann sofort beenden
faquit:         bsr     s_source_da
                lea     quit_rsc2(PC),A0
                beq.s   faquit3         ;Es ist kein Programm da
                tst.b   change_flag(A4)
                bne.s   faquit2         ;es wurde was geändert
faquit3:        lea     quit_rsc(PC),A0
faquit2:        jsr     _form_do
                tst.w   D0
                bmi.s   faquit4
                subq.w  #2,D0           ;Kein Ende
                beq.s   faquit4
                subq.w  #1,D0           ;SPEICHERN
                bne     do_quit
                st      s_exit_flag(A4)
                bra     s_quell_save2   ;Quelltext speichern
faquit4:        sf      maustast_flag(A4)
                bra     main_loop

quit_rsc:       DC.W 0,0,29,6,1
                DC.W 1,1
                DC.L ask_icn
                DC.W $3303
                DC.W 7,1
                DC.L quit_txt1
                DC.W 8
                DC.W 7,2
                DC.L quit_txt2
                DC.W 8
                DC.W 7,4
                DC.L quit_txt3
                DC.W $26
                DC.W 17,4
                DC.L quit_txt4
                DC.W $24
                DC.W -1
quit_rsc2:      DC.W 0,0,45,5,1
                DC.W 1,1
                DC.L quit_rsc_0
                DC.W 8
                DC.W 4,3
                DC.L quit_rsc_2
                DC.W $24
                DC.W 30,3
                DC.L quit_rsc_1
                DC.W $24
                DC.W 17,3
                DC.L quit_rsc_3
                DC.W $26
                DC.W -1

                SWITCH sprache
                CASE 0
quit_rsc_0:     DC.B 'Die Änderungen wurden noch nicht gesichert!',0
quit_rsc_1:     DC.B '  ABBRUCH  ',0
quit_rsc_2:     DC.B ' VERLASSEN ',0
quit_rsc_3:     DC.B ' SPEICHERN ',0
quit_txt1:      DC.B 'Möchten Sie den',0
quit_txt2:      DC.B 'Assembler verlassen?',0
quit_txt3:      DC.B '  JA  ',0
quit_txt4:      DC.B ' NEIN ',0
                CASE 1
quit_rsc_0:     DC.B 'The changes have not been saved!',0
quit_rsc_1:     DC.B ' CANCEL ',0
quit_rsc_2:     DC.B '  QUIT  ',0
quit_rsc_3:     DC.B '  SAVE  ',0
quit_txt1:      DC.B 'Do you want to',0
quit_txt2:      DC.B 'leave the assembler?',0
quit_txt3:      DC.B ' YES ',0
quit_txt4:      DC.B '  NO  ',0
                ENDS
                EVEN

do_quit:        bsr     kill_debugger   ;evtl. geladenen Debugger löschen

                jsr     org_driver

                move    #$2700,SR       ;Alle IRQs sperren
                move.l  $04BA.w,D1
                lea     save_data(A4),A0
                lea     8.w,A1
                move.w  #323,D0
do_quit2:       move.l  (A0)+,(A1)+     ;Speicherblock zurück
                dbra    D0,do_quit2
                move.l  D1,$04BA.w      ;200Hz-Timer nicht auf den alten Wert zurück
                move.l  old_trap3(PC),$8C.w
                move    #$2300,SR       ;IRQs wieder freigeben

                jsr     clr_ikbd        ;Tastatur zurücksetzen

                move.l  old_stack(A4),-(SP)
                move.w  #$20,-(SP)
                trap    #1              ;USER-Modus an
                addq.l  #6,SP

                clr.w   -(SP)           ;Exit to GEMDOS
                trap    #1
                ENDPART
************************************************************************
* F10 - Uhr stellen, bzw. ein-/ausschalten                             *
************************************************************************
                >PART 'fahelp'
fahelp:         moveq   #0,D1
                move.b  time_s(A4),D1
                lea     uhr_sek(PC),A0
                bsr     uhr_out         ;Sekunden einsetzen
                moveq   #0,D1
                move.b  time_m(A4),D1
                lea     uhr_min(PC),A0
                bsr     uhr_out         ;Minuten einsetzen
                moveq   #0,D1
                move.b  time_h(A4),D1
                lea     uhr_std(PC),A0
                bsr     uhr_out         ;Stunden einsetzen
                move.w  #$2A,-(SP)
                jsr     do_trap_1       ;Tgetdate()
                addq.l  #2,SP
                moveq   #31,D1
                and.w   D0,D1
                lea     uhr_tag(PC),A0
                bsr     uhr_out         ;Tag einsetzen
                lsr.w   #5,D0
                moveq   #15,D1
                and.w   D0,D1
                lea     uhr_monat(PC),A0
                bsr     uhr_out         ;Monat einsetzen
                lsr.w   #4,D0
                moveq   #127,D1
                and.w   D0,D1
                add.w   #80,D1
                lea     uhr_jahr(PC),A0
                bsr     uhr_out         ;Jahr einsetzen
                bsr     day_calc        ;Wochentag errechnen
                move.l  A0,uhr_wta      ;Zeiger auf den Wochentag einsetzen
                lea     uhr_rsc(PC),A0
                jsr     _form_do
                tst.w   D0
                bmi     main_loop
                subq.w  #1,D0
                bne.s   uhr_st3
                lea     uhr_button(PC),A0
                SWITCH sprache
                CASE 0
                move.l  #' AUS',D0
                CASE 1
                move.l  #' OFF',D0
                ENDS
                cmp.l   (A0),D0
                beq.s   uhr_st1         ;Uhr aus?
                move.l  D0,(A0)
                sf      uhr_flag(A4)    ;Uhr einschalten
                bra.s   uhr_st2
uhr_st1:        SWITCH sprache
                CASE 0
                move.l  #' EIN',(A0)
                CASE 1
                move.l  #' ON ',(A0)
                ENDS
                st      uhr_flag(A4)    ;Uhr ausschalten
uhr_st2:        bra     main_loop
uhr_st3:        subq.w  #1,D0
                bne.s   uhr_st2
                lea     uhr_jahr(PC),A0
                bsr     uhr_in          ;Zahl holen
                bmi     uhr_ste
                sub.w   #80,D1
                bmi     uhr_ste         ;Illegal
                move.w  D1,D3           ;Jahr merken
                lea     uhr_monat(PC),A0
                bsr     uhr_in          ;Zahl holen
                bmi     uhr_ste
                tst.w   D1
                beq     uhr_ste
                cmp.w   #12,D1          ;0<Monat<13
                bhi     uhr_ste
                lsl.w   #4,D3
                or.w    D1,D3           ;Monat einsetzen
                lea     uhr_tag(PC),A0
                bsr     uhr_in
                bmi     uhr_ste
                tst.w   D1
                bmi     uhr_ste
                cmp.w   #31,D1
                bhi.s   uhr_ste
                lsl.w   #5,D3
                or.w    D1,D3
                move.w  D3,-(SP)
                move.w  #$2B,-(SP)
                trap    #1              ;Tsetdate()
                addq.l  #4,SP
                swap    D3              ;Datum im oberen Word
                lea     uhr_std(PC),A0
                bsr.s   uhr_in
                bmi.s   uhr_ste
                cmp.w   #23,D1
                bhi.s   uhr_ste
                move.w  D1,D3
                lea     uhr_min(PC),A0
                bsr.s   uhr_in
                bmi.s   uhr_ste
                cmp.w   #59,D1
                bhi.s   uhr_ste
                lsl.w   #6,D3
                or.w    D1,D3
                lea     uhr_sek(PC),A0
                bsr.s   uhr_in
                bmi.s   uhr_ste
                cmp.w   #59,D1
                bhi.s   uhr_ste
                move.b  D1,time_s(A4)
                lsr.w   #1,D1           ;Zeit nur im 2-Sekunden-Takt
                lsl.w   #5,D3
                or.w    D1,D3
                move.w  D3,-(SP)
                move.w  #$2A,-(SP)
                jsr     do_trap_1       ;Tsettime()
                addq.l  #4,SP
                move.l  D3,-(SP)
                move.w  #$16,-(SP)
                trap    #14             ;Settime()
                addq.l  #6,SP
                lsr.w   #5,D3
                moveq   #63,D0
                and.w   D3,D0
                move.b  D0,time_m(A4)
                lsr.w   #6,D3
                moveq   #31,D0
                and.w   D3,D0
                move.b  D0,time_h(A4)
                bra     uhr_st2
uhr_ste:        jsr     c_bell          ;Falsche Eingabe
                bra     uhr_st2
uhr_in:         moveq   #0,D0
                moveq   #0,D1
                moveq   #-1,D2          ;noch keine Eingabe
uhr_in1:        move.b  (A0)+,D0
                beq.s   uhr_in2
                cmp.w   #' ',D0
                beq.s   uhr_in1
                subi.w  #'0',D0
                mulu    #10,D1
                add.w   D0,D1
                moveq   #0,D2           ;Eingabe vorhanden
                bra.s   uhr_in1
uhr_in2:        tst.w   D2
                rts

uhr_out:        divu    #10,D1
                or.l    #' 0 0',D1
                move.b  D1,(A0)+
                swap    D1
                move.b  D1,(A0)
                rts
uhr_rsc:        DC.W 0,0,42,8,1
                DC.W 2,2
                DC.L uhr_rsc_1
                DC.W 8
                DC.W 15,2
                DC.L uhr_rsc_2
                DC.W 8
                DC.W 28,2
                DC.L uhr_rsc_3
                DC.W 8
                DC.W 2,1
                DC.L uhr_rsc_6
                DC.W 8
                DC.W 15,1
                DC.L uhr_rsc_7
                DC.W 8
                DC.W 28,1
                DC.L uhr_rsc_8
                DC.W 8
                DC.W 11,1
                DC.L uhr_std
                DC.W $A8
                DC.W 24,1
                DC.L uhr_min
                DC.W $A8
                DC.W 37,1
                DC.L uhr_sek
                DC.W $A8
                DC.W 11,2
                DC.L uhr_tag
                DC.W $A8
                DC.W 24,2
                DC.L uhr_monat
                DC.W $A8
                DC.W 39,2
                DC.L uhr_jahr
                DC.W $A8
                DC.W 9,4
                DC.L uhr_rsc_12
                DC.W 8
                SWITCH sprache
                CASE 0
                DC.W 23,4
                CASE 1
                DC.W 20,4
                ENDS
uhr_wta:        DC.L 0
                DC.W 8
                DC.W 15,6
                DC.L uhr_rsc_13
                DC.W $24
                DC.W 1,6
                DC.L uhr_rsc_14
                DC.W $24
                SWITCH sprache
                CASE 0
                DC.W 33,6
                CASE 1
                DC.W 29,6
                ENDS
                DC.L ok_button
                DC.W $26
                DC.W -1

                SWITCH sprache
                CASE 0
uhr_rsc_1:      DC.B 'Tag     :',0
uhr_rsc_2:      DC.B 'Monat   :',0
uhr_rsc_3:      DC.B 'Jahr    :19',0
uhr_tag:        DC.B '  ',0
uhr_monat:      DC.B '  ',0
uhr_jahr:       DC.B '  ',0
uhr_rsc_6:      DC.B 'Stunden :',0
uhr_rsc_7:      DC.B 'Minuten :',0
uhr_rsc_8:      DC.B 'Sekunden:',0
uhr_std:        DC.B '  ',0
uhr_min:        DC.B '  ',0
uhr_sek:        DC.B '  ',0
uhr_rsc_12:     DC.B 'Heute ist ein',0
                EVEN
uhr_rsc_13:     DC.B ' UHR'
uhr_button:     DC.B ' AUSSCHALTEN ',0
uhr_rsc_14:     DC.B ' UHR STELLEN ',0
                EVEN
                CASE 1
uhr_rsc_1:      DC.B 'Day     :',0
uhr_rsc_2:      DC.B 'Month   :',0
uhr_rsc_3:      DC.B 'Year    :19',0
uhr_tag:        DC.B '  ',0
uhr_monat:      DC.B '  ',0
uhr_jahr:       DC.B '  ',0
uhr_rsc_6:      DC.B 'Hours   :',0
uhr_rsc_7:      DC.B 'Minutes :',0
uhr_rsc_8:      DC.B 'Seconds :',0
uhr_std:        DC.B '  ',0
uhr_min:        DC.B '  ',0
uhr_sek:        DC.B '  ',0
uhr_rsc_12:     DC.B 'Today is a',0
                EVEN
uhr_rsc_13:     DC.B ' CLOCK'
uhr_button:     DC.B ' OFF ',0
uhr_rsc_14:     DC.B ' SET CLOCK ',0
                EVEN
                ENDS
                ENDPART
                >PART 'day_calc'
day_calc:       move.w  #$2A,-(SP)
                jsr     do_trap_1       ;Tgetdate()
                addq.l  #2,SP
day_calc_:      moveq   #$1F,D3
                and.w   D0,D3           ;Der Tag
                lsr.w   #5,D0
                moveq   #$0F,D1
                and.w   D0,D1           ;Der Monat
                lsr.w   #4,D0
                moveq   #$7F,D2
                and.w   D0,D2
                add.w   #1980,D2        ;Das Jahr (Long für DIVU s.u.)
                cmp.w   #3,D1
                bhs.s   get_da1         ;Monat= März, April, ... =>
                add.w   #12,D1          ;Monat+12
                subq.w  #1,D2           ;Jahr-1
get_da1:        moveq   #0,D0
                move.w  D2,D0
                sub.w   #1980,D0        ;damit es auf Wortbreite bleibt
                move.w  D0,D4           ;Jahroffset merken
                mulu    #365,D0         ;mal 365
                lsr.w   #2,D4
                add.w   D4,D0           ;Schaltjahreskorrektur dazu addieren
                add.l   #723195,D0      ;und 1980*365.25 wieder dazu

                divu    #100,D2         ;- Jahr/100
                ext.l   D2
                sub.l   D2,D0

                lsr.l   #2,D2           ;+ Jahr/400
                add.l   D2,D0

                move.w  D1,D2           ;Den Tag merken
                subq.w  #1,D2
                mulu    #31,D2          ;+ (Tag-1)*31
                ext.l   D2
                add.l   D2,D0

                lsl.w   #2,D1           ;- Monat*0.4+2.3
                add.w   #23,D1
                divu    #10,D1          ;jetzt das Komma berücksichtigen
                ext.l   D1
                sub.l   D1,D0

                add.l   D3,D0           ;+ Tag
                addq.l  #6,D0           ;+ Magic

                ext.l   D0
                divs    #7,D0           ;mod 7
                clr.w   D0
                swap    D0
                lea     day_tab(PC),A0
                move.w  D0,D2
get_da2:        dbra    D2,get_da3
                rts
get_da3:        tst.b   (A0)+
                bne.s   get_da3
                bra.s   get_da2

day_tab:        SWITCH sprache
                CASE 0
                DC.B 'Montag',0
                DC.B 'Dienstag',0
                DC.B 'Mittwoch',0
                DC.B 'Donnerstag',0
                DC.B 'Freitag',0
                DC.B 'Sonnabend',0
                DC.B 'Sonntag',0
                CASE 1
                DC.B 'Monday',0
                DC.B 'Tuesday',0
                DC.B 'Wednesday',0
                DC.B 'Thursday',0
                DC.B 'Friday',0
                DC.B 'Saturday',0
                DC.B 'Sunday',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Gibt die Zeichentabelle aus                                          *
* ausgewählter Zeichencode wird in D0 zurückgegeben                    *
************************************************************************
                >PART 's_char_tab'
s_char_tab:     lea     char_rsc(PC),A0
                movem.l D1-A6,-(SP)
                move.l  zeile(A4),-(SP)
                addq.b  #1,set_lock(A4) ;Cursorsetzen im VBL verhindern
                st      no_dklick(A4)   ;Kein Doppelklick
                jsr     cursor_off
                movea.l A0,A1
                moveq   #0,D0
                lea     -10(A1),A2
                jsr     _objc_draw      ;Baum zeichnen
s_char_tab2:    jsr     tastchk         ;Tastatur abfragen
                bmi.s   s_char_tab5     ;Taste gedrückt
                btst    #1,maustast(A4) ;Linke Taste gedrückt?
                bne.s   s_char_tab3     ;Ja!
                btst    #0,maustast(A4) ;Rechte Taste gedrückt?
                beq.s   s_char_tab2     ;Nein!
                bra.s   s_char_tab5
s_char_tab3:    bsr.s   s_char_tab6     ;Maus über einem Text?
                bne.s   s_char_tab5     ;Nein!
                btst    #1,maustast(A4)
                bne.s   s_char_tab3     ;warten bis Taste losgelassen
                movea.l A0,A3           ;Zeiger auf aktuelles Edit-Obj
                sub.w   (A3),D0         ;Position im Eingabefeld
                subq.w  #1,D2
                lsl.w   #6,D2           ;Textnummer mal Zeilenlänge
                add.w   D2,D0           ;ASCII-Zeichen
                bra.s   s_char_tab50
s_char_tab5:    btst    #1,maustast(A4)
                bne.s   s_char_tab5     ;warten bis Taste losgelassen
                moveq   #0,D0
s_char_tab50:   move.l  (SP)+,zeile(A4)
                movem.l (SP)+,D1-A6
                subq.b  #1,set_lock(A4)
                sf      no_dklick(A4)
                bra     redraw_all

s_char_tab6:    move.w  mausx(A4),D0
                moveq   #0,D1
                move.w  mausy(A4),D1
                lsr.w   #3,D0
                divu    sdrv_cheight(A4),D1 ;In Zeichenkoordinaten umrechnen
                ext.l   D1
                subq.w  #menu_offset,D1
                bmi.s   s_char_e3
                move.w  D0,D6
                move.w  D1,D7
                movem.w 4(A1),D2-D3     ;Breite & Höhe holen
                sub.w   sdrv_maxcur_x(A4),D2
                subq.w  #1,D2
                neg.w   D2
                lsr.w   #1,D2           ;Objekt zentieren
                sub.w   sdrv_zanz(A4),D3
                neg.w   D3
                lsr.w   #1,D3
                sub.w   D2,D0           ;X zu klein?
                bmi.s   s_char_e3       ;dann nix gefunden =>
                sub.w   D3,D1
                bmi.s   s_char_e3       ;Y zu klein? Ja! =>
                moveq   #0,D2           ;Text Nr löschen
                movea.l A1,A0
s_char_e1:      tst.w   (A0)
                bmi.s   s_char_e3       ;Nichts gefunden
                lea     10(A0),A0       ;Nächster Eintrag (Flags unbeeinflußt)
                btst    #3,-1(A0)       ;Text?
                beq.s   s_char_e1       ;Kein Text
                addq.w  #1,D2           ;Text-Nr erhöhen
                move.w  -10(A0),D3      ;X-Koordinate holen
                cmp.w   D3,D0
                blo.s   s_char_e1       ;X zu klein
                movea.l -6(A0),A2       ;Textadresse
                moveq   #-1,D4
s_char_e2:      addq.l  #1,D4           ;Textlänge ermitteln
                tst.b   (A2)+
                bne.s   s_char_e2
                add.w   D4,D3           ;Breite dazu
                cmp.w   D3,D0
                bhs.s   s_char_e1       ;X zu groß
                move.w  -8(A0),D3       ;Y-Koordinate holen
                cmp.w   D3,D1
                blo.s   s_char_e1       ;Y zu klein
                addq.w  #1,D3           ;Höhe dazu (da Text, stets eine Zeile)
                cmp.w   D3,D1
                bhs.s   s_char_e1       ;Y zu groß
                lea     -10(A0),A0
                move    #$FF,CCR        ;Text gefunden
                rts
s_char_e3:      moveq   #0,D2           ;Kein Text gefunden
                move    #0,CCR
                rts

char_rsc:       DC.W 0,0,64,4,1
                DC.W 0,0
                DC.L char_rsc_0
                DC.W 8
                DC.W 0,1
                DC.L char_rsc_1
                DC.W 8
                DC.W 0,2
                DC.L char_rsc_2
                DC.W 8
                DC.W 0,3
                DC.L char_rsc_3
                DC.W 8
                DC.W -1

char_rsc_0:     DC.B $20,1,2,3,4,5,6,7,8,9,$0A,$0B,$0C,$0D,$0E,$0F
                DC.B $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1A,$1B,$1C,$1D,$1E,$1F
                DC.B $20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$2A,$2B,$2C,$2D,$2E,$2F
                DC.B $30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$3A,$3B,$3C,$3D,$3E,$3F,0
char_rsc_1:     DC.B $40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$4A,$4B,$4C,$4D,$4E,$4F
                DC.B $50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$5A,$5B,$5C,$5D,$5E,$5F
                DC.B $60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$6A,$6B,$6C,$6D,$6E,$6F
                DC.B $70,$71,$72,$73,$74,$75,$76,$77,$78,$79,$7A,$7B,$7C,$7D,$7E,$7F,0
char_rsc_2:     DC.B $80,$81,$82,$83,$84,$85,$86,$87,$88,$89,$8A,$8B,$8C,$8D,$8E,$8F
                DC.B $90,$91,$92,$93,$94,$95,$96,$97,$98,$99,$9A,$9B,$9C,$9D,$9E,$9F
                DC.B $A0,$A1,$A2,$A3,$A4,$A5,$A6,$A7,$A8,$A9,$AA,$AB,$AC,$AD,$AE,$AF
                DC.B $B0,$B1,$B2,$B3,$B4,$B5,$B6,$B7,$B8,$B9,$BA,$BB,$BC,$BD,$BE,$BF,0
char_rsc_3:     DC.B $C0,$C1,$C2,$C3,$C4,$C5,$C6,$C7,$C8,$C9,$CA,$CB,$CC,$CD,$CE,$CF
                DC.B $D0,$D1,$D2,$D3,$D4,$D5,$D6,$D7,$D8,$D9,$DA,$DB,$DC,$DD,$DE,$DF
                DC.B $E0,$E1,$E2,$E3,$E4,$E5,$E6,$E7,$E8,$E9,$EA,$EB,$EC,$ED,$EE,$EF
                DC.B $F0,$F1,$F2,$F3,$F4,$F5,$F6,$F7,$F8,$F9,$FA,$FB,$FC,$FD,$FE,$FF,0
                EVEN
                ENDPART
************************************************************************
* Shift-F5 Info                                                        *
************************************************************************
                >PART 'sourceinfo'
sourceinfo:     jsr     garbage_collection
                st      testwrd(A4)
                movem.l D1/D4,-(SP)
                moveq   #4,D4
                lea     sourceinfo_6(PC),A0
                moveq   #0,D1
                move.w  anz_zeilen(A4),D1 ;Anzahl der Zeilen
                jsr     dezw_out
                move.w  max_lines(A4),D1 ;max. Anzahl
                lea     sourceinfo_6+12(PC),A0
                jsr     dezw_out
                move.w  label_top_ind(A4),D1 ;Einträge
                lea     sourceinfo_7(PC),A0
                jsr     dezw_out
                move.w  max_index(A4),D1 ;max. Einträge
                lea     sourceinfo_7+12(PC),A0
                jsr     dezw_out
                movem.l D2-D3,-(SP)
                moveq   #0,D2
                moveq   #0,D3
                movea.l label_base(A4),A0
                move.w  label_top_ind(A4),D1
                subq.l  #1,A0
sourceinfo_l:   subq.w  #1,D1
                bmi.s   sourceinfo_l2
                lea     32(A0),A0
                tst.b   (A0)            ;Status des Eintrags
                beq.s   sourceinfo_l3   ;Symbol
                bpl.s   sourceinfo_l    ;freier Eintrag
                cmpi.b  #$FE,(A0)
                bhi.s   sourceinfo_l4   ;Formel
                beq.s   sourceinfo_l5   ;DC-Zeile
                swap    D3
                addq.w  #1,D3           ;Sonstiges
                swap    D3
                bra.s   sourceinfo_l
sourceinfo_l5:  addq.w  #1,D3
                bra.s   sourceinfo_l
sourceinfo_l4:  swap    D2
                addq.w  #1,D2
                swap    D2
                bra.s   sourceinfo_l
sourceinfo_l3:  addq.w  #1,D2
                bra.s   sourceinfo_l
sourceinfo_l2:  moveq   #0,D1
                move.w  D2,D1
                lea     sourceinfo_9(PC),A0 ;Symbole
                jsr     dezw_out
                swap    D2
                move.w  D2,D1
                lea     sourceinfo_10(PC),A0 ;Formeln
                jsr     dezw_out
                move.w  D3,D1
                lea     sourceinfo_11(PC),A0 ;DC-Zeilen
                jsr     dezw_out
                swap    D3
                move.w  D3,D1
                lea     sourceinfo_12(PC),A0 ;Sonstiges
                jsr     dezw_out
                movem.l (SP)+,D2-D3
                moveq   #6,D4
                move.l  program_top(A4),D1
                sub.l   program_base(A4),D1 ;Codelänge
                lea     sourceinfo_4(PC),A0
                jsr     dezw_out
                move.l  comment_top(A4),D1
                sub.l   comment_base(A4),D1 ;Remarklänge
                lea     sourceinfo_5(PC),A0
                jsr     dezw_out
                move.l  program_max(A4),D1
                sub.l   program_base(A4),D1 ;max. Codelänge
                lea     sourceinfo_4+12(PC),A0
                jsr     dezw_out
                move.l  comment_max(A4),D1
                sub.l   comment_base(A4),D1 ;max. Remarklänge
                lea     sourceinfo_5+12(PC),A0
                jsr     dezw_out
                move.l  max_code_len(A4),D1
                lea     sourceinfo_16(PC),A0
                jsr     dezw_out
                sf      testwrd(A4)
                movem.l (SP)+,D1/D4
                lea     sourceinfo_rsc(PC),A0
                jsr     _form_do
                subq.w  #1,D0           ;REORGANISIEREN
                bne     main_loop       ;nein
                lea     entry_buffer(A4),A0
                move.l  memory_gem(A4),(A0)+ ;Werte retten
                move.l  max_code_len(A4),(A0)+
                move.l  ass_adr(A4),(A0)+
                move.l  max_index(A4),(A0) ;max_index und max_lines
                bsr     install_alert
                tst.w   D0
                bpl     main_loop       ;ABBRUCH
                cmp.w   #-2,D0          ;wurde GEM-Speicher geändert
                bne.s   sourceinfo2     ;nein
                move.l  memory_base(A4),-(SP)
                move.w  #$49,-(SP)
                jsr     do_trap_1       ;Mfree
                addq.l  #6,SP
                move.l  memory_free(A4),D0
                sub.l   memory_gem(A4),D0
                move.l  D0,-(SP)        ;Anzahl der Bytes
                move.w  #$48,-(SP)
                jsr     do_trap_1       ;Malloc
                addq.l  #6,SP
                move.l  D0,memory_base(A4)
sourceinfo2:    lea     entry_buffer+16(A4),A0 ;Zwischenspeicher
                lea     program_base(A4),A1 ;Bereichszeiger
                moveq   #3,D1
sourceinfo3:    move.l  (A1)+,(A0)+
                move.l  (A1)+,D0        ;alte Zeiger retten
                sub.l   -4(A0),D0       ;immer base-Zeiger und Länge des Bereichs
                move.l  D0,(A0)+
                move.l  (A1)+,(A0)+     ;_max Zeiger
                dbra    D1,sourceinfo3
                move.l  memory_base(A4),D0 ;Startadresse
                move.l  memory_free(A4),D3
                sub.l   memory_gem(A4),D3 ;Anzahl der Bytes
                bsr     mem_verteilung  ;Zeiger der Bereiche neu berechnen
                lea     program_base(A4),A1
                lea     entry_buffer+16-4(A4),A0
                moveq   #3,D1
sourceinfo4:    addq.l  #8,A1
                addq.l  #8,A0
                move.l  (A1)+,D0
                sub.l   -12(A1),D0      ;zur Verfügung stehender Platz
                cmp.l   (A0)+,D0        ;mit alter Blocklänge vergleichen
                dbls    D1,sourceinfo4
                bls     sourceinfo5     ;Speicher reicht nicht
                movem.l A2-A3,-(SP)
                lea     program_base(A4),A1 ;Zielbreich
                lea     entry_buffer+16(A4),A0 ;alte Bereiche
                move.l  memory_top(A4),D0
                sub.l   memory_base(A4),D0 ;Länge der neuen Bereiche
                move.l  44(A0),D1       ;alte Endadresse der Remarks
                sub.l   (A0),D1         ;minus Anfang des Speichers
                cmp.l   D1,D0
                bhi.s   sourceinfo61    ;Blöcke werden auseinandergezogen
                moveq   #3,D1
sourceinfo6:    movea.l (A0)+,A2        ;Start des alten Bereichs
                movea.l (A1)+,A3        ;Start des neuen Bereichs
                move.l  (A0)+,D0        ;Länge des zu kopierenden Bereichs
                add.l   D0,(A1)+
                addq.l  #4,A1
                addq.l  #4,A0
                lsr.l   #1,D0
                beq.s   sourceinfo8     ;Block hat die Länge 0
                bra.s   sourceinfo73
sourceinfo74:   swap    D0
sourceinfo71:   move.w  (A2)+,(A3)+     ;Block nach unten kopieren
sourceinfo73:   dbra    D0,sourceinfo71
                swap    D0
                dbra    D0,sourceinfo74
sourceinfo8:    dbra    D1,sourceinfo6
sourceinfo82:   movea.l z_info_top(A4),A0
                moveq   #-1,D0
                clr.w   D0
                move.l  D0,(A0)         ;Endekennung setzen
                move.l  D0,6(A0)
                movem.l (SP)+,A2-A3
                movea.l program_base(A4),A6
                movea.l z_info_base(A4),A5
                movea.l comment_base(A4),A3 ;Zeiger auf Anfang
                movem.l A3/A5-A6,top_ptr(A4)
                clr.w   top_line(A4)
                bsr     jump_line       ;Zeile anspringen (D6 wurde nicht verändert)
                bra     main_loop
sourceinfo61:   moveq   #3,D1
                lea     comment_base(A4),A1
                lea     36(A0),A0
sourceinfo62:   movea.l (A0)+,A2        ;Start des alten Bereichs
                movea.l (A1)+,A3        ;Start des neuen Bereichs
                move.l  (A0),D0         ;Länge des zu kopierenden Bereichs
                add.l   D0,(A1)
                suba.w  #16,A1
                suba.w  #16,A0
                lea     2(A2,D0.l),A2
                lea     2(A3,D0.l),A3
                lsr.l   #1,D0
                beq.s   sourceinfo81    ;Block hat die Länge 0
                bra.s   sourceinfo72
sourceinfo75:   swap    D0
sourceinfo72:   move.w  -(A2),-(A3)     ;Block nach oben kopieren
                dbra    D0,sourceinfo72
                swap    D0
                dbra    D0,sourceinfo75
sourceinfo81:   dbra    D1,sourceinfo62
                bra.s   sourceinfo82

sourceinfo5:    lea     sourceinfo9_rsc(PC),A0
                jsr     _form_do
                subq.w  #1,D0           ;löschen
                bne.s   sourceinfo51    ;nein
                bsr     s_new           ;Speicher reicht nicht -> wird gelöscht
                bra     main_loop
sourceinfo51:   move.l  memory_base(A4),-(SP)
                move.w  #$49,-(SP)
                jsr     do_trap_1       ;Mfree
                addq.l  #6,SP
                move.l  entry_buffer(A4),memory_gem(A4) ;Werte zurückholen
                move.l  entry_buffer+4(A4),max_code_len(A4)
                move.l  entry_buffer+8(A4),ass_adr(A4)
                move.l  entry_buffer+12(A4),max_index(A4)
                move.l  memory_free(A4),D0
                sub.l   memory_gem(A4),D0
                move.l  D0,-(SP)        ;Anzahl der Bytes
                move.w  #$48,-(SP)
                jsr     do_trap_1       ;Malloc
                addq.l  #6,SP
                move.l  D0,memory_base(A4)
                lea     entry_buffer+16(A4),A0
                lea     program_base(A4),A1 ;alte Zeiger rekonstruieren
                moveq   #3,D1
sourceinfo52:   move.l  (A0)+,D0
                move.l  D0,(A1)+        ;_base Zeiger
                add.l   (A0)+,D0
                move.l  D0,(A1)+        ;_top Zeiger
                move.l  (A0)+,(A1)+     ;_max Zeiger
                dbra    D1,sourceinfo52
                move.l  comment_max(A4),memory_top(A4)
                bra     main_loop

sourceinfo_rsc: DC.W 0,0,39,18,1
                DC.W 1,1
                DC.L sourceinfo_0
                DC.W 8
                DC.W 1,3
                DC.L sourceinfo_1
                DC.W 8
                DC.W 1,5
                DC.L sourceinfo_2
                DC.W 8
                DC.W 1,7
                DC.L sourceinfo_3
                DC.W 8
                DC.W 19,3
                DC.L sourceinfo_4
                DC.W 8
                DC.W 19,5
                DC.L sourceinfo_5
                DC.W 8
                DC.W 21,1
                DC.L sourceinfo_6
                DC.W 8
                DC.W 21,7
                DC.L sourceinfo_7
                DC.W 8
                DC.W 12,9
                DC.L sourceinfo_8
                DC.W 8
                DC.W 21,9
                DC.L sourceinfo_9
                DC.W 8
                DC.W 21,10
                DC.L sourceinfo_10
                DC.W 8
                DC.W 21,11
                DC.L sourceinfo_11
                DC.W 8
                DC.W 21,12
                DC.L sourceinfo_12
                DC.W 8
                DC.W 4,14
                DC.L sourceinfo_15
                DC.W 8
                DC.W 4,16
                DC.L sourceinfo_13
                DC.W $24
                DC.W 27,16
                DC.L ok_button
                DC.W $26
                DC.W -1

                SWITCH sprache
                CASE 0
sourceinfo_0:   DC.B 'Zeilenanzahl:',0
sourceinfo_1:   DC.B 'Programm (Bytes):',0
sourceinfo_2:   DC.B 'Remarks (Bytes):',0
sourceinfo_3:   DC.B 'Tabelleneinträge:',0
sourceinfo_4:   DC.B '1234567 von 1234567',0
sourceinfo_5:   DC.B '1234567 von 1234567',0
sourceinfo_6:   DC.B '12345 von   65535',0
sourceinfo_7:   DC.B '12345 von   16363',0
sourceinfo_8:   DC.B 'davon:',0
sourceinfo_9:   DC.B '12345 Symbole',0
sourceinfo_10:  DC.B '12345 Formeln',0
sourceinfo_11:  DC.B '12345 DC-Zeilen',0
sourceinfo_12:  DC.B '12345 Sonstige',0
sourceinfo_13:  DC.B ' REORGANISIEREN ',0
sourceinfo_15:  DC.B 'Zielcode maximal '
sourceinfo_16:  DC.B '1234567 Bytes',0
                CASE 1
sourceinfo_0:   DC.B 'Number of lines:',0
sourceinfo_1:   DC.B 'Program (Bytes):',0
sourceinfo_2:   DC.B 'Remarks (Bytes):',0
sourceinfo_3:   DC.B 'Number of entries:',0
sourceinfo_4:   DC.B '1234567  of 1234567',0
sourceinfo_5:   DC.B '1234567  of 1234567',0
sourceinfo_6:   DC.B '12345  of   65535',0
sourceinfo_7:   DC.B '12345  of   16363',0
sourceinfo_8:   DC.B '  for:',0
sourceinfo_9:   DC.B '12345 symbols',0
sourceinfo_10:  DC.B '12345 formulas',0
sourceinfo_11:  DC.B '12345 DC-Lines',0
sourceinfo_12:  DC.B '12345 others',0
sourceinfo_13:  DC.B ' REORGANIZE ',0
sourceinfo_15:  DC.B 'memory for code '
sourceinfo_16:  DC.B '1234567 Bytes',0
                ENDS
                EVEN

sourceinfo9_rsc:DC.W 0,0,27,7,1
                DC.W 1,1
                DC.L sourceinfo9_0
                DC.W 8
                DC.W 4,3
                DC.L sourceinfo9_1
                DC.W 8
                DC.W 2,5
                DC.L sourceinfo9_2
                DC.W $24
                DC.W 16,5
                DC.L abbruch_button
                DC.W $26
                DC.W -1

                SWITCH sprache
                CASE 0
sourceinfo9_0:  DC.B 'Der Speicher reicht nicht',0
sourceinfo9_1:  DC.B 'für den Sourcetext.',0
sourceinfo9_2:  DC.B ' LÖSCHEN ',0
                CASE 1
sourceinfo9_0:  DC.B 'The memory is too small',0
sourceinfo9_1:  DC.B 'for the sourcetext.',0
sourceinfo9_2:  DC.B ' CLEAR ',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Eintrag für Warnungen anspringen angeklickt                          *
************************************************************************
                >PART 's_warnflag'
s_warnflag:     moveq   #' ',D0
                not.b   skip_warn(A4)   ;Flag toggeln
                beq.s   s_warnflag1
                moveq   #'',D0
s_warnflag1:    move.b  D0,warn_entry+1
                bra     main_loop
                ENDPART
************************************************************************
* Editormenü                                                           *
************************************************************************
                >PART 's_editor_1'
s_editor_1:     st      testwrd(A4)
                lea     s_edt02(PC),A0
                andi.w  #$FFFE,(A0)
                move.l  screen_delay(A4),D1
                tst.l   D1
                bpl.s   s_editor_11
                ori.w   #1,(A0)
                bra.s   s_editor_12
s_editor_11:    lsr.l   #3,D1
                divu    #25,D1
                moveq   #2,D4
                lea     editorm_10(PC),A0
                jsr     dezw_out
s_editor_12:    move.w  col1(A4),D1
                lea     editorm_5+3(PC),A0
                bsr     s_editor_111
                move.w  col0(A4),D1
                lea     editorm_6+3(PC),A0
                bsr     s_editor_111
                sf      testwrd(A4)
                lea     intin(A4),A0
                move.w  s_edt05(PC),(A0)+
                move.w  s_edt06(PC),(A0)+
                move.w  s_edt07(PC),(A0)
                lea     s_editor1_rsc(PC),A0
                move.b  s_suchz(PC),D1  ;für ABBRUCH merken
                jsr     _form_do
                subq.w  #1,D0
                ble.s   s_editor_17
                st      screen_delay(A4)
                btst    #0,s_edt02+1(PC) ;nein selektiert
                bne.s   s_editor_14
                lea     editorm_10(PC),A0
                moveq   #3,D2
                moveq   #0,D1
                bsr     s_get_zahl
                cmp.w   #10,D1          ;Werte kleiner 10->10
                bhs.s   s_editor_13
                moveq   #10,D1
s_editor_13:    mulu    #25,D1
                lsl.l   #3,D1           ;mal 200
                move.l  D1,screen_delay(A4) ;Verzögerung für Screensaver setzen
s_editor_14:    lea     editorm_5(PC),A0
                bsr.s   s_editor_18
                bmi.s   s_editor_15
                move.w  D1,col1(A4)
                move.w  D1,$FFFF8242.w
                move.w  D1,$FFFF8244.w
                move.w  D1,$FFFF8246.w
s_editor_15:    lea     editorm_6(PC),A0
                bsr.s   s_editor_18
                bmi.s   s_editor_16
                cmp.w   col1(A4),D1
                beq.s   s_editor_16
                move.w  D1,col0(A4)
                move.w  D1,$FFFF8240.w
s_editor_16:    bra     main_loop
s_editor_17:    move.b  D1,s_suchz      ;zurückschreiben, da ABBRUCH
                lea     intin(A4),A0
                move.w  (A0)+,s_edt05
                move.w  (A0)+,s_edt06
                move.w  (A0),s_edt07
                bra.s   s_editor_16

s_editor_18:    moveq   #0,D1           ;holt 3-stellige Hexzahl
                moveq   #0,D0
                moveq   #2,D2
s_editor_19:    move.b  (A0)+,D0
                sub.b   #'0',D0
                bmi.s   s_editor_110
                cmp.b   #7,D0
                bhi.s   s_editor_110
                lsl.w   #4,D1
                or.b    D0,D1
                dbra    D2,s_editor_19
                move    #0,CCR
                rts
s_editor_110:   move    #$FF,CCR
                rts

s_editor_111:   moveq   #0,D0           ;3-stellige Hexzahl ausgeben
                moveq   #2,D2
s_editor_112:   moveq   #$0F,D0
                and.b   D1,D0
                add.b   #'0',D0
                move.b  D0,-(A0)
                lsr.w   #4,D1
                dbra    D2,s_editor_112
                rts

s_editor1_rsc:  DC.W 0,0,39,13,1
                DC.W 24,11
                DC.L abbruch_button
                DC.W $24
                DC.W 6,11
                DC.L ok_button
                DC.W $26
                DC.W 2,1
                DC.L editorm_4
                DC.W 8
                DC.W 23,1
                DC.L editorm_5
                DC.W $A8
                DC.W 31,1
                DC.L editorm_6
                DC.W $A8
                DC.W 2,3
                DC.L editorm_7
                DC.W 8
                DC.W 31,3
                DC.L nein_button
s_edt02:        DC.W 4
                DC.W 25,3
                DC.L editorm_9
                DC.W 8
                DC.W 21,3
                DC.L editorm_10
                DC.W $A8
                DC.W 21,1
                DC.L editorm_18
                DC.W 8
                DC.W 29,1
                DC.L editorm_19
                DC.W 8
                DC.W 2,5
                DC.L editorm_22
                DC.W 8
                DC.W 11,7
                DC.L editorm_23
s_edt05:        DC.W $0245
                DC.W 23,7
                DC.L editorm_24
s_edt06:        DC.W $0244
                DC.W 2,7
                DC.L editorm_25
s_edt07:        DC.W $0244
                DC.W 2,9
                DC.L editorm_26
                DC.W 8
                DC.W 21,9
                DC.L s_suchz
                DC.W $88
                DC.W -1

s_suchz:        DC.B '~',0
editorm_5:      DC.B '000',0
editorm_6:      DC.B '555',0
editorm_10:     DC.B '999',0
editorm_18:     DC.B 'V:',0
editorm_19:     DC.B 'H:',0
                SWITCH sprache
                CASE 0
editorm_4:      DC.B 'Farbe',0
editorm_7:      DC.B 'Bildabschaltung',0
nein_button:    DC.B ' nein ',0
editorm_9:      DC.B 'sek',0
editorm_22:     DC.B 'Suchfunktionen',0
editorm_23:     DC.B ' von vorne ',0
editorm_24:     DC.B ' letzte Zeile ',0
editorm_25:     DC.B ' normal ',0
editorm_26:     DC.B 'Suchzeichen',0
                CASE 1
editorm_4:      DC.B 'Color',0
editorm_7:      DC.B 'Screensaver',0
nein_button:    DC.B '  no  ',0
editorm_9:      DC.B 'sec',0
editorm_22:     DC.B 'Searchfunctions',0
editorm_23:     DC.B ' from beg. ',0
editorm_24:     DC.B ' last line ',0
editorm_25:     DC.B ' normal ',0
editorm_26:     DC.B 'Search-Char',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Darstellungsmenü                                                     *
************************************************************************
                >PART 's_darstellung'
s_darstellung:  st      testwrd(A4)
                moveq   #0,D1
                lea     editor_r_5(PC),A0
                moveq   #1,D4
                move.w  tabs(A4),D1
                jsr     dezw_out
                lea     editor_r_6(PC),A0
                move.w  tabs+2(A4),D1
                jsr     dezw_out
                lea     editor_r_7(PC),A0
                move.w  tabs+4(A4),D1
                jsr     dezw_out
                lea     editor_r_28(PC),A0
                move.w  tabs+6(A4),D1
                jsr     dezw_out
                lea     editor_r_29(PC),A0
                move.w  tabs+8(A4),D1
                jsr     dezw_out
                sf      testwrd(A4)
                moveq   #5,D1
                moveq   #0,D0
                lea     editor_op(PC),A0
s_darstellung1: andi.w  #$FFFE,(A0)
                andi.w  #$FFFE,10(A0)
                move.b  hexlen_flag(A4,D1.w),D0
                sne     D0
                andi.w  #10,D0
                ori.w   #1,0(A0,D0.w)
                lea     20(A0),A0
                dbra    D1,s_darstellung1
                lea     editor_rsc(PC),A0
                jsr     _form_do
                bmi     main_loop
                subq.w  #2,D0
                beq     main_loop
                lea     editor_r_5(PC),A0
                bsr.s   s_darstellung8
                bvs.s   s_darstellung2
                move.w  D1,tabs(A4)
s_darstellung2: lea     editor_r_6(PC),A0
                bsr.s   s_darstellung8
                bvs.s   s_darstellung3
                move.w  D1,tabs+2(A4)
s_darstellung3: lea     editor_r_7(PC),A0
                bsr.s   s_darstellung8
                bvs.s   s_darstellung4
                move.w  D1,tabs+4(A4)
s_darstellung4: lea     editor_r_28(PC),A0
                bsr.s   s_darstellung8
                bvs.s   s_darstellung5
                move.w  D1,tabs+6(A4)
s_darstellung5: lea     editor_r_29(PC),A0
                bsr.s   s_darstellung8
                bvs.s   s_darstellung6
                move.w  D1,tabs+8(A4)
s_darstellung6: moveq   #5,D1
                lea     editor_op(PC),A0
s_darstellung7: moveq   #1,D0
                and.w   (A0),D0
                seq     D0
                and.w   #$20,D0
                move.b  D0,hexlen_flag(A4,D1.w)
                lea     20(A0),A0
                dbra    D1,s_darstellung7
                bsr     redraw_all
                bra     main_loop
s_darstellung8: moveq   #0,D1           ;2-stellige Dezimalzahl holen
                moveq   #0,D0
                move.b  (A0)+,D0
                cmp.b   #' ',D0
                beq.s   s_darstellung9
                subi.b  #'0',D0
                bmi.s   s_darstellung10
                cmp.w   #9,D0
                bhi.s   s_darstellung10
                move.w  D0,D1
s_darstellung9: move.b  (A0)+,D0
                subi.b  #'0',D0
                bmi.s   s_darstellung11
                cmp.w   #9,D0
                bhi.s   s_darstellung11
                mulu    #10,D1
                add.w   D0,D1
                move    #0,CCR
                rts
s_darstellung10:move    #$FF,CCR
s_darstellung11:rts

editor_rsc:     DC.W 0,0,52,17,1
                DC.W 10,15
                DC.L ok_button
                DC.W $26
                DC.W 34,15
                DC.L abbruch_button
                DC.W $24
                DC.W 17,1
                DC.L editor_r_0
                DC.W 8
                DC.W 1,3
                DC.L editor_r_1
                DC.W 8
                DC.W 1,5
                DC.L editor_r_2
                DC.W 8
                DC.W 1,7
                DC.L editor_r_3
                DC.W 8
                DC.W 1,9
                DC.L editor_r_26
                DC.W 8
                DC.W 1,11
                DC.L editor_r_27
                DC.W 8
                DC.W 16,3
                DC.L editor_r_5
                DC.W $A8
                DC.W 16,5
                DC.L editor_r_6
                DC.W $A8
                DC.W 16,7
                DC.L editor_r_7
                DC.W $A8
                DC.W 16,9
                DC.L editor_r_28
                DC.W $A8
                DC.W 16,11
                DC.L editor_r_29
                DC.W $A8
                DC.W 23,3
                DC.L editor_r_8
                DC.W 8
                DC.W 23,5
                DC.L editor_r_9
                DC.W 8
                DC.W 23,7
                DC.L editor_r_10
                DC.W 8
                DC.W 23,9
                DC.L editor_r_22
                DC.W 8
                DC.W 23,11
                DC.L editor_r_11
                DC.W 8
                DC.W 23,13
                DC.L editor_r_23
                DC.W 8
                DC.W 35,3
                DC.L editor_r_12
editor_op:      DC.W $0144
                DC.W 43,3
                DC.L editor_r_16
                DC.W $0144
                DC.W 35,5
                DC.L editor_r_12
                DC.W $0244
                DC.W 43,5
                DC.L editor_r_16
                DC.W $0244
                DC.W 35,7
                DC.L editor_r_12
                DC.W $0344
                DC.W 43,7
                DC.L editor_r_16
                DC.W $0344
                DC.W 35,9
                DC.L editor_r_12
                DC.W $0544
                DC.W 43,9
                DC.L editor_r_16
                DC.W $0544
                DC.W 35,11
                DC.L editor_r_15
                DC.W $0444
                DC.W 43,11
                DC.L editor_r_19
                DC.W $0444
                DC.W 35,13
                DC.L ja_button
                DC.W $0644
                DC.W 43,13
                DC.L nein_button
                DC.W $0644
                DC.W -1

editor_r_5:     DC.B '??',0
editor_r_6:     DC.B '??',0
editor_r_7:     DC.B '??',0
editor_r_28:    DC.B '??',0
editor_r_29:    DC.B '??',0
editor_r_15:    DC.B '  A7  ',0
editor_r_19:    DC.B '  SP   ',0
                SWITCH sprache
                CASE 0
editor_r_0:     DC.B 'Darstellung',0
editor_r_1:     DC.B 'Befehlstab',0
editor_r_2:     DC.B 'Operandentab',0
editor_r_3:     DC.B 'Remarktab',0
editor_r_26:    DC.B 'Pseudooptab',0
editor_r_27:    DC.B 'Pseudo-Remtab',0
editor_r_8:     DC.B 'Opcodes',0
editor_r_9:     DC.B 'Pseudoops',0
editor_r_10:    DC.B 'Register',0
editor_r_11:    DC.B 'Stack',0
editor_r_22:    DC.B 'Hexzahl',0
editor_r_23:    DC.B 'Zahl kürzen',0
editor_r_12:    DC.B ' groß ',0
editor_r_16:    DC.B ' klein ',0
ja_button:      DC.B '  ja  ',0
                CASE 1
editor_r_0:     DC.B 'Representation',0
editor_r_1:     DC.B 'Commandtab',0
editor_r_2:     DC.B 'Operandtab',0
editor_r_3:     DC.B 'Remarktab',0
editor_r_26:    DC.B 'Pseudooptab',0
editor_r_27:    DC.B 'Pseudo-Remtab',0
editor_r_8:     DC.B 'Opcodes',0
editor_r_9:     DC.B 'Pseudoops',0
editor_r_10:    DC.B 'Register',0
editor_r_11:    DC.B 'Stack',0
editor_r_22:    DC.B 'Hexnumber',0
editor_r_23:    DC.B 'cut number',0
editor_r_12:    DC.B ' caps ',0
editor_r_16:    DC.B ' small ',0
ja_button:      DC.B ' yes ',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* New                                                                  *
************************************************************************
                >PART 'fanew'
fanew:          lea     clr_rsc(PC),A0
                jsr     _form_do
                bmi     main_loop
                subq.w  #2,D0
                beq     main_loop
                bsr.s   s_new
                lea     fname_src(A4),A0
                move.l  #'NONA',(A0)+
                move.l  #'ME.S',(A0)+
                move.w  #'RC',(A0)+
                clr.b   (A0)+
                bsr     s_copy_name
                bsr     s_copy_namec
                moveq   #0,D0
                jsr     error_out
                bra     main_loop
                ENDPART
                >PART 's_new'
s_new:          clr.l   save_prot(A4)   ;Passwort löschen
                clr.l   save_prot+4(A4)
                clr.l   save_date(A4)   ;Erstellungsdatum ist nicht korrekt
                st      default_but(A4) ;kein Default-Button mehr
                moveq   #0,D6
                clr.b   change_flag(A4)
                moveq   #$FF,D0
                move.l  D0,block_anf(A4)
                moveq   #12,D1
                lea     marker(A4),A0
s_new2:         move.w  D0,(A0)+
                dbra    D1,s_new2
                moveq   #63,D0
                lea     undo_buff(A4),A0
s_new1:         clr.l   (A0)+
                dbra    D0,s_new1
                clr.w   scr_z(A4)
                clr.w   save_pos(A4)
                jsr     print_top
                move.l  program_top(A4),D0
                movea.l program_base(A4),A6
                move.l  A6,program_top(A4)
                movea.l A6,A0
                sub.l   A0,D0
                lsr.l   #2,D0
                bcc.s   s_new7
                clr.w   (A0)+
s_new7:         clr.l   (A0)+
                dbra    D0,s_new7
                movea.l z_info_base(A4),A5
                move.l  A5,z_info_top(A4)
                movea.l A5,A0
                move.w  anz_zeilen(A4),D0
                bra.s   s_new5
s_new6:         clr.l   (A0)+
                clr.l   (A0)+           ;10 Bytes löschen
                clr.w   (A0)+
s_new5:         dbra    D0,s_new6
                move.w  D0,(A5)         ;D0=$FFFF
                move.w  D0,6(A5)
                clr.w   8(A5)
                clr.w   anz_zeilen(A4)
                movea.l comment_base(A4),A3
                move.l  A3,comment_top(A4)
                movea.l label_base(A4),A0
                move.l  A0,label_top(A4)
                move.w  label_top_ind(A4),D0
                bra.s   s_new3
s_new4:         clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+           ;32 Bytes löschen
                clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+
s_new3:         dbra    D0,s_new4
                clr.w   label_top_ind(A4)
                clr.w   top_line(A4)
                clr.l   err_count(A4)
                clr.l   partbuffer(A4)
                clr.l   partbuffer-4(A4)
                move.b  #' ',last_char(A4)
                movem.l A3/A5-A6,top_ptr(A4)
                bra     redraw_all

clr_rsc:        DC.W 0,0,25,6,1
                DC.W 1,1
                DC.L ask_icn
                DC.W $3303
                DC.W 7,1
                DC.L clr_1
                DC.W 8
                DC.W 7,4
                DC.L clr_2
                DC.W $24
                SWITCH sprache
                CASE 0
                DC.W 17,4
                CASE 1
                DC.W 16,4
                ENDS
                DC.L clr_3
                DC.W $26
                DC.W -1

                SWITCH sprache
                CASE 0
clr_1:          DC.B 'Programm löschen?',0
clr_2:          DC.B '  JA  ',0
clr_3:          DC.B ' NEIN ',0
                CASE 1
clr_1:          DC.B 'Clear program?',0
clr_2:          DC.B ' YES ',0
clr_3:          DC.B '  NO  ',0
                ENDS
                EVEN
                ENDPART
                >PART 'ask_icn'
ask_icn:        DC.L $3FFFFFFC,-$3FFFFFFD,-$60000007,-$40000003,-$2007C005
                DC.L $5FE00FFA,$6FC007F6,$2F8383F4,$3787C3EC,$1787C3E8
                DC.L $1BFF83D8,$0BFF07D0,$0DFE0FB0,$05FC1FA0,$06FC3F60
                DC.L $02FC3F40,$037C3EC0,$017C3E80,$01BFFD80,$BFFD00
                DC.L $DC3B00,$5C3A00,$6C3600,$2FF400,$37EC00
                DC.L $17E800,$1BD800,$0BD000,$0DB000,$05A000
                DC.L $066000,$03C000
                ENDPART
                >PART 'stop_icn'
stop_icn:       DC.L $7FFE00,$C00300,$01BFFD80,$037FFEC0,$06FFFF60
                DC.L $0DFFFFB0,$1BFFFFD8,$37FFFFEC,$6FFFFFF6,-$20000005
                DC.L -$4E7E79F3,-$5F7EFDFB,-$5B18CD9B,-$5818CD9B,-$5C18CD9B
                DC.L -$4E18CDFB,-$4718CDF3,-$4318CD83,-$5B18CD83,-$5F18FD83
                DC.L -$4E187983,-$40000003,-$20000005,$6FFFFFF6,$37FFFFEC
                DC.L $1BFFFFD8,$0DFFFFB0,$06FFFF60,$037FFEC0,$01BFFD80
                DC.L $C00300,$7FFE00
                ENDPART
************************************************************************
* Menüpunkt 'Rechner'                                                  *
************************************************************************
                >PART 's_calculator'
s_calc:         ori.w   #$10,s_negxx    ;negieren disablen
                lea     rechner_rsc(PC),A0
                andi.b  #$7F,8(A0)
s_calc1:        jsr     _form_do
                ori.b   #$80,8(A0)      ;Redraw ohne Löschen
                tst.w   D0
                bmi     s_editor_212
                cmp.w   #1,D0
                beq     s_calc8
                cmp.w   #3,D0
                beq     s_editor_212    ;ABBRUCH
                cmp.w   #4,D0
                beq.s   s_calc7         ;negieren
                lea     rechner_0(PC),A0
                cmp.w   #2,D0
                beq.s   s_calc2         ;Formel übernehmen
                lea     rechner_4(PC),A0
                subq.w  #6,D0
                bmi.s   s_calc2         ;Dez
                lea     rechner_5(PC),A0
                beq.s   s_calc2         ;Hex
                lea     rechner_6(PC),A0 ;Bin
s_calc2:        move.w  s_zeile(A4),D0
                subq.w  #menu_offset,D0
                cmp.w   scr_z(A4),D0
                bne.s   s_calc5         ;Zeile stimmt nicht
                cmp.w   s_spalte(A4),D2
                bne.s   s_calc5         ;Spalte stimmt nicht
                move.w  block_pointer(A4),D2 ;Position zum Löschen setzen
                move.w  block_pointer+2(A4),D0 ;Länge der alten Formel
                sub.w   D0,D3           ;von der Zeilenlänge abziehen
                move.w  D2,D7
                add.w   D0,D7           ;zweite Spaltenposition
                move.w  D2,D0           ;ak. Spalte
s_calc3:        move.b  0(A1,D7.w),0(A1,D0.w) ;umkopieren
                addq.w  #1,D7
                addq.w  #1,D0
                cmp.w   #255,D7
                blt.s   s_calc3
s_calc4:        clr.b   0(A1,D0.w)
                addq.w  #1,D0           ;Rest des Buffers löschen
                cmp.w   #255,D0
                blt.s   s_calc4
                moveq   #0,D0
s_calc5:        move.b  (A0)+,D0        ;String in Sourcetext kopieren
                beq.s   s_calc6
                cmp.b   #' ',D0
                beq.s   s_calc5
                bsr     zset_char2
                bra.s   s_calc5
s_calc6:        st      action_fl(A4)   ;es wurde was verändert
                bra     s_editor_212
s_calc7:        movem.l D1-D4/A1,-(SP)
                lea     rechner_4(PC),A0
                moveq   #' ',D0
                move.b  D0,(A0)
                move.b  D0,rechner_5-rechner_4(A0)
                move.b  D0,rechner_6-rechner_4(A0)
                bra.s   s_calc13
s_calc8:        lea     rechner_0(PC),A0
                bsr     get_term        ;Ausdruck ausrechnen
                bpl.s   s_calc12
                moveq   #' ',D0
                lea     rechner_4(PC),A0
                bsr.s   s_calc10
                lea     rechner_5(PC),A0
                bsr.s   s_calc10        ;alle 3 Ergebnisse löschen
                lea     rechner_6(PC),A0
                bsr.s   s_calc10
                lea     rechner_4(PC),A0
                lea     rechner_err(PC),A1
s_calc9:        move.b  (A1)+,(A0)+     ;Fehlermeldung kopieren
                bne.s   s_calc9
                move.b  D0,-(A0)
                ori.w   #$10,s_negxx    ;negieren disablen
                bra.s   s_calc16
s_calc10:       tst.b   (A0)
                beq.s   s_calc11
                move.b  D0,(A0)+
                bra.s   s_calc10
s_calc11:       rts
s_calc12:       andi.w  #$FFEF,s_negxx  ;negiert enablen
                movem.l D1-D4/A1,-(SP)
                moveq   #' ',D0
                tst.l   D1              ;ist das Ergebnis negativ?
                bpl.s   s_calc13        ;Nein! =>
                moveq   #'-',D0
                neg.l   D1              ;sonst ein negatives Vorzeichen davor
s_calc13:       lea     rechner_5(PC),A0
                move.b  D0,(A0)+
                move.b  #'$',(A0)
                lea     rechner_6(PC),A0
                move.b  D0,(A0)+
                move.b  #'%',(A0)
                lea     rechner_4(PC),A0
                move.b  #' ',(A0)+      ;negatives Vorzeichen löschen
                moveq   #9,D4
                st      testwrd(A4)
                jsr     dezw_out        ;Dezimalzahl ausgeben
                sf      testwrd(A4)
                cmp.b   #'-',D0         ;negatives Zahl?
                bne.s   s_calc15        ;Nein! =>
                lea     rechner_4+10(PC),A0
s_calc14:       cmpi.b  #' ',-(A0)
                bne.s   s_calc14        ;das negative Vorzeichen vor die Zahl
                move.b  D0,(A0)
s_calc15:       lea     rechner_5+2(PC),A0
                bsr     hexl_out        ;Hexzahl ausgeben
                lea     rechner_6+2(PC),A0
                bsr     binl_out        ;Binärzahl ausgeben
                movem.l (SP)+,D1-D4/A1
s_calc16:       lea     rechner_rsc(PC),A0
                bra     s_calc1

rechner_rsc:    DC.W 0,0,69,9,1
                DC.W 1,1        ;Die Formel
                DC.L rechner_0
                DC.W $88
                DC.W 3,3        ;Dezimal-Ergebnis
                DC.L rechner_4
                DC.W 8
                DC.W 4,5        ;Hex-Ergebnis
                DC.L rechner_5
                DC.W 8
                DC.W 4,7        ;Binär-Ergebnis
                DC.L rechner_6
                DC.W 8
                DC.W 17,3       ;ausrechnen
                DC.L rechner_7
                DC.W $26
                DC.W 39,7       ;Formel übernehmen
                DC.L rechner_8
                DC.W $24
                DC.W 60,7       ;Ende
                DC.L rechner_9
                DC.W $24
                DC.W 17,5       ;negiert anzeigen
                DC.L rechner_10
s_negxx:        DC.W $24

;Übernahme-Buttons für das Ergebnis
                DC.W 1,3        ;Dez übernehmen
                DC.L rechner_14
                DC.W $24
                DC.W 1,5        ;Hex übernehmen
                DC.L rechner_14
                DC.W $24
                DC.W 1,7        ;Bin übernehmen
                DC.L rechner_14
                DC.W $24

;zusätzliche Texte
                DC.W 37,3
                DC.L rechner_11
                DC.W 8
                DC.W 52,4
                DC.L rechner_12
                DC.W 8
                DC.W 37,5
                DC.L rechner_13
                DC.W 8
                DC.W -1

rechner_0:      DC.B '                                                                   ',0,0
rechner_4:      DC.B '           ',0
rechner_5:      DC.B ' $        ',0
rechner_6:      DC.B ' %                                ',0
rechner_14:     DC.B '',0
rechner_12:     DC.B '<< >> % ( )',0
                SWITCH sprache
                CASE 0
rechner_7:      DC.B ' ausrechnen ',0
rechner_8:      DC.B ' Formel übernehmen ',0
rechner_9:      DC.B '  ENDE  ',0
rechner_10:     DC.B ' ohne Vorzeichen ',0
rechner_11:     DC.B 'Rechenzeichen: + - * / & | ^',0
rechner_13:     DC.B 'Vorzeichen   : + - ! ~',0
rechner_err:    DC.B '  *FEHLER*',0
                CASE 1
rechner_7:      DC.B ' calculate ',0
rechner_8:      DC.B ' transfer formula ',0
rechner_9:      DC.B '  EXIT  ',0
rechner_10:     DC.B ' without sign ',0
rechner_11:     DC.B 'Operations: + - * / & | ^',0
rechner_13:     DC.B 'Signs     : + - ! ~',0
rechner_err:    DC.B '  *ERROR*',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Zahlenausgaberoutinen für Rechner                                    *
************************************************************************
                >PART 'hexl_out'
hexl_out:       lea     hexl_out5(PC),A1
                moveq   #0,D0
                swap    D1
                bsr.s   hexl_out2
                swap    D1
hexl_out2:      rol.w   #8,D1
                bsr.s   hexl_out3
                rol.w   #8,D1
hexl_out3:      move.b  D1,D0
                lsr.b   #4,D0
                move.b  0(A1,D0.w),(A0)+
                moveq   #15,D0
                and.b   D1,D0
                move.b  0(A1,D0.w),(A0)+
                rts
hexl_out5:      DC.B '0123456789ABCDEF'
                EVEN
                ENDPART
                >PART 'binl_out'
binl_out:       move.l  D1,-(SP)
                moveq   #31,D0
binl_out2:      moveq   #'0'/2,D2
                roxl.l  #1,D1
                addx.b  D2,D2
                move.b  D2,(A0)+
                dbra    D0,binl_out2
                move.l  (SP)+,D1
                rts
                ENDPART
************************************************************************
* Liest ein Zeichen nach D0 (Überlesen von Spaces, ...)                *
************************************************************************
                >PART 'w_get'
w_get:          moveq   #0,D0
                move.b  (A0)+,D0        ;Zeichen holen
                beq.s   w_get2
                cmp.b   #' ',D0         ;Spaces werden überlesen
                beq.s   w_get
                cmp.b   #'a',D0
                blo.s   w_get1          ;kein Kleinbuchstabe
                cmp.b   #'z'+1,D0
                bhs.s   w_get1          ;kein Kleinbuchstabe
                bclr    #5,D0
w_get1:         tst.b   D0
                rts
w_get2:         moveq   #0,D0
                subq.l  #1,A0           ;Ändert ja keine Flags
                rts
                ENDPART
************************************************************************
* Liegt D0 im Zahlensystem D2 ?                                        *
************************************************************************
                >PART 'w_chkval'
w_chkval:       sub.b   #'0',D0         ;prüft d0 auf Gültigkeit im Zahlensystem d2
                cmp.b   #10,D0          ;kleiner 10?
                blo.s   w_chkval0       ;ja,ok
                subq.b  #7,D0           ;nein, 7 weg
                cmp.b   #10,D0          ;jetzt kleiner 10?
                blo.s   w_chkval1       ;ja, Fehler, Carry löschen
w_chkval0:      cmp.b   D2,D0           ;vergleichen mit Zahlenbasis
                bhs.s   w_chkval1
                rts
w_chkval1:      add.b   #$37,D0         ;restaurieren, da keine zahl
                move    #0,CCR
                rts
                ENDPART
************************************************************************
* Zahlenbasis gemäß des Zahlenbasiszeichens (in D0) nach D3 holen      *
************************************************************************
                >PART 'w_numbas'
w_numbas:       moveq   #3,D3           ;wenn das Zeichen in d0 ein Zahlbasiszeichen
w_numbas1:      cmp.b   w_numtab(PC,D3.w),D0 ;ist, Rückkehr mit der Zahlenbasis in d3
                dbeq    D3,w_numbas1    ;sonst negative=1
                tst.w   D3
                bmi.s   w_numbas2
                move.b  w_numtab1(PC,D3.w),D3
w_numbas2:      rts
                DC.B '›'
w_numtab:       DC.B '%@.$'
w_numtab1:      DC.B 2,8,10,16
                EVEN
                ENDPART
************************************************************************
* LONG-Division      : D2=D2/D1  D1=D2 MOD D1                          *
************************************************************************
                >PART 'w_ldiv'
w_ldiv:         movem.l D0/D3-D4,-(SP)
                tst.l   D1
                beq     w_err
                exg     D1,D2
                clr.w   D4
                tst.l   D1
                bge.s   w_ldiv1
                addq.w  #3,D4
                neg.l   D1
w_ldiv1:        tst.l   D2
                bge.s   w_ldiv2
                addq.w  #1,D4
                neg.l   D2
w_ldiv2:        moveq   #1,D3
w_ldiv4:        cmp.l   D1,D2
                bhs.s   w_ldiv3
                add.l   D2,D2
                add.l   D3,D3
                bra.s   w_ldiv4
w_ldiv3:        moveq   #0,D0
w_ldiv6:        cmp.l   D1,D2
                bhi.s   w_ldiv5
                or.l    D3,D0
                sub.l   D2,D1
w_ldiv5:        lsr.l   #1,D2
                lsr.l   #1,D3
                bcc.s   w_ldiv6
                cmp.w   #3,D4
                blt.s   w_ldiv7
                neg.l   D1
w_ldiv7:        lsr.l   #1,D4
                bcc.s   w_ldiv8
                neg.l   D0
w_ldiv8:        move.l  D0,D2
                movem.l (SP)+,D0/D3-D4
                rts
                ENDPART
************************************************************************
* Ausdruck auswerten, Ergebnis nach D1                                 *
* D0<0 => Fehler aufgetreten                                           *
************************************************************************
                >PART 'get_term'
get_term:       movem.l D2-A6,-(SP)
                movea.l SP,A6           ;falls ein Fehler auftritt!
                lea     rechner_0(PC),A0 ;Zeiger auf die Formel
                bsr     w_get           ;1.Zeichen holen
                bsr.s   w_a             ;Formel ausrechnen
                tst.w   D0
                bne     w_err           ;Formel mit illegalem Zeichen beendet
                movem.l (SP)+,D2-A6
                rts

w_a:            move.l  D2,-(SP)
                bsr     w_eausd
                move.l  D1,D2
w_al:           cmp.b   #'+',D0         ;Addition
                bne.s   w_a1
                bsr     w_get
                bsr.s   w_eausd
                add.l   D1,D2
                bvs     w_err
                bra.s   w_al
w_a1:           cmp.b   #'-',D0         ;Subtraktion
                bne.s   w_a2
                bsr     w_get
                bsr.s   w_eausd
                sub.l   D1,D2
                bvs     w_err
                bra.s   w_al
w_a2:           cmp.b   #'|',D0         ;OR
                bne.s   w_a3
                bsr     w_get
                bsr.s   w_eausd
                or.l    D1,D2
                bra.s   w_al
w_a3:           cmp.b   #'^',D0         ;EOR
                bne.s   w_a4
                bsr     w_get
                bsr.s   w_eausd
                eor.l   D1,D2
                bra.s   w_al
w_a4:           cmp.b   #'<',D0         ;SHL
                bne.s   w_a5
                cmpi.b  #'<',(A0)
                bne.s   w_a5
                addq.l  #1,A0
                bsr     w_get
                bsr.s   w_eausd
                lsl.l   D1,D2
                bra.s   w_al
w_a5:           cmp.b   #'>',D0         ;SHR
                bne.s   w_aend
                cmpi.b  #'>',(A0)
                bne.s   w_aend
                addq.l  #1,A0
                bsr     w_get
                bsr.s   w_eausd
                lsr.l   D1,D2
                bra.s   w_al
w_aend:         move.l  D2,D1
                move.l  (SP)+,D2
                rts

w_eausd:        move.l  D2,-(SP)
                bsr.s   w_term
                move.l  D1,D2
w_eal:          cmp.b   #'*',D0         ;Multiplikation
                bne.s   w_ea1
                bsr     w_get
                bsr.s   w_term
                bsr     lmult           ;D2=D1*D2
                bra.s   w_eal
w_ea1:          cmp.b   #'/',D0         ;Division
                bne.s   w_ea2
                bsr     w_get
                bsr.s   w_term
                bsr     w_ldiv          ;D2.L = D2.L/D1.L
                bra.s   w_eal
w_ea2:          cmp.b   #'&',D0         ;AND
                bne.s   w_ea3
                bsr     w_get
                bsr.s   w_term
                and.l   D1,D2
                bra.s   w_eal
w_ea3:          cmp.b   #'%',D0         ;MODULO
                bne.s   w_eaend
                bsr     w_get
                bsr.s   w_term
                bsr     w_ldiv          ;D1.L = D2 MOD D1
                move.l  D1,D2
                bra.s   w_eal
w_eaend:        move.l  D2,D1
                move.l  (SP)+,D2
                rts

w_term:         cmp.b   #'!',D0         ;Logical NOT
                bne.s   w_term0
                bsr     w_get
                bsr.s   w_term0
                tst.l   D1
                beq.s   w_term4
                moveq   #0,D1
                rts
w_term4:        moveq   #1,D1
                rts
w_term0:        cmp.b   #'~',D0         ;NOT
                bne.s   w_term1
                bsr     w_get
                bsr.s   w_term1
                not.l   D1
                rts
w_term1:        cmp.b   #'-',D0
                beq.s   w_term3
                cmp.b   #'+',D0
                bne.s   w_term2
                bsr     w_get           ;Positives Vorzeichen überlesen
w_term2:        bsr.s   w_fakt
                rts
w_term3:        bsr     w_get           ;Negatives Vorzeichen
                bsr.s   w_fakt
                neg.l   D1
                rts

w_fakt:         move.l  D2,-(SP)
                cmp.b   #'(',D0
                beq.s   w_fakt1
                bsr.s   w_get_zahl      ;Zahl nach D1 holen
                move.l  (SP)+,D2
                rts
w_fakt1:        bsr     w_get           ;Klammer überlesen
                bsr     w_a             ;Ausdruck in der Klammer auswerten
                cmp.b   #')',D0
                bne.s   w_err           ;Klammer zu muß folgen
                bsr     w_get
                move.l  (SP)+,D2
                rts
w_err:          movea.l A6,SP           ;Stack korrigieren
                moveq   #0,D1           ;0 als Ergebnis liefern
                moveq   #-1,D0          ;als Fehlerkennung
                movem.l (SP)+,D2-A6
                rts
                ENDPART
************************************************************************
* Zahl nach D1.L holen                                                 *
************************************************************************
                >PART 'w_get_zahl'
w_get_zahl:     movem.l D2-D7/A1-A6,-(SP)
                cmp.b   #$27,D0         ;ASCII-String?
                beq.s   w_zahll
                cmp.b   #$22,D0         ;ASCII-String?
                beq.s   w_zahll
                moveq   #10,D2          ;Dezimal ist Default
                bsr     w_numbas        ;?Zahlenbasiszeichen
                bmi.s   w_zahli         ;nein
                move.w  D3,D2           ;ja, neue Zahlenbasis setzen
                bsr     w_get           ;und nächstes Zeichen
                bsr     w_chkval        ;lfd. zeichen gültig?
                bcs.s   w_zahli1        ;ja!
                subq.l  #1,A0
                bra.s   w_zahlo
w_zahli:        bsr     w_chkval        ;lfd. zeichen gültig?
                bcc.s   w_zahlo         ;nein, Fehler (evtl. Label?)
w_zahli1:       moveq   #0,D1           ;Vorbesetzung von D1
w_zahlj:        move.l  D1,D3           ;D1.L * D2.B = D1.L
                swap    D3
                mulu    D2,D3
                mulu    D2,D1
                swap    D3
                tst.w   D3
                bne.s   w_err
                add.l   D3,D1
                bcs.s   w_err
                add.l   D0,D1           ;und addieren der Stelle
                bcs.s   w_err
                bsr     w_get           ;nächste Stelle
                bsr     w_chkval        ;gültig?
                bcs.s   w_zahlj         ;ja, weiter
w_zahlk:        movem.l (SP)+,D2-D7/A1-A6
                rts
w_zahll:        moveq   #0,D1
w_zahlm:        cmp.b   (A0)+,D0        ;Zeichen gleich dem Anfangszeichen ' oder ` ?
                beq.s   w_zahln         ;ja, fertig
                rol.l   #8,D1           ;Ergebnisregister 8 bit nach links shiften
                tst.b   D1              ;waren die höchsten 8bit schon belegt?
                bne.s   w_err           ;ja, mehr als 4 byte ASCII, Error
                move.b  -1(A0),D1
                beq.s   w_zahlz         ;null, Ende der Datei
                cmp.b   #13,D1          ;CR beendet ASCII
                bne.s   w_zahlm
w_zahlz:        subq.l  #1,A0           ;wieder eins abziehen,damit w_get 0 bzw. CR holt
                lsr.l   #8,D1
w_zahln:        bsr     w_get
                bra.s   w_zahlk         ;alles OK, Ende

w_zahlo:        subq.l  #1,A0
                bsr     search_label    ;Symbol suchen
                tst.w   D0
                bmi     w_err           ;nicht gefunden
                move.l  (A1),D1         ;Wert holen
                bsr     w_get
                bra.s   w_zahlk         ;alles OK
                ENDPART
************************************************************************
* benennt ein File in ein .BAK-File um                                 *
************************************************************************
                >PART 's_rename_file'
s_rename_file:  movem.l D0/A0-A2,-(SP)
                lea     spaced(A4),A1
                movea.l A0,A2
                move.l  A1,-(SP)        ;Adresse des BAK-Filenames
                move.l  (A0)+,(A1)
                move.l  (A0)+,4(A1)     ;Filenamen kopieren
                move.l  (A0)+,8(A1)
                move.w  (A0),12(A1)
s_rename_file2: tst.b   (A1)
                beq.s   s_rename_file3
                cmpi.b  #'.',(A1)+
                bne.s   s_rename_file2
                subq.l  #1,A1
s_rename_file3: move.b  #'.',(A1)+
                move.b  #'B',(A1)+      ;und .BAK anhängen
                move.b  #'A',(A1)+
                move.b  #'K',(A1)+
                clr.b   (A1)

                move.w  #$41,-(SP)      ;Fdelete (fname.BAK!)
                jsr     do_trap_1
                addq.l  #2,SP

                move.l  A2,-(SP)        ;alter Filename
                move.l  #$560000,-(SP)  ;Frename
                jsr     do_trap_1
                lea     12(SP),SP
                movem.l (SP)+,D0/A0-A2
                rts
                ENDPART
************************************************************************
* testet ob File schon existiert, und löscht es gegebenenfalls         *
* A0=Zeiger auf Filename                                               *
************************************************************************
                >PART 's_write_file'
s_write_file:   move.w  #7,-(SP)
                move.l  A0,-(SP)
                move.w  #$4E,-(SP)
                jsr     do_trap_1       ;Fsfirst
                addq.w  #8,SP
                tst.w   D0
                bmi.s   s_write_file2   ;existiert nicht
                btst    #3,editor3_flag(A4) ;soll Alert erscheinen?
                beq.s   s_write_file1   ;nein, dann überschreiben
                moveq   #0,D0
                jsr     _graf_mouse
                move.l  A0,-(SP)
                lea     s_write_rsc(PC),A0
                jsr     _form_do
                movea.l (SP)+,A0
                move.w  D0,-(SP)
                moveq   #1,D0
                jsr     _graf_mouse
                move.w  (SP)+,D0
                subq.w  #2,D0
                bmi.s   returnx         ;Abbruch
s_write_file1:  move.l  A0,-(SP)
                move.w  #$41,-(SP)
                jsr     do_trap_1       ;Fdelete
                addq.l  #6,SP
s_write_file2:  move    #0,CCR          ;kein Abbruch
returnx:        rts

s_write_rsc:    DC.W 0,0,33,7,1
                DC.W 7,2
                DC.L write_r_0
                DC.W 8
                DC.W 20,5
                DC.L abbruch_button
                DC.W $24
                DC.W 3,5
                DC.L write_r_1
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1

                SWITCH sprache
                CASE 0
write_r_0:      DC.B 'File existiert bereits!',0
write_r_1:      DC.B ' ÜBERSCHREIBEN ',0
                CASE 1
write_r_0:      DC.B 'File already exists!',0
write_r_1:      DC.B ' OVERWRITE ',0
                ENDS
                EVEN
                ENDPART
                >PART '_fsel_input'
************************************************************************
* Fileselector ausgeben - D7 = Button                                  *
* ->A0:Adresse des Pfads                                               *
* ->A1:Adresse des Filenamens                                          *
* ->D0:Extension für Pfad (wenn 0, keine Änderung)                     *
************************************************************************
_fsel_input:    movem.l D0-D6/A0-A6,-(SP)
                move.l  A2,addrin+8(A4) ;Label für den erweiterten File Selector
                lea     fpath_sel(A4),A2
                move.l  A2,addrin(A4)   ;Adresse des Pfadnamen
                moveq   #31,D1          ;128 Bytes
fsel0:          move.l  (A0)+,(A2)+     ;Pfad kopieren
                dbra    D1,fsel0
                lea     fname_sel(A4),A2
                move.l  A2,addrin+4(A4) ;Filenamenadr
                moveq   #4,D1           ;20 Bytes
fsel00:         move.l  (A1)+,(A2)+     ;Namen kopieren
                dbra    D1,fsel00
                lea     fname_sel(A4),A0
fsel1:          move.b  (A0)+,D1        ;Zeichen holen
                beq.s   fsel10          ;keine Extension
                cmp.b   #'.',D1
                bne.s   fsel1
                tst.l   D0              ;eine (positive!) Extension vorgegeben?
                bgt.s   fsel19          ;Ja! =>
fsel17:         lea     fpath_sel(A4),A1 ;Name hat eine Extension
fsel11:         tst.b   (A1)+           ;Ende des Pfads suchen
                bne.s   fsel11
                subq.w  #1,A1
fsel12:         move.b  -(A1),D1        ;rückwärts gehen
                cmp.b   #'.',D1
                beq.s   fsel13          ;Extension gefunden
                cmp.b   #'\',D1
                beq.s   fsel14          ;Ende des Pfadnamens
                cmp.b   #':',D1         ;Drivekennung
                bne.s   fsel12
                addq.w  #1,A1
fsel14:         move.b  #'\',(A1)+
                move.b  #'*',(A1)+
fsel13:         move.b  #'.',(A1)+
fsel15:         move.b  (A0)+,(A1)+     ;Extension aus Namen übertragen
                bne.s   fsel15
                bra.s   fsel8
fsel10:         bclr    #31,D0          ;Vorzeichen-Bit löschen
                tst.l   D0
                beq.s   fsel16          ;keine Extension vorgegeben
fsel19:         move.b  #'.',-1(A0)
                move.b  D0,(A0)
                lsr.l   #8,D0
                move.b  D0,1(A0)        ;Extension aus Datenregister
                lsr.w   #8,D0           ;an Filenamen anhängen
                move.b  D0,2(A0)
                clr.b   3(A0)
                bra.s   fsel17          ;Extension noch in Pfad übernehmen
fsel16:         lea     fsel18(PC),A0   ;Extension = *
                bra.s   fsel17
fsel18:         DC.B '*',0

fsel8:          bsr     switch_org_drv  ;Originaltreiber rein

                movea.l addrin(A4),A0
                moveq   #0,D0
                move.b  (A0)+,D0
                cmpi.b  #':',(A0)       ;Laufwerkskennung?
                bne.s   fsel81
                sub.b   #'A',D0
                jsr     do_mediach_d0   ;Media-Change auf Laufwerk D0
                bra.s   fsel82
fsel81:         jsr     do_mediach      ;Media-Change wenn nötig
fsel82:
                move.l  #$0A000100,D0
                jsr     aes             ;appl_init()

                jsr     waitaes

                clr.w   intin(A4)
                move.l  #$4E010101,D0
                jsr     aes             ;graf_mouse(Arrow)

                move.l  #$5A000202,D0   ;Default ist die alte TOS-Version
                move.w  global(A4),D1   ;AES-Versionsnummer holen
                cmp.w   #$0140,D1
                blo.s   tos_alt         ;noch kein TOS 1.4 =>
                cmp.w   #$0200,D1
                bhs.s   tos_alt         ;GEM 2.2 hat kein fsel_exinput() =>
                move.l  #$5B000203,D0   ;erweiterten File Selector
tos_alt:        lea     $0404.w,A2
                movea.l (A2),A3
                move.l  save_data+$0404-8(A4),(A2)
                jsr     aes             ;Fileselector aufrufen
                move.l  A3,(A2)
                move.w  intout+2(A4),D7 ;Exit-Button

                jsr     waitaes

                move.l  #$13000101,D0
                jsr     aes             ;appl_exit()

                bsr     switch_my_drv   ;und die eigenen Treiber wieder rein
                movem.l (SP)+,D0-D6/A0-A6
                movea.l addrin+4(A4),A2
                tst.b   (A2)
                bne.s   fsel9
                moveq   #0,D7           ;Kein Filename => ABBRUCH
fsel9:          tst.w   D7
                beq.s   fsel51          ;bei Abbruch Pfad nicht neu setzen
                lea     fname_sel(A4),A2
                moveq   #4,D0           ;20 Bytes
fsel91:         move.l  (A2)+,(A1)+     ;Filename zurückkopieren
                dbra    D0,fsel91
                lea     fpath_sel(A4),A2
                movea.l A0,A1
                moveq   #31,D0          ;128 Bytes
fsel92:         move.l  (A2)+,(A1)+     ;Pfadnamen zurückkopieren
                dbra    D0,fsel92
                movea.l A0,A1           ;Adresse des Pfadnamens
fsel2:          tst.b   (A0)+           ;Ende des Pfadnamen suchen
                bne.s   fsel2
fsel3:          cmpi.b  #'\',-(A0)
                bne.s   fsel3
                addq.l  #1,A0
                move.b  (A0),D1
                clr.b   (A0)            ;Extension löschen
                cmpi.b  #':',1(A1)      ;Drivekennung
                bne.s   fsel4           ;nein
                moveq   #0,D0
                move.b  (A1),D0         ;Buchstaben holen
                sub.w   #'A',D0
                move.w  D0,-(SP)
                move.w  #$0E,-(SP)      ;Dsetdrv()
                jsr     do_trap_1
                addq.l  #4,SP
                jsr     do_mediach      ;Media-Change wenn nötig
                tst.l   D0
                bmi.s   fsel5           ;Fehler in Drivenummer
                addq.l  #2,A1
fsel4:          jsr     do_mediach      ;Media-Change wenn nötig
                move.l  A1,-(SP)        ;Zeiger Pfadnamen
                move.w  #$3B,-(SP)
                jsr     do_trap_1       ;Dsetpath()
                addq.l  #6,SP
fsel5:          move.b  D1,(A0)         ;Nullbyte wieder entfernen
                tst.l   D0
fsel51:         rts
                ENDPART
                >PART 'switch_my_drv'
switch_my_drv:  movem.l D0-A6,-(SP)
                jsr     my_driver
                bsr     redraw_complete
                movem.l (SP)+,D0-A6
                rts
                ENDPART
                >PART 'switch_org_drv'
switch_org_drv: movem.l D0-A6,-(SP)
                jsr     org_driver
                movem.l (SP)+,D0-A6
                rts
                ENDPART
                >PART 'clr_cache'
clr_cache:      movem.l D0/A0/A4-A6,-(SP)
                move    SR,-(SP)
                movea.l SP,A6           ;SP retten
                lea     $10.w,A5
                movea.l (A5),A4         ;Illegal-Vektor retten
                lea     clr_cache1(PC),A0
                move.l  A0,(A5)         ;neuen einsetzen
                ori     #$0700,SR
                DC.L $4E7A0002  ;MOVE CACR,D0
                or.w    #$0808,D0       ;Cache löschen
                DC.L $4E7B0002  ;MOVE D0,CACR
clr_cache1:     move.l  A4,(A5)         ;Illegal-Vektor zurück
                movea.l A6,SP           ;SP zurück
                move    (SP)+,SR
                movem.l (SP)+,D0/A0/A4-A6
                rts
                ENDPART
                >PART 'a_append_end'
************************************************************************
* Leerzeilen am Sourcetextende entfernen und END anhängen              *
************************************************************************
s_append_end:   movem.l D0-D1/A0,-(SP)
                movea.l z_info_top(A4),A0 ;Zeiger auf Ende
                move.w  anz_zeilen(A4),D0
                moveq   #0,D1
                move.w  #$1200,D1       ;Code für END
s_append_end1:  lea     -10(A0),A0      ;eine Zeile nach oben
                subq.w  #1,D0
                beq.s   s_append_end2   ;keine Zeilen mehr da
                tst.l   (A0)            ;Leerzeile?
                bne.s   s_append_end2   ;nein
                tst.w   6(A0)           ;Symboldefinition?
                bpl.s   s_append_end2   ;ja -> keine Leerzeile
                tst.b   9(A0)           ;Remark da?
                beq.s   s_append_end1   ;nein -> Leerzeile
s_append_end2:  cmp.w   2(A0),D1        ;END-Befehl?
                beq.s   s_append_end4   ;ja
                lea     10(A0),A0       ;eine Zeile weiter
                addq.w  #2,D0
                move.l  D1,(A0)+        ;END einsetzen
                move.l  #$FFFF,(A0)+    ;keine Symboldef
                clr.w   (A0)+           ;Fehlernr und Remark
s_append_end3:  move.l  A0,z_info_top(A4) ;Zeiger wieder merken
                move.w  D0,anz_zeilen(A4) ;Anzahl wieder merken
                move.l  #$FFFF0000,(A0)+ ;Endekennung setzen
                move.l  #$FFFF,(A0)+
                clr.w   (A0)
                movem.l (SP)+,D0-D1/A0
                rts
s_append_end4:  lea     10(A0),A0       ;eine Zeile weiter
                addq.w  #1,D0
                bra.s   s_append_end3
                ENDPART
                >PART 's_init_errtab'
s_init_errtab:  movem.l D0-D2/A0-A1,-(SP)
                lea     err_tab(PC),A0  ;Zeiger auf Flagtabelle
                lea     s_initerr(PC),A1 ;Zeiger auf Tabelle
                move.w  optim_flag(A4),D1 ;Bits vom Dialog
                moveq   #0,D2
s_initerr3:     btst    D2,D1           ;Button testen
                bne.s   s_initerr11     ;Button selektiert
s_initerr1:     move.w  (A1)+,D0        ;Fehlernummer holen
                beq.s   s_initerr2      ;Ende der Teiltabelle
                bclr    #7,0(A0,D0.w)   ;Optimierung sperren
                bra.s   s_initerr1
s_initerr11:    move.w  (A1)+,D0
                beq.s   s_initerr2
                bset    #7,0(A0,D0.w)   ;Optimierung freigeben
                bra.s   s_initerr11
s_initerr2:     addq.w  #1,D2           ;nächster Button
                tst.w   (A1)            ;Ende der Tabelle?
                bpl.s   s_initerr3      ;nein
                btst    #2,D1           ;PC-relativ nicht über Segmentgrenzen
                beq.s   s_initerr21     ;Button nicht selektiert
                bclr    #7,55(A0)       ;Optimierung sperren
s_initerr21:    movem.l (SP)+,D0-D2/A0-A1
                rts
s_initerr:      DC.W 41,42,0    ;Sprungoptimierungen
                DC.W 50,55,0    ;PC-relativ Optimierung
                DC.W 56,0       ;PC-relativ mit Segmentgrenzen
                DC.W 54,0       ;Short-Optimierungen
                DC.W 51,52,0    ;LEA/PEA-Wandlung
                DC.W -1
                ENDPART
                >PART 's_free_list'
s_free_list:    movem.l D0-D3/A0-A1,-(SP) ;legt eine Liste der freien
                lea     mem_list(A4),A0 ;Speicherbereiche an
                move.l  #34000,(A0)+    ;2. Bildschirmseite
                move.l  #hires,D0
                add.l   A4,D0
                move.l  D0,(A0)+
                lea     program_top(A4),A1
                moveq   #3,D3           ;4 Bereiche für Sourcetext
                moveq   #10,D2          ;kleine Sicherheit
s_free_list1:   move.l  (A1)+,D1        ;Endadresse des Bereichs
                add.l   D2,D1
                move.l  (A1),D0         ;max. Adresse des Bereichs
                sub.l   D1,D0           ;ergibt die Länge
                move.l  D0,(A0)+        ;Länge
                move.l  D1,(A0)+        ;Startadresse
                dbra    D3,s_free_list1
                clr.l   (A0)+           ;Ende der Liste
                clr.l   (A0)
                movem.l (SP)+,D0-D3/A0-A1
                rts
                ENDPART
                >PART 's_assemble/x'
************************************************************************
* Assemble                                                             *
************************************************************************
s_assemblex:    st      s_left_right(A4)
s_assemble:     movem.l D1-A6,-(SP)
                tst.w   anz_zeilen(A4)
                beq     s_assm_end
                moveq   #2,D0
                jsr     _graf_mouse     ;Hour glass
                bsr     s_append_end    ;END an Sourcetext anhängen
                bsr     s_init_errtab   ;Optimierungen ein-/ausschalten
                bsr     garbage_collection
                bsr.s   s_free_list     ;Liste der freien Speicherbereiche
                lea     fpath_src(A4),A0
                lea     fpath_code(A4),A1
                moveq   #15,D0
s_assloop:      move.l  (A0)+,(A1)+     ;Pfad für Zielcode auf
                move.l  (A0)+,(A1)+     ;Sourcepfad setzen
                dbra    D0,s_assloop
                bclr    #7,sym_flag(A4)
                pea     dta_buffer(A4)
                move.w  #$1A,-(SP)
                trap    #1              ;Fsetdta
                addq.l  #6,SP
                move.w  #$2A,-(SP)
                jsr     do_trap_1
                move.w  D0,a_date(A4)
                move.w  #$2C,(SP)
                jsr     do_trap_1
                move.w  D0,a_time(A4)
                addq.l  #2,SP
                clr.l   err_count(A4)   ;Fehler und Warnings auf 0
                movea.l label_base(A4),A6
                move.w  label_top_ind(A4),D0
                moveq   #$68,D5         ;External,Global u. EQU-Bit bleiben
                move.w  #$FD,D1         ;Sonderkennung für geladene Symbole
                subq.l  #1,A6
                bra.s   a_pass01
a_pass0:        tst.b   (A6)
                bne.s   a_pass01
                cmp.b   -26(A6),D1      ;Typflag
                beq.s   a_pass01        ;geladenes Symbol
                and.b   D5,-27(A6)      ;defined-flag löschen
a_pass01:       lea     32(A6),A6
                dbra    D0,a_pass0
                movea.l z_info_base(A4),A6
                move.w  anz_zeilen(A4),D0
                subq.w  #1,D0
                addq.l  #8,A6
                moveq   #0,D5           ;Fehlernummern löschen
a_pass02:       move.b  D5,(A6)
                lea     10(A6),A6
                dbra    D0,a_pass02
                move.l  $04BA.w,merk200(A4)
                bsr     a_pass1         ;Source assemblieren
                tst.l   D0
                bmi     fatal_error
                lea     merk200(A4),A0
                move.l  $04BA.w,D1
                sub.l   (A0),D1
                move.l  D1,(A0)
                lsr.l   #3,D1
                sub.l   D1,(A0)
                subq.l  #3,(A0)
                bpl.s   s_assm1         ;Rundungsfehler korrgieren
                moveq   #1,D0
                move.l  D0,(A0)
s_assm1:        move.l  A2,end_adr(A4)
                moveq   #0,D0
                jsr     _graf_mouse
                move.l  A2,D1
                sub.l   ass_adr(A4),D1  ;Länge des erzeugten Programms
                moveq   #32,D0
                cmp.l   D0,D1           ;genau 32 Bytes (d.h. nur ein Header)
                beq     s_asym1         ;ja, Symboltabelle

                lea     ass_rsc_last(PC),A0 ;letztes Baumelement
                bset    #7,(A0)
                tst.b   optimize_flag(A4) ;Optimierungen möglich?
                beq.s   s_assm11        ;nein
                bclr    #7,(A0)

s_assm11:       lea     ass_rsc_d(PC),A0 ;Symboltabellenbuttons
                move.w  #$FFEF,D1
                and.w   D1,(A0)
                and.w   D1,10(A0)       ;enablen (Symboltabellen)
                and.w   D1,20(A0)
s_assm_cont:    st      testwrd(A4)
                lea     asm_rsc_1(PC),A0
                move.l  end_adr(A4),D1
                sub.l   ass_adr(A4),D1  ;Länge des erzeugten Programms
                moveq   #6,D4
                jsr     dezw_out        ;Bytes

                movea.l ass_adr(A4),A1
                lea     asm_rsc_2b(PC),A0
                move.l  2(A1),D1        ;Länge des TEXT-Segments
                moveq   #5,D4
                jsr     dezw_out        ;Bytes
                lea     asm_rsc_2c(PC),A0
                move.l  6(A1),D1        ;Länge des DATA-Segments
                moveq   #5,D4
                jsr     dezw_out        ;Bytes
                lea     asm_rsc_2d(PC),A0
                move.l  10(A1),D1       ;Länge des BSS-Segments
                moveq   #5,D4
                jsr     dezw_out        ;Bytes
                lea     asm_rsc_2e(PC),A0
                move.l  end_adr(A4),D1
                sub.l   ass_adr(A4),D1
                sub.l   2(A1),D1
                sub.l   6(A1),D1        ;Länge des Rests
                moveq   #5,D4
                jsr     dezw_out        ;Bytes

                lea     asm_rsc_0(PC),A0
                moveq   #0,D1
                move.w  anz_zeilen(A4),D1
                moveq   #4,D4
                jsr     dezw_out        ;Zeilen

                moveq   #' ',D0
                subq.w  #1,D1
                beq.s   s_ass11         ;Singular/Plural bilden
                SWITCH sprache
                CASE 0
                moveq   #'n',D0
                CASE 1
                moveq   #'s',D0
                ENDS
s_ass11:        move.b  D0,asm_rsc_0a

                lea     asm_rsc_20+1(PC),A0
                move.l  merk200(A4),D1  ;Zeit holen
                moveq   #0,D2
                move.w  anz_zeilen(A4),D2 ;Zeilenanzahl
                bsr     ldiv            ;Anzahl / Klicks
                move.l  #12000,D1
                bsr     lmult           ;mal 12000
                move.l  D2,D1
                moveq   #6,D4
                jsr     dezw_out
                SWITCH sprache
                CASE 0
                moveq   #'n',D0
                CASE 1
                moveq   #'s',D0
                ENDS
                moveq   #0,D1
                move.w  err_count(A4),D1
                subq.w  #1,D1
                bne.s   s_ass12
                moveq   #' ',D0
s_ass12:        move.b  D0,asm_rsc_0c

                addq.w  #1,D1
                lea     asm_rsc_0b(PC),A0
                moveq   #4,D4           ;Anzahl der Fehler ausgeben
                jsr     dezw_out

                move.w  warn_count(A4),D1
                SWITCH sprache
                CASE 0
                moveq   #'e',D0
                CASE 1
                moveq   #'s',D0
                ENDS
                subq.w  #1,D1
                bne.s   s_ass13
                moveq   #0,D0
s_ass13:        move.b  D0,asm_rsc_0e

                addq.w  #1,D1
                lea     asm_rsc_0d(PC),A0
                jsr     dezw_out        ;Anzahl der Warnings ausgeben
                sf      testwrd(A4)

                lea     ass_rsc_a(PC),A0 ;relativer Code
                move.l  #asm_rsc_1a,(A0)
                tst.b   reloc_fl(A4)
                bne.s   s_assm3
                move.l  #asm_rsc_1b,(A0) ;relozierbarer Code

s_assm3:        lea     ass_rsc_d(PC),A0 ;Symboltabellenbuttons setzen
                btst    #4,1(A0)        ;"keine" auch disabled?
                bne.s   s_assm31        ;dann nix mehr tun
                move.w  #$FFFE,D1
                move.b  opt_d_flag(A4),D0
                subq.b  #1,D0
                beq.s   s_assm34
                bcs.s   s_assm3x
                bmi.s   s_assm32        ;kein OPT =>
                and.w   D1,(A0)
                and.w   D1,10(A0)
                ori.w   #1,20(A0)       ;Xtend Symbols
                bra.s   s_assm32
s_assm3x:       ori.w   #1,(A0)         ;no Symbols
                and.w   D1,10(A0)
                and.w   D1,20(A0)
                bra.s   s_assm32
s_assm34:       and.w   D1,(A0)
                ori.w   #1,10(A0)       ;normal Symbols
                and.w   D1,20(A0)
s_assm32:       move.w  #$FFEF,D1
                and.w   D1,(A0)
                and.w   D1,10(A0)       ;alles enablen
                and.w   D1,20(A0)
                bsr     a_chk_symbol    ;sind Symbole vorhanden?
                beq.s   s_assm31        ;Ja! =>
                moveq   #$10,D1
                or.w    D1,10(A0)       ;disablen (Symboltabellen)
                or.w    D1,20(A0)
                move.w  #$FFFE,D1
                and.w   D1,10(A0)       ;deselect
                and.w   D1,20(A0)
                ori.w   #1,(A0)         ;"keine Symboltabelle" selektieren
s_assm31:       lea     ass_rsc_c(PC),A0 ;Zeiger auf die Module im der RSC
s_assm40:       movea.l -4(A0),A6       ;Zeiger auf den String
                move.l  -(A6),D0        ;Adresse holen
                beq.s   s_assm39        ;=0 => das war's
                movea.l D0,A6           ;Modulbasisadresse merken
                movem.l D1-A6,-(SP)
                movea.l ass_adr(A4),A5  ;Zeiger auf das erzeugte Programm
                lea     dbuffer(A4),A3  ;2k-Diskbuffer
                movea.l screen_adr(A4),A2 ;32k-Screenbuffer
                move.l  org_adr(A4),D7  ;ORG-Adresse (OPT-Befehl)
                move.b  opt_d_flag(A4),D6
                ext.w   D6
                ext.l   D6              ;Symbolflag (OPT D/OPT X)
                move.b  reloc_fl(A4),D5
                ext.w   D5
                ext.l   D5              ;Relocinfo-Flag (vorhanden oder nicht)
                move.l  end_adr(A4),D4  ;Endadr des erzeugten Programms
                move.b  debugger_da(A4),D3
                ext.w   D3
                ext.l   D3              ;<>0 => Debugger resident
                jsr     12(A6)          ;disable-Test
                movem.l (SP)+,D1-A6
                movea.l -4(A0),A1       ;Adresse des Strings
                lea     20(A6),A2
                addq.l  #1,A1
                moveq   #7,D1
s_assm43:       move.b  (A2)+,(A1)+     ;Namen übertragen
                dbra    D1,s_assm43
                ori.w   #$10,(A0)       ;Modul erstmal disablen
                tst.w   D0              ;soll doch enabled werden?
                beq.s   s_assm41        ;NEIN! =>
                andi.w  #$FFEF,(A0)     ;Modul wieder enablen
s_assm41:       lea     10(A0),A0       ;Zeiger auf den nächsten Eintrag
                bra.s   s_assm40        ;weiter geht's

s_assm39:       lea     ass_rsc_b(PC),A0
                moveq   #12,D0          ;13 Buttons
s_assm33:       andi.w  #$FFFC,(A0)     ;Default-Button-Flag überall löschen
                lea     10(A0),A0
                dbra    D0,s_assm33

                lea     ass_rsc_b(PC),A0
                move.w  default_but(A4),D0 ;DEFAULT-Opcode?
                bmi.s   s_assm330       ;Nein!
                mulu    #10,D0          ;Dann den Button versuchen zu selektieren
                bra.s   s_assm331
s_assm330:      move.w  asm_default(A4),D0
s_assm331:      tst.w   err_count(A4)   ;Fehler bei der Assemblierung ?
                beq.s   s_assm37
                moveq   #0,D0           ;ABBRUCH ist zeitweise Default
s_assm37:       btst    #4,1(A0,D0.w)
                beq.s   s_assm42        ;gewünschter Button disabled?
                moveq   #20,D0
                btst    #4,1(A0,D0.w)   ;dann den 1.Button nochmal probieren
                beq.s   s_assm42
                moveq   #0,D0           ;sonst ABBRUCH als Default setzen
s_assm42:       ori.w   #2,0(A0,D0.w)   ;Defaultbutton setzen
                divu    #10,D0          ;Default-Button bei Alt+A
                addq.w  #1,D0
                tst.b   s_left_right(A4)
                bne.s   s_assm350       ;rechte Maustaste

                lea     ass_rsc(PC),A0  ;Alert ausgeben
                jsr     _form_do
                bmi     s_assm_endu2    ;UNDO = Abbruch
s_assm350:      subq.w  #1,D0
                beq     s_assm_end      ;ABBRUCH-Button
                cmp.w   #16,D0
                beq     s_assm_endu     ;ANPASSEN, Sprünge korrigieren

                move.w  D0,D1           ;Button-Nummer*10
                mulu    #10,D1          ;Defaultbutton neu setzen
                tst.w   err_count(A4)   ;Fehler bei der Assemblierung ?
                bne.s   s_assm38
                move.w  D1,asm_default(A4)
s_assm38:       move.b  #'3',ass_rsc9   ;Pass 3 für fatale Fehler
                lea     ass_rsc_b(PC),A0
                movea.l -4(A0,D1.w),A0
                movea.l -(A0),A6        ;Basisadresse des gewählten Moduls
                tst.b   (A0)
                sgt     D0              ;wenn >0, dann D0=-1

                btst    #4,ass_rsc_d+1(PC)
                bne.s   s_assm361       ;Symboltabelle ist disabled
                moveq   #0,D1
                btst    #0,ass_rsc_d+11(PC) ;standard Symboltabelle
                beq.s   s_assm35
                moveq   #1,D1
s_assm35:       btst    #0,ass_rsc_d+21(PC) ;GST
                beq.s   s_assm36
                moveq   #2,D1
s_assm36:       move.b  D1,s_symbol_flag(A4)
                lea     ass_rsc_d(PC),A0 ;Symboltabellenbuttons setzen
                moveq   #0,D2
                tst.w   D1              ;keine Symboltabelle
                beq.s   s_assm361       ;dann auch nicht disablen
                moveq   #$10,D2
                or.w    D2,(A0)
                or.w    D2,10(A0)       ;disablen (Symboltabellen)
                or.w    D2,20(A0)
                bsr     a_make_symbol   ;Symboltabelle erzeugen (D0=DBG-Flag)
s_assm361:
                movem.l D1-A6,-(SP)
                movea.l ass_adr(A4),A5  ;Zeiger auf das erzeugte Programm
                lea     dbuffer(A4),A3  ;2k-Diskbuffer
                movea.l screen_adr(A4),A2 ;32k-Screenbuffer
                move.l  org_adr(A4),D7  ;ORG-Adresse (OPT-Befehl)
                move.b  opt_d_flag(A4),D6
                ext.w   D6
                ext.l   D6              ;Symbolflag (OPT D/OPT X)
                move.b  reloc_fl(A4),D5
                ext.w   D5
                ext.l   D5              ;Relocinfo-Flag (vorhanden oder nicht)
                move.l  end_adr(A4),D4  ;Endadr des erzeugten Programms
                move.b  debugger_da(A4),D3
                ext.w   D3
                ext.l   D3              ;<>0 => Debugger resident
                move.l  SP,s_assm_stk(A4) ;Stackpointer merken
                jsr     16(A6)          ;module choosed
s_assm_end2:    movea.l s_assm_stk(A4),SP
                movem.l (SP)+,D1-A6
                cmp.w   #-4,D0
                beq     _disk_fulla
                moveq   #0,D2           ;kein eigener Fehlertext
                tst.w   D0              ;Fehlernummer < 0
                bmi.s   fatal_error     ;=> fataler Fehler
                subq.w  #1,D0
                bmi.s   s_assm_end      ;0 = normaler Abbruch
                beq     s_assm_cont     ;1 = Dialog nochmal aufrufen
                tst.b   debugger_da(A4) ;Debugger vorhanden?
                bpl.s   s_assm_end      ;nein => nix tun
                subq.w  #1,D0
                beq     call_debug      ;2 = Ab in den Debugger
s_assm_end:     moveq   #0,D0
                jsr     _graf_mouse
                movem.l (SP)+,D1-A6
                bsr     s_reset_def
                moveq   #0,D0
                tst.w   err_count(A4)   ;Fehler da?
                bne.s   s_assm_end1     ;ja
                tst.w   warn_count(A4)  ;Warnungen da?
                beq.s   s_assem_end2    ;nein
                tst.b   skip_warn(A4)   ;zu Warnungen springen?
                beq.s   s_assem_end2    ;nein
s_assm_end1:    moveq   #0,D6
                bsr     jump_line       ;an Quelltextanfang
                movea.l A5,A0
                moveq   #0,D0
                move.w  D6,D1
                bsr     s_jumpx         ;1. Fehler suchen
                bra     s_jump_err1     ;Sprung zum Fehler
s_assm_endu2:   sf      optimize_flag(A4) ;Ende für UNDO
s_assm_endu:    moveq   #0,D0           ;Ende für ANPASSEN
                jsr     _graf_mouse
                movem.l (SP)+,D1-A6
                bsr     s_reset_def
                bsr     s_optimize      ;ev. optimieren
s_assem_end2:   cmp.w   anz_zeilen(A4),D6 ;ak. Zeile überprüfen
                bls     main_loop       ;alles klar
                bra     s_pgend         ;Cursor hinter Textende! -> korrigieren
s_assm21:       move.w  D0,D1
                bsr     _save_err_out   ;Alert ausgeben
                bsr     fclose          ;File schließen
                bra.s   s_assm_end

fatal_error:    lea     ass_rsc12(PC),A0
                st      testwrd(A4)
                moveq   #4,D4
                moveq   #0,D1
                move.w  D0,D1
                move.w  D0,D7
                bsr     dezw_out
                sf      testwrd(A4)
                lea     ass_rsc22(PC),A0
                move.l  #ass_rsc13,(A0) ;'Speicher voll'
                swap    D0
                cmp.w   #-1,D0          ;Speicher voll ?
                beq.s   fatal_error2
                move.l  #ass_rsc15,(A0) ;'File error'
                cmp.w   #-3,D0
                beq.s   fatal_error2
                move.l  #ass_rsc16,(A0) ;'OPT P'
                cmp.w   #-4,D0
                beq.s   fatal_error2
                move.l  #ass_rsc14,(A0) ;'FAIL'
                tst.l   D2
                beq.s   fatal_error2    ;Standardfehlermeldung ausgeben
                move.l  D2,(A0)         ;eigene Meldung ausgeben
fatal_error2:   moveq   #0,D0
                jsr     _graf_mouse
                lea     ass_rsc2(PC),A0
                jsr     _form_do
                exg     D0,D7
                tst.w   D7
                movem.l (SP)+,D1-A6
                bmi.s   s_ass_exit
                move.w  D0,D6
                bsr     jump_line       ;Fehler anspringen
s_ass_exit:     bsr.s   s_reset_def
                bra     main_loop

s_reset_def:    movem.l D0/A0-A1,-(SP)  ;alle defined-Bits für den Editor
                movea.l label_base(A4),A0
                movea.l z_info_base(A4),A1
                tst.w   label_top_ind(A4) ;Einträge belegt ?
                beq.s   s_reset_def1    ;nein
s_reset_def2:   tst.w   6(A1)           ;Symboldefinition
                bpl.s   s_reset_def3    ;vorhanden
s_reset_def4:   lea     10(A1),A1       ;eine Zeile weiter
                tst.w   (A1)            ;letzte Zeile ?
                bpl.s   s_reset_def2    ;nein
s_reset_def1:   movem.l (SP)+,D0/A0-A1
                rts
s_reset_def3:   moveq   #0,D0
                move.w  6(A1),D0        ;Symbolindex
                lsl.l   #5,D0
                ori.b   #$80,4(A0,D0.l) ;defined-bit setzen
                bra.s   s_reset_def4

s_optimize:     tst.b   optimize_flag(A4)
                beq.s   s_optim1        ;keine Korrekturen möglich
                st      change_flag(A4) ;Sourcetext geändert
                bsr     s_correct_jumps ;Sprunglängen korrigieren
                move.w  top_line(A4),D0
                bsr     calc_pointerx   ;Pointer neu setzen
                movem.l A3/A5-A6,top_ptr(A4)
                move.w  D6,D0           ;ak. Zeile
                bra     calc_pointer
s_optim1:       rts

ass_rsc:        DC.W 0,0,52,17,1
                DC.W 1,4
                DC.L asm_rsc_0
                DC.W 8
                DC.W 7,1
                DC.L asm_rsc_1
                DC.W 8
                DC.W 21,1
ass_rsc_a:      DC.L asm_rsc_1a
                DC.W 8
                DC.W 2,2
                DC.L asm_rsc_2a
                DC.W 8
                DC.W 1,6
                DC.L asm_rsc_2
                DC.W 8
                DC.W 1,8
                DC.L asm_rsc_6
                DC.W 8
                DC.W 13,16
                DC.L asm_rsc_20
                DC.W 8

                DC.W 2,14
                DC.L abbruch_button
ass_rsc_b:      DC.W $64

                DC.W 16,8
                DC.L asm_rsc_18 ;Debugger
ass_rsc_c:      DC.W $74
                DC.W 28,8
                DC.L asm_rsc_7
                DC.W $74
                DC.W 40,8
                DC.L asm_rsc_8
                DC.W $74
                DC.W 16,10
                DC.L asm_rsc_9
                DC.W $74
                DC.W 28,10
                DC.L asm_rsc_10
                DC.W $74
                DC.W 40,10
                DC.L asm_rsc_11
                DC.W $74
                DC.W 16,12
                DC.L asm_rsc_12
                DC.W $74
                DC.W 28,12
                DC.L asm_rsc_13
                DC.W $74
                DC.W 40,12
                DC.L asm_rsc_14
                DC.W $74
                DC.W 16,14
                DC.L asm_rsc_15
                DC.W $74
                DC.W 28,14
                DC.L asm_rsc_16
                DC.W $74
                DC.W 40,14
                DC.L asm_rsc_17
                DC.W $74

                DC.W 16,6
                DC.L asm_rsc_3
ass_rsc_d:      DC.W $0145
                DC.W 26,6
                DC.L asm_rsc_4
                DC.W $0144
                DC.W 39,6
                DC.L asm_rsc_5
                DC.W $0144

ass_rsc_last:   DC.W 2,12
                DC.L asm_rsc_21 ;ANPASSEN
                DC.W $24
                DC.W -1

asm_rsc_2a:     DC.B '(TEXT:'
asm_rsc_2b:     DC.B '      '
                DC.B ' DATA:'
asm_rsc_2c:     DC.B '      '
                DC.B ' BSS:'
asm_rsc_2d:     DC.B '      '
                DC.B ' REST:'
asm_rsc_2e:     DC.B '      '
                DC.B ')',0
                SWITCH sprache
                CASE 0
asm_rsc_0:      DC.B '      Zeile'
asm_rsc_0a:     DC.B 'n mit '
asm_rsc_0b:     DC.B '      Fehler'
asm_rsc_0c:     DC.B 'n und '
asm_rsc_0d:     DC.B '      Warnung'
asm_rsc_0e:     DC.B 'en',0
asm_rsc_1:      DC.B '        Bytes ',0
asm_rsc_1a:     DC.B 'relozierbaren Codes erzeugt.',0
asm_rsc_1b:     DC.B 'relativen Codes erzeugt.',0
asm_rsc_20:     DC.B '(        Zeilen pro Minute)',0
asm_rsc_2:      DC.B 'Symboltabelle',0
asm_rsc_6:      DC.B 'Was nun?',0
                EVEN
                DS.L 1          ;Endekennung der Modulliste
asm_rsc_3:      DC.B ' keine ',0
asm_rsc_4:      DC.B ' standard ',0
asm_rsc_5:      DC.B ' erweitert ',0
asm_rsc_21:     DC.B ' ANPASSEN ',0
                CASE 1
asm_rsc_0:      DC.B '      line'
asm_rsc_0a:     DC.B 's with '
asm_rsc_0b:     DC.B '      error'
asm_rsc_0c:     DC.B 's and '
asm_rsc_0d:     DC.B '      warning'
asm_rsc_0e:     DC.B 's ',0
asm_rsc_1:      DC.B '        Bytes ',0
asm_rsc_1a:     DC.B 'relocatable code produced.',0
asm_rsc_1b:     DC.B 'relative code produced.',0
asm_rsc_20:     DC.B '(        lines per minute)',0
asm_rsc_2:      DC.B 'symboltable',0
asm_rsc_6:      DC.B 'choose ',0
                EVEN
                DS.L 1          ;Endekennung der Modulliste
asm_rsc_3:      DC.B ' none ',0
asm_rsc_4:      DC.B ' standard ',0
asm_rsc_5:      DC.B ' extended ',0
asm_rsc_21:     DC.B ' CORRECT ',0
                ENDS
                EVEN
                DS.L 1
asm_rsc_18:     DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_7:      DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_8:      DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_9:      DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_10:     DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_11:     DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_12:     DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_13:     DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_14:     DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_15:     DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_16:     DC.B ' -------- ',0
                EVEN
                DS.L 1
asm_rsc_17:     DC.B ' -------- ',0
                EVEN

ass_rsc2:       DC.W 0,0,45,8,1
                DC.W 8,1
                DC.L ass_rsc8
                DC.W 8
                DC.W 8,2
                DC.L ass_rsc10
                DC.W 8
                DC.W 8,4
ass_rsc22:      DC.L ass_rsc13
                DC.W 8
                DC.W 18,6
                DC.L ok_button
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1

ass_rsc3:       DC.W 0,0,25,7,1
                DC.W 2,1
                DC.L ass_rsc3_0
                DC.W 8
                DC.W 1,3
                DC.L ass_rsc3_1
                DC.W 8
                DC.W 1,5
                DC.L ass_rsc_1
ass_rsc3a:      DC.W $26
                DC.W 15,5
                DC.L abbruch_button
                DC.W $24
                DC.W -1

                SWITCH sprache
                CASE 0
ass_rsc3_0:     DC.B 'Symboltabelle mit',0
ass_rsc3_1:     DC.B '      Symbolen erzeugt.',0

ass_rsc8:       DC.B 'Assemblierung während des '
ass_rsc9:       DC.B '1.Pass',0
ass_rsc10:      DC.B 'in Zeile '
ass_rsc12:      DC.B '      abgebrochen !!',0
ass_rsc13:      DC.B 'Zielcodespeicher ist voll',0
ass_rsc14:      DC.B 'Benutzer-Fehler (FAIL)',0
ass_rsc15:      DC.B 'File konnte nicht geöffnet werden',0
ass_rsc16:      DC.B 'kein PC-relatives Programm erzeugt',0
ass_rsc_1:      DC.B ' SPEICHERN ',0
                CASE 1
ass_rsc3_0:     DC.B 'Symboltable with',0
ass_rsc3_1:     DC.B '      symbols produced.',0

ass_rsc8:       DC.B 'Assembling canceled during '
ass_rsc9:       DC.B '1.Pass',0
ass_rsc10:      DC.B 'in line '
ass_rsc12:      DC.B '      !!',0
ass_rsc13:      DC.B 'Codememory is full',0
ass_rsc14:      DC.B 'User-Error (FAIL)',0
ass_rsc15:      DC.B 'File cannot be opened',0
ass_rsc16:      DC.B 'no PC-relative program produced',0
ass_rsc_1:      DC.B ' SAVE ',0
                ENDS
                EVEN
                ENDPART
                >PART 'hunt_environment'
************************************************************************
* Envirnoment-String?                                                  *
* Filename ab A3, Zielpfad ab A0                                       *
* Zielpfad ab A3                                                      *
************************************************************************
hunt_environment:movea.l basepage(A4),A2
                movea.l $2C(A2),A2      ;Adresse des Environment-String holen
hunt_env0:      lea     hunt_env_str(PC),A1
                move.b  (A2)+,D0
                beq.s   hunt_env5       ;Ende des Environment-Strings, nix
                cmp.b   (A1)+,D0
                beq.s   hunt_env2       ;1.Zeichen ist gleich ! =>
hunt_env1:      tst.b   (A2)+           ;String bis zum Nullbyte überlesen
                bne.s   hunt_env1
                bra.s   hunt_env0       ;Nächste Variable vergleichen
hunt_env2:      move.b  (A2)+,D0
                beq.s   hunt_env0       ;Ende der Variable, nix gefunden
                move.b  (A1)+,D1
                beq.s   hunt_env3       ;gefunden!
                cmp.b   D1,D0
                bne.s   hunt_env1       ;ungleich, nächste Variable
                bra.s   hunt_env2       ;weiter vergleichen
hunt_env3:      movea.l A3,A1
                movea.l A0,A3
                move.b  D0,(A0)+
hunt_env4:      move.b  (A2)+,(A0)+     ;Pfad bis zum Nullbyte kopieren
                bne.s   hunt_env4
                subq.l  #1,A0
hunt_env6:      move.b  (A1)+,(A0)+     ;Filenamen kopieren
                bne.s   hunt_env6
                moveq   #0,D0           ;Environment-String gefunden
                rts
hunt_env5:      moveq   #-1,D0          ;Environment-String nicht gefunden
                rts

hunt_env_str:   DC.B 'SIGMA=',0
                EVEN
                ENDPART
                >PART 'load_moduls'
************************************************************************
* Module einlesen                                                      *
************************************************************************
load_moduls:    moveq   #0,D6           ;noch kein Speicherblock geholt
                lea     dta_buffer(A4),A6
                move.l  A6,-(SP)
                move.w  #$1A,-(SP)
                trap    #1              ;Fsetdta
                addq.l  #6,SP

                lea     modul_name(PC),A3
                lea     fpath_src(A4),A0
                bsr.s   hunt_environment ;Environment-String vorhanden?
                pea     load_modules0(PC)
                beq.s   load_moduls_2   ;gefunden
                addq.l  #4,SP
load_modules0:  lea     modul_name(PC),A3
                bsr.s   load_moduls_2   ;im aktuellen Verzeichnis suchen
                move.b  #'\',-(A3)
                bsr.s   load_moduls_2   ;in Hauptinhaltsverzeichnis
                move.w  $0446.w,D0
                add.w   #'A',D0
                move.b  #':',-(A3)
                move.b  D0,-(A3)        ;ab dem Bootlaufwerk
load_moduls_1:  bsr.s   load_moduls_2
load_moduls_10: addq.b  #1,(A3)
                cmpi.b  #'B',(A3)
                beq.s   load_moduls_10
                cmpi.b  #'Q',(A3)       ;bis zum Laufwerk 'P:' suchen
                bne.s   load_moduls_1
                move.w  #'..',(A3)
                bsr.s   load_moduls_2   ;BSR !!!
                rts
load_moduls_2:  move.w  #7,-(SP)        ;auch als "hidden" suchen
                move.l  A3,-(SP)
                move.w  #$4E,-(SP)
                trap    #1              ;Fsfirst("TURBOASS.DAT",7)
                addq.l  #8,SP
                tst.w   D0
                bpl.s   load_moduls_3
                rts                     ;nicht gefunden

load_moduls_3:  move.l  26(A6),D7       ;Länge der Datei ermitteln

                move.l  D7,-(SP)
                move.w  #$48,-(SP)      ;Speicher für die Module anfordern
                trap    #1              ;Malloc()
                addq.l  #6,SP
                move.l  D0,D6           ;Adresse des Speicherblocks merken
                beq     load_moduls1    ;Speicher reicht nicht!

                clr.w   -(SP)
                move.l  A3,-(SP)
                move.w  #$3D,-(SP)
                trap    #1              ;Fopen()
                addq.l  #8,SP
                move.w  D0,D5           ;Fhandle merken
                bmi     load_moduls1    ;dat war nix

                move.l  D6,-(SP)        ;in den Buffer
                move.l  D7,-(SP)        ;Dateilänge
                move.w  D5,-(SP)        ;Fhandle
                move.w  #$3F,-(SP)
                trap    #1              ;Fread()
                lea     12(SP),SP
                move.l  D0,D4           ;Fehlernr bzw. Anzahl der gelesenen Bytes merken

                move.w  D5,-(SP)
                move.w  #$3E,-(SP)
                trap    #1              ;Fclose()
                addq.l  #4,SP

                cmp.l   D4,D7
                bne.s   load_moduls1    ;Datei nicht komplett gelesen => Mist!

                movea.l D6,A6
                cmpi.w  #$601A,(A6)
                bne.s   load_moduls4
                move.l  2(A6),D7        ;Dateilänge = TEXT-Länge
                lea     28(A6),A6       ;Header ignorieren
load_moduls4:   lea     asm_rsc_18(PC),A0
                lea     ass_rsc_c(PC),A2
                moveq   #11,D5          ;max.12 Module
load_moduls0:   cmpi.l  #'∑-so',(A6)    ;Stimmt der Header?
                bne.s   load_moduls1    ;sonst => Fehlerhafte Moduldatei
                cmpi.l  #'ft01',4(A6)
                bne.s   load_moduls1    ;=> Fehlerhafte Moduldatei
                movem.l D1-A6,-(SP)
                jsr     8(A6)           ;Modul initialisieren
                movem.l (SP)+,D1-A6
                tst.w   D0
                beq.s   load_moduls0b   ;Modul will aber nicht!
                andi.w  #$FFEF,(A2)     ;Modul enablen
                lea     10(A2),A2
                lea     20(A6),A1
                move.l  A6,-(A0)        ;Basisadresse des Moduls übertragen
                move.b  D0,(A0)         ;Flag positiv, wenn Debugger-Modul
                addq.l  #5,A0
                moveq   #7,D0
load_moduls0a:  move.b  (A1)+,(A0)+     ;Namen übertragen
                dbra    D0,load_moduls0a
                addq.l  #7,A0           ;Zeiger auf den nächsten Eintrag in RSC
load_moduls0b:  move.l  28(A6),D0       ;Länge des Moduls holen
                adda.l  D0,A6           ;Zeiger auf das nächste Modul
                sub.l   D0,D7           ;Modullänge von der Gesamtlänge abziehen
                dbls    D5,load_moduls0 ;und noch ein Modul initialisieren
                addq.l  #4,SP           ;Stack korrigieren, nicht weiterladen
load_moduls1:   rts                     ;Alles OK, Module sind geladen
;Bei Fehler: Speicher nicht wieder freigeben!!!
;Da ein Moduls bereits initialisiert sein könnte.

                DC.B '   '      ;Buffer für z.B.: 'C:\'
modul_name:     DC.B 'TURBOASS.DAT',0
                EVEN
                ENDPART
                >PART 'calc_checksum'
************************************************************************
* Prüfsumme über den Assembler ziehen                                  *
************************************************************************
calc_checksum2: movem.l D0-D1/A0-A1/A4,-(SP)
                move.w  #checksum_2,D1  ;Adresse der 2.Prüfsumme
                bra.s   calc_checksum0
calc_checksum1: movem.l D0-D1/A0-A1/A4,-(SP)
                move.w  #checksum_1,D1  ;Adresse der 1.Prüfsumme
calc_checksum0: lea     varbase,A4
                lea     anfang,A0       ;Ab hier geht's los
                moveq   #0,D0
calc_checksum10:add.l   (A0)+,D0        ;Prüfsumme über den Assembler
                cmpa.l  A4,A0
                blo.s   calc_checksum10 ;schon fertig
                move.l  D0,0(A4,D1.w)   ;Prüfsumme ablegen
                movem.l (SP)+,D0-D1/A0-A1/A4
                rts
                ENDPART
                >PART 's_debugger'
************************************************************************
* einfacher Sprung in den Debugger                                     *
************************************************************************
s_debugger:     tst.b   debugger_da(A4)
                bpl     main_loop       ;Debugger nicht resident im Speicher
                lea     own_stack(PC),A0
                movem.l D0-A6,8(A0)
                move    USP,A1
                move.l  A1,4(A0)
                move.l  SP,(A0)
                jsr     org_driver
                pea     -1.w
                move.w  #$48,-(SP)      ;größter zusammenhängender Speicherblock
                bsr     do_trap_1
                addq.w  #6,SP
                move.l  D0,-(SP)
                move.w  #$48,-(SP)      ;Startadresse des selben
                bsr     do_trap_1
                addq.w  #6,SP
                move.l  D0,-(SP)
                move.l  D0,D1
                move.w  #$49,-(SP)      ;und wieder freigeben
                bsr     do_trap_1
                addq.w  #6,SP
                movea.l D1,A0           ;Zeiger auf freien Speicher
                bsr.s   calc_checksum1
                suba.l  A2,A2           ;kein Programm
                lea     s_debug(PC),A1  ;Rücksprungadresse
                move.l  debugger_adr(A4),-(SP) ;Einsprungadresse
                rts                     ;Sprung in Debugger
s_debug:        lea     varbase,A4
                trap    #3
                bsr     calc_checksum2
                lea     own_stack(PC),A0
                movea.l (A0),SP
                jsr     my_driver
                lea     own_stack(PC),A0
                movea.l 4(A0),A1
                move    A1,USP
                movem.l 8(A0),D0-A6
                andi    #$FBFF,SR       ;Interrupts wieder freigeben
                bsr.s   redraw_complete ;gesamten Screen redrawn
                bra     main_loop
                ENDPART
                >PART 'redraw_complete'
redraw_complete:movem.l D0-A6,-(SP)
                jsr     c_clrhome       ;Bildschirm löschen
                jsr     menü_draw       ;Menüzeile ausgeben
                bsr     print_top       ;Statuszeile ausgeben
                moveq   #0,D0           ;kein Fehler
                bsr     error_out
                bsr     asc_code_out    ;ASCII-Code oben rechts darstellen
                bsr.s   redraw_all      ;für alle Zeilen einen Redraw
                bsr     redraw_screen3  ;nun die Zeilen neu ausgeben
                movem.l (SP)+,D0-A6
                rts
                ENDPART
                >PART 'redraw_all'
redraw_all:     movem.l D0/A0,-(SP)
                lea     lin_tab(A4),A0
                move.w  sdrv_zanz(A4),D0
redraw_all1:    sf      (A0)+
                dbra    D0,redraw_all1
                movem.l (SP)+,D0/A0
redraw_all2:    movem.l D0-D1/A0-A1,-(SP)
                lea     lin_tab2(A4),A0 ;Tabelle der Zeilennummern
                move.w  top_line(A4),D0 ;oberste Zeile
                move.w  sdrv_zanz(A4),D1 ;ein Eintrag mehr als Zeilen da
                addq.w  #1,D1
                lea     partbuffer(A4),A1
redraw_all3:    tst.l   (A1)            ;Einträge in der Tabelle
                beq.s   redraw_all6     ;keine versteckten Teile
                cmp.w   (A1),D0         ;mit Startzeile vergleichen
                bls.s   redraw_all4     ;vor Block
                cmp.w   2(A1),D0        ;mit Endzeile vergleichen
                bhi.s   redraw_all5     ;hinter Block
                addq.l  #2,A1
                move.w  (A1)+,D0
                addq.w  #1,D0           ;hinter den Block gehen
redraw_all4:    move.w  D0,(A0)+        ;Zeilennummer in Tabelle eintragen
                addq.w  #1,D0           ;eine Zeile weiter
                dbra    D1,redraw_all3
                movem.l (SP)+,D0-D1/A0-A1
                rts
redraw_all5:    addq.l  #4,A1           ;ein Eintrag weiter
                tst.l   (A1)            ;Ende der Tabelle?
                bne.s   redraw_all3     ;nein
redraw_all6:    move.w  D0,(A0)+        ;Tabelle füllen
                addq.w  #1,D0
                dbra    D1,redraw_all6
                movem.l (SP)+,D0-D1/A0-A1
                rts
                ENDPART

                >PART 'call_debug'
************************************************************************
* Call Debugger                                                        *
************************************************************************
call_debug:     lea     zreserve(A4),A0 ;Zeiger auf Commandline
                move.l  A0,s_assm5-8    ;Wert speichern
                lea     own_stack(PC),A0
                move.l  SP,(A0)+
                move    USP,A1
                move.l  A1,(A0)
                jsr     org_driver
                pea     -1.w
                move.w  #$48,-(SP)      ;größter zusammenhängender Speicherblock
                bsr     do_trap_1
                addq.w  #6,SP
                move.l  D0,-(SP)
                move.w  #$48,-(SP)      ;Startadresse des selben
                bsr     do_trap_1
                addq.w  #6,SP
                move.l  D0,-(SP)
                move.l  D0,D1
                move.w  #$49,-(SP)      ;und wieder freigeben
                bsr     do_trap_1
                addq.w  #6,SP
                movea.l D1,A0           ;Zeiger auf freien Speicher
                move.l  A0,-(SP)
                lea     spaced(A4),A0
                moveq   #0,D2
s_assm62:       move.w  marker(A4,D2.w),D1
                move.w  D1,(A0)+
                bmi.s   s_assm61
                bsr     s_calc_offset
s_assm61:       move.l  D0,(A0)+
                addq.w  #2,D2
                cmp.w   #20,D2
                blo.s   s_assm62
                movea.l (SP)+,A0
                move.b  start_flag(A4),ass_adr(A4)
                movea.l ass_adr(A4),A2  ;Zeiger auf Programm
                sf      ass_adr(A4)
                bsr     calc_checksum1
                lea     s_assm5(PC),A1  ;Rücksprungadresse
                lea     spaced(A4),A3   ;Zeiger auf Offsettabelle
                move.l  debugger_adr(A4),-(SP) ;Einsprungadresse
                rts                     ;Sprung in Debugger

*******************************************************************
* Sprungtabelle für Sourceleveldebugging   (Offsets)              *
*******************************************************************
                OPT O-
                jmp     dbg_disass      ;(-26) Zeile in D0 disassemblieren
                jmp     dbg_calc_offset ;(-20) Zeilennummer -> Offset
                jmp     dbg_calc_line   ;(-14) Offset -> Zeilennummer
                DC.L 0          ;(-8) Zeiger auf Commandline
                DC.L $DEADFACE  ;(-4) Magic für Debugger
                OPT O+
s_assm5:        lea     varbase,A4      ;Rückkehr vom Debugger
                trap    #3              ;Supervisor an
                bsr     calc_checksum2  ;Prüfsumme neu berechnen
                move.l  A0,s_offset_ptr(A4) ;Zeiger auf die Offsets der Marker
                move.l  D0,s_offset(A4) ;Rückgabe des PCs (Control Help)
                lea     own_stack(PC),A0
                movea.l (A0)+,SP        ;Stack richtig setzen
                movea.l (A0),A1         ;Register zurückholen
                move    A1,USP
                jsr     my_driver       ;Assemblertreiber an
                bsr     s_reset_def     ;defined-bits wieder setzen
                movem.l (SP)+,D1-A6
                andi    #$FBFF,SR       ;Interrupts wieder freigeben
                tst.l   s_offset(A4)
                bmi.s   s_assm10        ;kein Control Help
                moveq   #0,D6
                bsr     jump_line       ;zur Zeile 0 springen
                moveq   #0,D2
                movea.l s_offset_ptr(A4),A0
s_assm7:        move.l  (A0)+,D1
                bmi.s   s_assm9
                bsr     s_calc_line
                cmp.w   anz_zeilen(A4),D0 ;die 10 Marker umrechnen
                bls.s   s_assm8
                move.w  anz_zeilen(A4),D0
s_assm8:        move.w  D0,marker(A4,D2.w)
s_assm9:        addq.w  #2,D2
                cmp.w   #20,D2
                blo.s   s_assm7
                move.l  s_offset(A4),D1
                bsr     s_calc_line     ;den PC umrechnen
                cmp.w   anz_zeilen(A4),D0 ;der PC zu groß?
                bhi.s   s_assm10        ;Ja! => raus
                move.w  D0,D6           ;Sprung in die Zeile
s_assm10:       bsr     redraw_complete ;gesamten Screen redrawn
                bsr     jump_line       ;Zeile D6 anspringen
                bra     main_loop
                ENDPART
                >PART 'dgb_routines'
*******************************************************************
* Routinen für Debugger zum Sourceleveldebugging                  *
*******************************************************************
dbg_calc_line:  movem.l D1/A4,-(SP)
                lea     varbase,A4
                move.l  D0,D1           ;PC-Offset vom Debugger nach D1
                bsr.s   s_calc_line     ;Zeilennummer berechnen
                movem.l (SP)+,D1/A4
                rts
dbg_calc_offset:movem.l D1/A4,-(SP)
                lea     varbase,A4
                moveq   #0,D1
                cmp.l   #$FFFE,D0       ;Zeilennummer > 65534
                bhi.s   dbg_calc_off1   ;ja -> Fehler
                move.w  D0,D1           ;Zeilennummer vom Debugger
                cmp.w   anz_zeilen(A4),D1 ;mit Ende vergleichen
                bhi.s   dbg_calc_off1   ;größer
                bsr     s_calc_offset   ;Offset berechnen
                movem.l (SP)+,D1/A4
                rts
dbg_calc_off1:  moveq   #-1,D0          ;Kennung für Debugger
                movem.l (SP)+,D1/A4
                rts
dbg_disass:     movem.l D1-D7/A1-A6,-(SP)
                lea     varbase,A4
                cmp.w   anz_zeilen(A4),D0
                bhi.s   dbg_dis2        ;außerhalb
                bsr     calc_pointer    ;Zeiger auf Zeile D0 berechnen
                pea     zeingabe+2(A4)  ;Buffer
                bsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP
                clr.b   (A0)
                lea     zeingabe+2(A4),A0 ;Anfang des Buffers
                moveq   #0,D0
                movem.l (SP)+,D1-D7/A1-A6
                rts
dbg_dis2:       moveq   #-1,D0          ;Kennung für Debugger
                movem.l (SP)+,D1-D7/A1-A6
                rts
;dbg_disassx:    movem.l D1-D7/A1-A6,-(SP)
;                lea     varbase,A4
;                cmp.w   anz_zeilen(A4),D0
;                bhi.s   dbg_dis2        ;außerhalb
;                bsr     calc_pointer    ;Zeiger auf Zeile D0 berechnen
;                moveq   #0,D0
;                move.w  screen_adr2(A4),D0
;                lsl.l   #8,D0           ;Adresse des 2. Screens (als Buffer)
;                movea.l D0,A1
;                movem.l (SP)+,D1-D7/A1-A6
;                rts
                ENDPART
                >PART 's_calc_line'
*******************************************************************
* Berechnung der Zeilennummer (in D0) anhand des PC-Offsets in D1 *
*******************************************************************
s_calc_line:    movem.l D1-D5/A0-A3,-(SP)
                moveq   #0,D5           ;Flag für calc_line
                move.w  #8,dx_anzahl(A4)
                move.w  #-1,rept_pointer(A4)
                sf      if_flag(A4)
                sf      switch_flag(A4)
                sf      switch_aktiv(A4)
                move.w  #$0200,D3
                moveq   #0,D2
                moveq   #0,D0
                suba.l  A2,A2
                movea.l z_info_base(A4),A0
                movea.l label_base(A4),A3
                tst.l   D1
                beq.s   s_assmz
s_assmx:        tst.w   (A0)
                bmi.s   s_assmw23       ;Ende des Sourcetexts
                adda.w  (A0),A2         ;Länge des Befehl addieren
                cmp.w   2(A0),D3        ;auf Pseudoopcode testen
                bgt.s   s_assmy         ;normaler Befehl
                beq     s_dcb           ;DC.B
                moveq   #0,D2
                move.b  2(A0),D2
                move.w  s_atab-2(PC,D2.w),D2
                beq.s   s_assmy
                jmp     s_atab(PC,D2.w) ;Sprung in Routine
s_assmw23:      bra     s_assmw2        ;Routine verlassen

s_assmy:        tst.w   D5
                bne     s_coff3         ;in die calc_offset Routine
                addq.w  #1,D0           ;Zeilennummer erhöhen
                lea     10(A0),A0       ;Zeiger auf nächste Zeile
                cmpa.l  D1,A2           ;Offset vergleichen
                blo.s   s_assmx         ;noch nicht erreicht
                bhi     s_assmw21       ;Offset bereits überschritten
s_assmz:        tst.l   (A0)
                bne.s   s_assmw         ;keine Leerzeile
s_assmw3:       addq.w  #1,D0           ;eine Zeile weiter
                lea     10(A0),A0       ;Zeiger erhöhen
                bra.s   s_assmz

                BASE DC.W,s_atab
s_atab:         DC.W s_even,s_ds,0,0,0,s_even,0
                DC.W 0,0,0,0,0,0,0,s_ibytes
                DC.W 0,0,0,s_outp,s_if,s_else,s_endc,0
                DC.W s_dx,s_dxset,s_ds,0,s_org,0,s_rept,s_endr
                DC.W s_switch,s_case,s_ends,0,0,0,0,0 ;bis $4E
                DC.W 0,0,0,0,0,s_breakp

s_assmw:        tst.w   D5
                bne     s_coff1         ;in die calc_offset Routine
                moveq   #0,D2
                move.b  2(A0),D2        ;Pseudoopcodekennung
                subq.b  #2,D2
                blt.s   s_assmw2        ;normaler Befehl
                move.w  s_atab(PC,D2.w),D3 ;da TST wegen PC nicht geht
                beq.s   s_assmw3        ;kein besonderer Pseudopcode
                cmp.b   #$2A,D2         ;ENDC (alle minus 2)
                beq.s   s_assmw3
                cmp.b   #$3C,D2         ;ENDR
                beq     s_endr
                cmp.b   #$3A,D2         ;REPT
                beq     s_assmw3
                cmp.b   #$26,D2         ;IF
                beq     s_if
                cmp.b   #$36,D2         ;ORG
                beq     s_assmw3
                cmp.b   #$28,D2         ;ELSE
                beq     s_else
                cmp.b   #$30,D2         ;DXSET
                beq     s_assmw3
                cmp.b   #$24,D2         ;OUTPUT
                beq     s_outp
                cmp.b   #$3E,D2         ;SWITCH
                beq     s_switch
                cmp.b   #$40,D2         ;CASE
                beq     s_case
                cmp.b   #$42,D2         ;ENDS
                beq     s_ends
s_assmw2:       movem.l (SP)+,D1-D5/A0-A3
                rts
s_assmw21:      subq.w  #1,D0           ;Zeilennummer erniedrigen
                bra.s   s_assmw2

s_dcb:          tst.w   4(A0)           ;Index negativ ?
                bpl.s   s_dcb2
                subq.l  #1,A2
s_dcb2:         cmpa.l  D1,A2
                bgt     s_assmw
                tst.l   10(A0)
                beq.s   s_dcb3          ;Leerzeile
                bmi     s_assmw         ;Ende
                cmp.w   12(A0),D3
                ble     s_assmy
s_even:         addq.l  #1,A2
                move.l  A2,D2
                andi.w  #$FFFE,D2
                movea.l D2,A2
                moveq   #0,D2
                bra     s_assmy
s_dcb3:         addq.w  #1,D0
                lea     10(A0),A0
                bra.s   s_dcb2
s_ds:           subq.l  #4,A2
                move.b  3(A0),D4
                move.w  4(A0),D2
                andi.w  #$30,D4
                cmp.w   #$30,D4
                beq.s   s_ds1
s_ds2:          move.b  3(A0),D4
                rol.b   #2,D4
                andi.w  #3,D4
                beq.s   s_ds3
                lsl.l   D4,D2
                addq.l  #1,A2
                move.l  A2,D4
                andi.w  #$FFFE,D4
                movea.l D4,A2
                moveq   #0,D4
                adda.l  D2,A2
                moveq   #0,D2
                bra     s_assmy
s_ds3:          adda.l  D2,A2
                moveq   #0,D2
                bra.s   s_dcb2
s_ds1:          lsl.l   #5,D2
                move.l  0(A3,D2.l),D2
                bra.s   s_ds2
s_ibytes:       move.w  4(A0),D2
                lsl.l   #5,D2
                adda.l  8(A3,D2.l),A2
                bra     s_assmy
s_rept:         move.b  3(A0),D4
                move.w  4(A0),D2
                andi.w  #5,D4
                cmp.w   #5,D5
                bne.s   s_rept1
                lsl.l   #5,D2
                move.l  0(A3,D2.l),D2
s_rept1:        move.l  D2,rept_count(A4)
                move.l  A0,rept_pointer(A4)
                move.w  D0,rept_line(A4)
                bra     s_assmy
s_endr:         tst.w   rept_pointer(A4)
                bmi     s_assmy
                subq.l  #1,rept_count(A4)
                blo.s   s_endr1
                beq.s   s_endr1
                move.w  rept_line(A4),D0
                movea.l rept_pointer(A4),A0
                bra     s_assmy
s_endr1:        move.w  #-1,rept_pointer(A4)
                bra     s_assmy
s_if:           tst.w   4(A0)
                bpl.s   s_if1
                st      if_flag(A4)
                bra     s_assmy
s_if1:          addq.w  #1,D0
                lea     10(A0),A0       ;eine Zeile weiter
                tst.w   (A0)
                bmi.s   s_if2           ;Ende des Sourcetext
                move.w  2(A0),D2
                cmp.w   #$2A00,D2       ;ELSE-Befehl
                beq.s   s_if3
                cmp.w   #$2C00,D2       ;ENDC-Befehl
                bne.s   s_if1
                bra     s_assmy
s_if2:          bra     s_assmw
s_if3:          move.b  #1,if_flag(A4)
                bra     s_assmy
s_else:         tst.b   if_flag(A4)
                bpl     s_assmy
s_else1:        addq.w  #1,D0
                lea     10(A0),A0       ;nächste Zeile
                tst.w   (A0)
                bmi.s   s_if2           ;letzte Zeile
                cmpi.b  #$2C,2(A0)      ;ENDC
                bne.s   s_else1
                sf      if_flag(A4)
                bra     s_assmy
s_endc:         sf      if_flag(A4)
                bra     s_assmy
s_dx:           adda.w  dx_anzahl(A4),A2
                bra     s_assmy
s_dxset:        moveq   #0,D2
                move.b  4(A0),D2        ;Anzahl holen
                move.w  D2,dx_anzahl(A4)
                bra     s_assmy
s_org:          subq.l  #4,A2           ;für Adresse im Programmcode
                bra     s_assmy
s_outp:         suba.w  (A0),A2         ;ev. Commandline wieder abziehen
                bra     s_assmy
s_breakp:       addq.l  #2,A2           ;plus 2, wegen ILLEGAL-Code
                bra     s_assmy
s_switch:       moveq   #0,D2
                move.w  4(A0),D2        ;Index holen
                lsl.l   #5,D2
                move.w  2(A3,D2.l),switch_wert(A4)
                st      switch_flag(A4)
                bra     s_assmy
s_case:         tst.b   switch_flag(A4)
                beq     s_assmy         ;vorher kein SWITCH
s_case1:        tst.b   switch_aktiv(A4)
                bne.s   s_case2         ;schon einen CASE-Teil ausgeführt
                tst.b   3(A5)
                bmi.s   s_case3         ;default Case
                move.w  4(A0),D2        ;Case-Wert
                cmp.w   switch_wert(A4),D2
                bne.s   s_case2         ;ungleich
s_case3:        st      switch_aktiv(A4) ;Case-Teile wird durchlaufen
                bra     s_assmy
s_case2:        addq.w  #1,D0
                lea     10(A0),A0       ;eine Zeile weiter
                tst.w   (A0)
                bmi     s_assmw         ;Ende des Sourcetexts
                move.b  2(A0),D2
                cmp.b   #$42,D2         ;CASE
                beq.s   s_case1         ;ausführen
                cmp.b   #$40,D2         ;SWITCH
                beq.s   s_ends          ;Fehler in Struktur
                cmp.b   #$44,D2         ;ENDS
                bne.s   s_case2
s_ends:         sf      switch_flag(A4)
                sf      switch_aktiv(A4)
                bra     s_assmy
                ENDPART
                >PART 's_calc_offset'
*********************************************************************
* Berechnung eines PC-Offsets (in D0) anhand der Zeilennummer in D1 *
*********************************************************************
s_calc_offset:  movem.l D1-D5/A0-A3,-(SP) ;Zeile in D1
                moveq   #1,D5           ;Flag für calc_offset
                move.w  #-1,rept_pointer(A4)
                sf      if_flag(A4)
                sf      switch_flag(A4)
                sf      switch_aktiv(A4)
                move.w  #$0200,D3
                moveq   #0,D2
                moveq   #0,D0
                suba.l  A2,A2
                tst.w   D1
                beq     s_coff1
                movea.l z_info_base(A4),A0
                lea     -10(A0),A0
                movea.l label_base(A4),A3
s_coff2:        addq.w  #1,D0
                lea     10(A0),A0
                adda.w  (A0),A2
                cmp.w   2(A0),D3
                bgt.s   s_coff3
                beq     s_cdcb          ;DC.B
                moveq   #0,D2
                move.b  2(A0),D2
                move.w  s_ctab-2(PC,D2.w),D2
                beq.s   s_coff3
                jmp     s_ctab(PC,D2.w)
                BASE DC.W,s_ctab
s_ctab:         DC.W s_even,s_ds,0,0,0,s_even,0
                DC.W 0,0,0,0,0,0,0,s_ibytes
                DC.W 0,0,0,s_outp,s_if,s_else,s_endc,0
                DC.W s_dx,s_dxset,s_ds,0,s_org,0,s_rept,s_endr
                DC.W s_switch,s_case,s_ends,0,0,0,0,0 ;bis $4E
                DC.W 0,0,0,0,0,s_breakp

s_coff3:        cmp.w   D1,D0
                blo.s   s_coff2
s_coff1:        move.l  A2,D0
                move.b  2(A0),D2
                cmp.b   #2,D2           ;DC
                beq.s   s_coff5
                cmp.b   #4,D2           ;DS
                beq.s   s_coff6
s_coff7:        movem.l (SP)+,D1-D5/A0-A3
                rts
s_coff5:        tst.b   3(A0)
                beq.s   s_coff7
                addq.l  #1,D0
                and.w   #$FFFE,D0
                bra.s   s_coff7
s_coff6:        move.b  3(A0),D2
                andi.w  #$C0,D2
                beq.s   s_coff7
                addq.l  #1,D0
                and.w   #$FFFE,D0
                bra.s   s_coff7
s_cdcb:         tst.w   4(A0)           ;Index negativ ?
                bpl.s   s_cdcb2
                subq.l  #1,A2
s_cdcb2:        cmp.w   D1,D0
                beq.s   s_coff1
                tst.l   10(A0)
                beq.s   s_cdcb3         ;Leerzeile
                bmi.s   s_coff1         ;Ende
                cmp.w   12(A0),D3
                ble.s   s_coff3
                addq.l  #1,A2
                move.l  A2,D2
                and.w   #$FFFE,D2
                movea.l D2,A2
                moveq   #0,D2
                bra.s   s_coff3
s_cdcb3:        addq.w  #1,D0
                lea     10(A0),A0
                bra.s   s_cdcb2
                ENDPART
                >PART 's_asym1' ;Symboltabelle abspeichern
************************************************************************
* Symboltabelle abspeichern                                            *
************************************************************************
s_asym1:        moveq   #0,D1
                move.w  label_top_ind(A4),D1
                beq.s   s_asym2
                movea.l label_base(A4),A0
                movea.l ass_adr(A4),A1  ;Buffer für Offsets
                clr.w   (A1)
                moveq   #0,D2
s_asym3:        tst.b   31(A0)          ;Status des Eintrags
                bne.s   s_asym4
                tst.b   4(A0)           ;defined-flag
                bpl.s   s_asym4         ;undefiniert
                move.b  5(A0),D0
                bpl.s   s_asym4         ;keine Konstante
                addq.l  #2,A1           ;Zeiger in Buffer erhöhen
                addq.w  #1,D2           ;Anzahl erhöhen
                clr.w   (A1)
s_asym4:        moveq   #32,D0
                add.w   D0,(A1)
                adda.l  D0,A0
                subq.w  #1,D1
                bne.s   s_asym3         ;nächsten Eintrag
                move.w  D2,D1           ;Anzahl der gefundenen Symbole
s_asym2:        st      testwrd(A4)
                lea     ass_rsc3_1(PC),A0
                moveq   #4,D4           ;Anzahl der Symbole ausgeben
                bsr     dezw_out
                sf      testwrd(A4)
                lea     ass_rsc3a(PC),A0
                andi.w  #$FFEF,(A0)     ;Speichern enablen
                andi.w  #$FFFD,10(A0)   ;Abbruch nicht default
                ori.w   #2,(A0)         ;Speichern default
                tst.w   D1
                bne.s   s_asym5
                ori.w   #$10,(A0)       ;Speichern disablen
                andi.w  #$FFFD,(A0)     ;Speichern nicht default
                ori.w   #2,10(A0)       ;Abbruch default
s_asym5:        lea     ass_rsc3(PC),A0
                jsr     _form_do
                cmp.w   #1,D0           ;Speichern ?
                bne     s_assm_end      ;nein
                move.w  D1,D6
                lea     s_sym2_txt(PC),A2 ;Header für Exfsel_input()
                move.l  #'MYS',D0       ;.SYM
                lea     fpath_temp(A4),A0
                lea     fname_temp(A4),A1
                bsr     _fsel_input
                bmi     s_assm_end
                tst.w   D7              ;ABBRUCH
                beq     s_assm_end
                lea     fname_temp(A4),A0
                bsr     s_write_file
                bmi     s_assm_end
                jsr     cursor_off      ;Cursor wieder aus
                moveq   #1,D0
                jsr     _graf_mouse
                clr.w   -(SP)
                pea     fname_temp(A4)
                move.w  #$3C,-(SP)
                bsr     do_trap_1
                addq.w  #8,SP
                move.w  D0,fhandle(A4)
                lea     dbuffer(A4),A5
                lea     fname_temp(A4),A1
                move.l  #'∑SYM',(A5)
                pea     (A5)
                pea     4.w             ;Header schreiben
                move.w  fhandle(A4),-(SP)
                move.w  #$40,-(SP)
                bsr     do_trap_1       ;Fwrite
                lea     12(SP),SP
                tst.l   D0
                bmi     s_assm21        ;Fehler beim Speichern
                movea.l ass_adr(A4),A3
                movea.l label_base(A4),A2
s_asym7:        moveq   #63,D2          ;max. Anzahl für Buffer
                movea.l A5,A0           ;Zeiger in Diskbuffer
                moveq   #32,D0
s_asym6:        adda.w  (A3)+,A2        ;Offset addieren
                move.l  (A2),(A0)
                move.l  4(A2),4(A0)
                move.l  8(A2),8(A0)
                move.l  12(A2),12(A0)   ;Eintrag in Buffer kopieren
                move.l  16(A2),16(A0)
                move.l  20(A2),20(A0)
                move.l  24(A2),24(A0)
                move.l  28(A2),28(A0)
                move.b  #$FE,5(A0)
                adda.l  D0,A0           ;Zeiger in Buffer erhöhen
                subq.w  #1,D6           ;Anzahl minus 1
                dbeq    D2,s_asym6
                suba.l  A5,A0           ;Anzahl der Bytes berechnen
                pea     (A5)
                pea     (A0)            ;Buffer schreiben
                move.w  fhandle(A4),-(SP)
                move.w  #$40,-(SP)
                bsr     do_trap_1       ;Fwrite
                lea     12(SP),SP
                tst.l   D0
                bmi     s_assm21        ;Fehler beim Speichern
                cmp.l   A0,D0
                bne.s   s_asym8
                tst.w   D6
                bne.s   s_asym7         ;noch nicht alle Einträge geschrieben
                bsr     fclose
                bra     s_assm_end
s_asym8:        movem.l (SP)+,D1-A6
                lea     fname_temp(A4),A1
                bra     _disk_full
own_stack:      DS.L 19
s_sym2_txt:     SWITCH sprache
                CASE 0
                DC.B 'SYMBOLTABELLE SPEICHERN',0
                CASE 1
                DC.B 'SAVE SYMBOLTABLE',0
                ENDS
                EVEN
                ENDPART
                >PART 'a_make_symbol'
************************************************************************
* Erzeugt eine Symboltabelle                                           *
************************************************************************
a_make_symbol:  tst.b   s_symbol_flag(A4)
                beq     a_make14
                movem.l D0/D2-D5/A0-A3/A5-A6,-(SP)
                move.b  D0,D4           ;wenn D0<0, dann Debugger-Symboltabelle
                move.l  ass_adr(A4),D3
                movea.l D3,A6
                adda.l  max_code_len(A4),A6 ;Endadresse des Zielcodespeichers
                moveq   #14,D2
                suba.l  D2,A6           ;minus 14
                cmpa.l  end_adr(A4),A6
                blo     a_make16        ;Speicher voll
                moveq   #$1C,D0
                add.l   D0,D3           ;Start des TEXT-Segments
                move.l  end_adr(A4),D1
                addq.l  #1,D1
                bclr    #0,D1
                movea.l D1,A1
                movea.l D1,A5
                movea.l label_base(A4),A3
                move.w  label_top_ind(A4),D2
;Ø                lea     segm_adr(A4),A2 ;überflüssig?
                moveq   #0,D0
                exg     D0,D4
                tst.b   D0
                bmi     a_make10        ;eigenes Format erzeugen
                cmpi.b  #2,s_symbol_flag(A4)
                beq     a_make7         ;GST-Format
a_make1:        subq.w  #1,D2
                bmi.s   a_make2         ;Ende der Symboltabelle
                tst.b   31(A3)          ;Symbol ?
                bne.s   a_make3         ;nein
                move.l  8(A3),(A1)+
                move.l  12(A3),(A1)+    ;Symbolnamen übertragen
                move.b  4(A3),D5        ;Symboltyp
                move.b  D5,(A1)+
                clr.b   (A1)+
                move.l  (A3),D0         ;Adresse des Symbols
                and.b   #7,D5
                beq.s   a_make30        ;gar nix
                cmp.b   #2,D5
                beq.s   a_make31        ;TEXT
                cmp.b   #4,D5
                beq.s   a_make32        ;DATA
                sub.l   segm_adr+8(A4),D0 ;- DATA-Länge
a_make32:       sub.l   segm_adr+4(A4),D0 ;- TEXT-Länge
a_make31:       sub.l   D3,D0           ;- Startadr des TEXT-Segmentes
a_make30:       move.l  D0,(A1)+        ;Adresse eintragen
                moveq   #14,D0
                add.l   D0,end_adr(A4)
                addq.w  #1,D4           ;Zähler
                cmpa.l  end_adr(A4),A6
                bls.s   a_make2         ;Ende des Speichers
a_make3:        lea     32(A3),A3
                bra.s   a_make1
a_make2:        movea.l ass_adr(A4),A0
                move.l  D4,D0
                lsl.l   #4,D4
                sub.l   D0,D4
                sub.l   D0,D4
                move.l  D4,14(A0)       ;Länge der Symboltabelle
                beq.s   a_make6         ;keine Symbole
                movea.l A1,A2           ;Ende der Symboltabelle
                movea.l ass_adr(A4),A1
                lea     $1C(A1),A0
                addq.l  #2,A1
                adda.l  (A1)+,A0        ;TEXT-Länge
                adda.l  (A1),A0         ;DATA-Länge=Zeiger auf Reloctabelle
                movea.l A0,A1
                sub.l   A0,D1           ;Länge des Relocinfos
                lsr.l   #2,D1           ;in Longs
a_make4:        move.l  (A0)+,(A2)+     ;Relocinfo hinter Symboltabelle
                dbra    D1,a_make4      ;kopieren
                movea.l A5,A0           ;Start der Symboltabelle
                move.l  A2,D0
                sub.l   A0,D0           ;Länge des Blocks
                lsr.l   #2,D0           ;in Longs
a_make5:        move.l  (A0)+,(A1)+     ;Block runterkopieren
                dbra    D0,a_make5
a_make6:        addq.w  #1,D2           ;Wenn D2=-1, dann ist alles ok!
a_make16:       movem.l (SP)+,D0/D2-D5/A0-A3/A5-A6
                beq.s   a_make14
                movem.l D0/A0,-(SP)
                lea     make_sym_rsc(PC),A0
                jsr     _form_do
                movem.l (SP)+,D0/A0
a_make14:       rts
a_make7:        subq.w  #1,D2           ;GST-Format erzeugen
                bmi.s   a_make2         ;Ende der Symboltabelle
                tst.b   31(A3)          ;Symbol ?
                bne.s   a_make9         ;nein
                move.l  8(A3),(A1)+
                move.l  12(A3),(A1)+    ;Symbolnamen übertragen
                move.b  4(A3),D5        ;Symboltyp
                move.b  D5,(A1)+
                clr.b   (A1)+
                move.l  (A3),D0         ;Adresse des Symbols
                and.b   #7,D5
                beq.s   a_make70        ;gar nix
                cmp.b   #2,D5
                beq.s   a_make71        ;TEXT
                cmp.b   #4,D5
                beq.s   a_make72        ;DATA
                sub.l   segm_adr+8(A4),D0 ;- DATA-Länge
a_make72:       sub.l   segm_adr+4(A4),D0 ;- BSS-Länge
a_make71:       sub.l   D3,D0           ;- Startadresse des TEXT-Segmentes
a_make70:       move.l  D0,(A1)+        ;Adresse eintragen
                tst.b   16(A3)
                beq.s   a_make8         ;Name nicht länger als 8 Zeichen
                move.b  #$48,-5(A1)     ;GST-Kennung für Folgeeintrag
                move.l  16(A3),(A1)+
                move.l  20(A3),(A1)+    ;Rest des Namens
                move.l  24(A3),(A1)+
                move.w  28(A3),(A1)+
                addq.w  #1,D4
                moveq   #14,D0
                add.l   D0,end_adr(A4)
a_make8:        moveq   #14,D0
                add.l   D0,end_adr(A4)
                addq.w  #1,D4           ;Zähler
                cmpa.l  end_adr(A4),A6
                bls     a_make2
a_make9:        lea     32(A3),A3
                bra.s   a_make7
a_make10:       subq.w  #1,D2           ;eigenes Format erzeugen
                bmi     a_make2         ;Ende der Symboltabelle
                tst.b   31(A3)          ;Symbol ?
                bne.s   a_make11        ;nein
                lea     8(A3),A0        ;Adresse des Namen
                move.l  A0,(A1)+        ;Zeiger in Tabelle
                clr.l   (A1)+           ;reserviert
                move.b  4(A3),D5        ;Symboltyp
                move.b  D5,(A1)+
                clr.b   (A1)+
                move.l  (A3),D0         ;Adresse des Symbols
                and.b   #7,D5
                beq.s   a_make15        ;gar nix
                cmp.b   #2,D5
                beq.s   a_make13        ;TEXT
                cmp.b   #4,D5
                beq.s   a_make12        ;DATA
                sub.l   segm_adr+8(A4),D0 ;- Länge des DATA-Segmentes
a_make12:       sub.l   segm_adr+4(A4),D0 ;- Länge des TEXT-Segmentes
a_make13:       sub.l   D3,D0           ;- Startadr des TEXT-Segmentes
a_make15:       move.l  D0,(A1)+        ;Adresse eintragen
                moveq   #14,D0
                add.l   D0,end_adr(A4)
                addq.w  #1,D4           ;Zähler
                cmpa.l  end_adr(A4),A6
                bls     a_make2
a_make11:       lea     32(A3),A3
                bra.s   a_make10
make_sym_rsc:   DC.W 0,0,45,6,1
                DC.W 8,1
                DC.L make_s_0
                DC.W 8
                DC.W 8,2
                DC.L make_s_1
                DC.W 8
                DC.W 18,4
                DC.L abbruch_button
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1

                SWITCH sprache
                CASE 0
make_s_0:       DC.B 'Erzeugung der Symboltabelle aus',0
make_s_1:       DC.B 'Speicherplatzmangel abgebrochen.',0
                CASE 1
make_s_0:       DC.B 'Creation of symboltable has been',0
make_s_1:       DC.B 'canceled because of less memory.',0
                ENDS
                EVEN
                ENDPART
                >PART 'a_chk_symbol'
************************************************************************
* testet, ob Symbole in der Tabelle sind (wenn ja Z=0)                 *
************************************************************************
a_chk_symbol:   movem.l D0/A0,-(SP)
                move.w  label_top_ind(A4),D0
                beq.s   a_chk_symbol2
                movea.l label_base(A4),A0
                subq.l  #1,A0
                subq.w  #1,D0
a_chk_symbol1:  lea     32(A0),A0
                tst.b   (A0)
                dbeq    D0,a_chk_symbol1
                beq.s   a_chk_symbol3
a_chk_symbol2:  move    #0,CCR
a_chk_symbol3:  movem.l (SP)+,D0/A0
                rts
                ENDPART
                >PART 'ldiv'
***********************************************************************
* LONG-Division      : D2=D2/D1  D1=D2 MOD D1                         *
***********************************************************************
ldiv:           movem.l D0/D3-D4,-(SP)
                tst.l   D1
                beq.s   ldiv9
                exg     D1,D2
                clr.w   D4
                tst.l   D1
                bge.s   ldiv1
                addq.w  #3,D4
                neg.l   D1
ldiv1:          tst.l   D2
                bge.s   ldiv2
                addq.w  #1,D4
                neg.l   D2
ldiv2:          moveq   #1,D3
ldiv4:          cmp.l   D1,D2
                bhs.s   ldiv3
                add.l   D2,D2
                add.l   D3,D3
                bra.s   ldiv4
ldiv3:          moveq   #0,D0
ldiv6:          cmp.l   D1,D2
                bhi.s   ldiv5
                or.l    D3,D0
                sub.l   D2,D1
ldiv5:          lsr.l   #1,D2
                lsr.l   #1,D3
                bcc.s   ldiv6
                cmp.w   #3,D4
                blt.s   ldiv7
                neg.l   D1
ldiv7:          lsr.l   #1,D4
                bcc.s   ldiv8
                neg.l   D0
ldiv8:          move.l  D0,D2
ldiv9:          movem.l (SP)+,D0/D3-D4
                rts
                ENDPART
                >PART 'lmult'
************************************************************************
* Long-Mult D2.L*D1.L -> D2.L                                          *
* <- V-Flag gesetzt, wenn Overflow                                     *
************************************************************************
lmult:          movem.l D1/D3-D5,-(SP)
                moveq   #0,D3
                tst.l   D1
                bpl.s   lmult2
                addq.w  #1,D3
                neg.l   D1
lmult2:         tst.l   D2
                bpl.s   lmult3
                addq.w  #1,D3
                neg.l   D2
lmult3:         move.l  D2,D4           ;1.Faktor merken
                mulu    D1,D2           ;low-words multiplizieren
                move.l  D4,D5           ;1.Faktor nochmal merken
                swap    D4              ;high des 2.Faktors
                mulu    D1,D4
                swap    D4              ;Ergebnis umdrehen
                tst.w   D4              ;höheres Word testen
                bne.s   lmult1
                add.l   D4,D2           ;und aufaddieren
                bcs.s   lmult1
                move.l  D5,D4           ;1.Faktor reproduzieren
                swap    D1
                mulu    D1,D4           ;h-word d3 mal l-word d1
                swap    D4              ;Ergebnis swappen (wie oben)
                tst.w   D4              ;wieder höheres Word testen
                bne.s   lmult1
                add.l   D4,D2           ;wieder aufaddieren
                bcs.s   lmult1
                swap    D5              ;2.Faktor h-word nach unten
                mulu    D1,D5           ;h-words multiplizieren
                bne.s   lmult1          ;nicht null, erg. > $ffffffff
                btst    #0,D3
                beq.s   lmult4
                neg.l   D2
                andi    #$FD,CCR        ;kein Übertrag -> V-Flag gelöscht
lmult4:         movem.l (SP)+,D1/D3-D5
                rts
lmult1:         ori     #2,CCR          ;Overflow aufgetreten -> V-Flag gesetzt
                movem.l (SP)+,D1/D3-D5
                rts
                ENDPART
                >PART 'a_pass1'
************************************************************************
* Der 1.Pass                                                           *
************************************************************************
a_pass1:        movea.l ass_adr(A4),A6  ;Startadresse des Zielcodes
                movea.l A6,A0
                move.w  #$601A,(A6)+    ;0  DOS-Identifikation
                clr.l   (A6)+           ;2  TEXT-Länge
                clr.l   (A6)+           ;6  DATA-Länge
                clr.l   (A6)+           ;10 BSS-Länge
                clr.l   (A6)+           ;14 Länge der Symboltabelle
                clr.l   (A6)+           ;18 reserviert
                clr.l   (A6)+           ;22 Bit 0=1 (=> TOS 1.4-Fast-Load)
                clr.w   (A6)+           ;26 Relocinfo (=0 wegen TOS-Fehler)
                move.l  max_code_len(A4),D5 ;Max.Länge des Codes
                move.l  A6,D4           ;Beginn des TEXT-Segments
                move.l  D4,segm_adr(A4)
                clr.l   segm_adr+4(A4)  ;kein DATA-Segment
                clr.l   segm_adr+8(A4)  ;kein BSS-Segment
                sf      optimize_flag(A4) ;Flag für Sprungkorrektur
                sf      output_flag(A4) ;Noch keinen OUTPUT-Befehl gefunden
                movea.l label_base(A4),A3 ;Zeiger auf Labeltabelle
                movea.l z_info_base(A4),A5 ;Zeiger auf Zeileninfo
                movea.l program_base(A4),A1 ;Opcode ab hier
                clr.l   rs_count(A4)
                clr.l   rs_merk(A4)
                clr.l   org_adr(A4)
                move.w  #8,dx_anzahl(A4)
                clr.b   dx_wert(A4)
                clr.b   if_flag(A4)
                sf      switch_flag(A4)
                sf      switch_aktiv(A4)
                sf      opt_w_flag(A4)
                sf      opt_o_flag(A4)
                st      opt_d_flag(A4)
                sf      opt_p_flag(A4)
                move.w  #-1,rept_pointer(A4)
                st      default_but(A4)
                move.b  #2,sym_typ(A4)
                move.b  #'1',ass_rsc9   ;Pass 1
                move.w  #$4447,a_copy2  ;NEG.W D7 einsetzen
                move.w  #$9A87,a_copy6  ;SUB.L D7,D5 einsetzen
                move.w  #a_dx-a_tab,a_tab01 ;DX setzen
                move.w  #a_ds-a_tab,a_tab02 ;DCB setzen
                move.w  #a_ibytes-a_tab,a_tab03 ;IBYTES setzen
                move.l  #$122D0001,a_dc+2 ;MOVE.B 1(A5),D1 einsetzen
                move.b  #2,a_dsll-1     ;DS produziert Code
                move.b  #2,a_dswl-1
                move.b  #2,a_dsbl-1
                move.b  #a_dsll1-a_dsll3-2,a_dsll3+1
                move.b  #a_dswl1-a_dswl3-2,a_dswl3+1
                move.b  #a_dsbl1-a_dsbl3-2,a_dsbl3+1
                move.w  #$6F00,D7       ;BLS out_of_mem einsetzen
                move.w  D7,a_pat1
                move.w  D7,a_pat2
                move.w  D7,a_pat3
                move.w  D7,a_pat4
                move.w  D7,a_pat5
                move.w  D7,a_pat6
                move.w  D7,a_pat7
                move.w  #$421E,D7
                move.w  D7,a_dsl
                move.w  D7,a_dsw
                move.w  D7,a_pass2
                bsr     clr_cache
                moveq   #0,D6           ;Zeile 0
                moveq   #0,D3           ;Zähler für Längeneintrag
                moveq   #0,D7
a_pass1loop:    move.w  (A5)+,D7        ;Befehlslänge holen
                move.w  4(A5),D0        ;Wurde ein Label in dieser Zeile definiert?
                bpl.s   a_labeldef      ;JA!
a_copy3:        move.b  (A5),D0
                subq.b  #2,D0           ;Vergleich siehe Zettel !!!
                bge.s   a_spez          ;Spezialbefehle
a_copy6:        sub.l   D7,D5
                OPT O-
a_pat1:         bls     out_of_mem      ;wird gepatched (BSS)
                OPT O+
a_copy2:        neg.w   D7              ;wird nach BRA.S *+4 gepatched (BSS)
                jmp     a_copy4(PC,D7.w)
                adda.w  D7,A6           ;für das BSS-Segment !
                addq.l  #8,A5           ;Zeiger auf nächste Zeile
                addq.w  #1,D6           ;Zeilennr.+1
                bra.s   a_pass1loop     ;nächste Zeile
                move.w  (A1)+,(A6)+     ;5 Words
                move.w  (A1)+,(A6)+     ;4 Words
                move.w  (A1)+,(A6)+     ;3 Words kopieren
                move.w  (A1)+,(A6)+     ;2 Words
                move.w  (A1)+,(A6)+     ;1 Word
a_copy4:        addq.l  #8,A5           ;Zeiger auf nächste Zeile
                addq.w  #1,D6           ;Zeilennr.+1
                bra.s   a_pass1loop     ;nächste Zeile

a_bss_error2:   tst.l   -2(A5)          ;Leerzeile ?
                beq.s   a_copy4         ;ja!
a_bss_error:    moveq   #15,D0          ;'Im BSS-Bereich nicht erlaubt'
                bsr     _mark_error
                bra.s   a_copy4

a_end:          tst.w   rept_pointer(A4)
                bpl     a_rept07        ;offene REPT-Struktur
                tst.b   switch_flag(A4)
                bne     a_switch13      ;offene SWITCH-Struktur
                tst.b   if_flag(A4)
                beq     a_pass2
                bra     a_if15          ;offene IF-Struktur

a_spez:         ext.w   D0
                move.w  a_tab(PC,D0.w),D0 ;Sprungoffset holen
                jmp     a_tab(PC,D0.w)  ;Sprung in Routine

a_labeldef:     ext.l   D0
                lsl.l   #5,D0           ;Labelnummer * 32
                move.b  (A5),D1
                subq.b  #2,D1           ;Vergleich siehe Zettel !!!
                bge.s   a_labeldef1     ;Spezialbefehle nach Labeln
a_labeldef2:    bset    #7,4(A3,D0.l)   ;defined-flag setzen
                bne.s   redef_err
                move.l  A6,0(A3,D0.l)   ;Destadr in die Labeltabelle
                move.b  sym_typ(A4),D1
                or.b    D1,4(A3,D0.l)   ;Symboltyp (TEXT, DATA, BSS)
                moveq   #0,D0           ;D0 wieder löschen
                bra.s   a_copy3         ;Weiter geht's
redef_err:      moveq   #4,D0
                bsr     _mark_error
                bra     a_copy3
out_of_mem:     moveq   #-1,D0          ;Out of memory
                move.w  D6,D0           ;Zeilennummer
                rts

a_labeldef1:    beq     a_dc            ;DC.X ?
                cmp.b   #2,D1           ;DS.X ?
                beq     a_ds
                cmp.b   #$0C,D1         ;EQU ?
                beq     a_equ           ;Ja
                cmp.b   #$16,D1         ;RS.X ?
                beq.s   a_rs
                cmp.b   #$38,D1         ;SET ?
                beq     a_set           ;ja
                cmp.b   #$1A,D1         ;REG ?
                beq     a_reg1          ;Ja
                cmp.b   #$32,D1         ;DCB ?
                beq     a_ds
                cmp.b   #$56,D1         ;== ?
                beq     a_equ
                bra.s   a_labeldef2

                BASE DC.W,a_tab
a_tab:          DC.W a_dc       ;DC
                DC.W a_ds       ;DS
                DC.W a_dc14     ;TEXT
                DC.W a_data     ;DATA
                DC.W a_bss      ;BSS
                DC.W a_even     ;EVEN
                DC.W a_copy4    ;EQU
                DC.W a_opt      ;OPT
                DC.W a_end      ;END
                DC.W a_rsreset  ;RSRESET
                DC.W a_rsbss    ;RSBSS
                DC.W a_rs00     ;RS
                DC.W a_rsset    ;RSSET
                DC.W a_dc14     ;REG
a_tab03:        DC.W a_ibytes   ;IBYTES
                DC.W a_dc14     ;BASE
                DC.W a_path     ;PATH
                DC.W a_cnop     ;CNOP
                DC.W a_outp     ;OUTPUT
                DC.W a_if       ;IF
                DC.W a_else     ;ELSE
                DC.W a_endc     ;ENDC
                DC.W a_rseven   ;RSEVEN
a_tab01:        DC.W a_dx       ;DX.B
                DC.W a_dxset    ;DXSET
a_tab02:        DC.W a_ds       ;DCB
                DC.W a_fail     ;FAIL
                DC.W a_org      ;ORG
                DC.W a_set      ;SET
                DC.W a_rept     ;REPT
                DC.W a_endr     ;ENDR
                DC.W a_switch   ;SWITCH
                DC.W a_case     ;CASE
                DC.W a_ends     ;ENDS
                DC.W a_global   ;GLOBAL
                DC.W a_common   ;COMMON
                DC.W a_default  ;DEFAULT
                DC.W 0          ;MACRO
                DC.W 0          ;ENDM
                DC.W 0          ;Macroaufruf
                DC.W a_dc14     ;PART
                DC.W a_dc14     ;ENDPART
                DC.W a_isymbol  ;ISYMBOL
                DC.W a_copy4    ;==
                DC.W a_breakp   ;BREAKPT

a_rs00:         moveq   #$FF,D0
a_rs:           moveq   #0,D1
                move.w  2(A5),D1        ;Anzahl/Index
                move.w  (A5),D2
                lsr.w   #4,D2           ;Flags für Breite
                bcc.s   a_rs02          ;kein Symbol
                exg     D1,D0
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A3,D0.l) ;Formel
                bne.s   a_rs03          ;nein
                bsr     a_calc_formel
a_rs03:         tst.b   4(A3,D0.l)      ;defined_flag testen
                bpl.s   a_rs05          ;undefiniert
                tst.b   5(A3,D0.l)      ;Typflag
                beq.s   a_rs04          ;Symbol
                bpl.s   a_rs04          ;Reglist
                exg     D0,D1
                move.l  0(A3,D1.l),D1   ;Wert holen
a_rs02:         tst.l   D0
                bmi.s   a_rs08          ;keine Symboldef
                bset    #7,4(A3,D0.l)   ;defined-flag der Symboldef
                bne.s   a_rs07          ;doppelte Deklaration
                andi.w  #3,D2
                beq.s   a_rs01          ;RS.B
                lsl.l   D2,D1           ;mal Breite
                move.l  rs_count(A4),D2
                addq.l  #1,D2
                bclr    #0,D2           ;Counter begradigen
                bne.s   a_rs11
                move.l  D0,-(SP)
                moveq   #25,D0
                bsr     _mark_warn      ;es wurde begradigt
                move.l  (SP)+,D0
a_rs11:         move.l  D2,0(A3,D0.l)   ;Counter übertragen
                move.b  #$FC,5(A3,D0.l) ;Flag für RS-Konstante
a_rs10:         add.l   D1,D2
                move.l  D2,rs_count(A4) ;zum Zähler dazu
                moveq   #0,D0
                bra     a_dc14
a_rs07:         moveq   #4,D0
                bsr     _mark_error     ;'doppelte Deklaration'
                bra.s   a_rs08
a_rs05:         moveq   #19,D0          ;'Symbol nicht definiert'
                bra.s   a_rs06
a_rs04:         moveq   #14,D0          ;'unerlaubter Operand'
a_rs06:         bsr     _mark_error
                exg     D0,D1
                moveq   #0,D1
                bra.s   a_rs02
a_rs01:         move.l  rs_count(A4),0(A3,D0.l) ;Counter übertragen
                move.b  #$FC,5(A3,D0.l) ;Flag für RS-Konstante
a_rs09:         add.l   D1,rs_count(A4)
                moveq   #0,D0
                bra     a_dc14
a_rs08:         andi.w  #3,D2
                beq.s   a_rs09          ;RS.B
                lsl.l   D2,D1           ;mal Breite
                move.l  rs_count(A4),D2
                addq.l  #1,D2
                andi.w  #$FFFE,D2       ;Counter begradigen
                bra.s   a_rs10

a_reg1:         bset    #7,4(A3,D0.l)
                beq     a_dc14
                moveq   #4,D0
                bsr     _mark_error
                bra     a_dc14

a_opt:          move.w  2(A5),D0
                btst    #12,D0          ;W
                beq.s   a_opt01
                btst    #13,D0
                sne     opt_w_flag(A4)
a_opt01:        btst    #10,D0          ;O
                beq.s   a_opt00
                btst    #11,D0
                sne     opt_o_flag(A4)
a_opt00:        btst    #2,D0           ;D
                beq.s   a_opt02
                sf      opt_d_flag(A4)  ;-
                btst    #3,D0
                bne.s   a_opt02
                move.b  #1,opt_d_flag(A4) ;+
a_opt02:        btst    #0,D0           ;X
                beq.s   a_opt03
                sf      opt_d_flag(A4)  ;-
                btst    #1,D0
                bne.s   a_opt03
                move.b  #2,opt_d_flag(A4) ;+
a_opt03:        btst    #6,D0           ;F
                beq.s   a_opt05
                tst.b   D0              ;Bit 7=1?
                bmi.s   a_opt05         ;Ja! => OPT F- angegeben
                movea.l ass_adr(A4),A0  ;OPT F+ : Startadresse des Zielcodes
                bset    #0,25(A0)       ;Fast-Load-Flag im Header setzen
a_opt05:        btst    #8,D0           ;P
                beq.s   a_opt04
                btst    #9,D0
                seq     opt_p_flag(A4)  ;setzen, wenn +
a_opt04:        bra     a_dc14

a_org:          move.l  (A1)+,org_adr(A4)
                tst.b   1(A5)           ;',^' ?
                sne     org_adr(A4)
                bra     a_dc14
a_rept:         tst.w   rept_pointer(A4)
                bpl.s   a_rept06
                moveq   #0,D0
                move.w  2(A5),D0        ;Anzahl/Index
                move.w  (A5),D2
                lsr.w   #4,D2           ;Flags für Breite
                bcc.s   a_rept02        ;kein Symbol
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A3,D0.l) ;Formel
                bne.s   a_rept03        ;nein
                bsr     a_calc_formel
a_rept03:       tst.b   4(A3,D0.l)      ;defined_flag testen
                bpl.s   a_rept05        ;undefiniert
                tst.b   5(A3,D0.l)      ;Typflag
                beq.s   a_rept04        ;Symbol
                bpl.s   a_rept04        ;Reglist
                move.l  0(A3,D0.l),D0   ;Wert holen
a_rept02:       move.l  D0,rept_count(A4)
                move.w  D6,rept_line(A4)
                move.l  A1,rept_pointer(A4)
                move.l  A5,rept_pointer+4(A4)
                moveq   #0,D0
                bra     a_dc14
a_rept04:       moveq   #14,D0          ;'unerlaubter Operand'
                bsr     _mark_error
                moveq   #1,D0
                bra.s   a_rept02
a_rept05:       moveq   #19,D0          ;'Symbol nicht definiert'
                bsr     _mark_error
                moveq   #1,D0
                bra.s   a_rept02
a_rept06:       moveq   #35,D0          ;'REPT nicht abgeschlossen'
                bsr     _mark_error
                bra     a_dc14
a_rept07:       moveq   #35,D0          ;'REPT nicht abgeschlossen'
                movea.l rept_pointer+4(A4),A5 ;Zeiger auf REPT
                bsr     _mark_error
                bra     a_pass2
a_endr:         tst.w   rept_pointer(A4)
                bmi.s   a_endr01
                subq.l  #1,rept_count(A4)
                bcs.s   a_endr02
                beq.s   a_endr02        ;Zähler auf Null
                movea.l rept_pointer(A4),A1
                movea.l rept_pointer+4(A4),A5
                move.w  rept_line(A4),D6
                bra     a_dc14
a_endr02:       move.w  #$FFFF,rept_pointer(A4)
                bra     a_dc14
a_endr01:       moveq   #36,D0          ;'ENDR ohne REPT'
                bsr     _mark_error
                bra     a_dc14
a_fail:         moveq   #-2,D0          ;Kennung für Abbruch durch FAIL
                swap    D0
                move.w  D6,D0           ;Zeilennummer
                moveq   #0,D2
                tst.w   2(A5)           ;eigene Meldung
                bmi.s   a_fail2         ;nein
                move.w  2(A5),D2        ;Index holen
                lsl.l   #5,D2
                add.l   label_base(A4),D2 ;Adresse der Meldung
a_fail2:        rts

a_if:           tst.b   if_flag(A4)
                bne.s   a_if17          ;geschachtelte IFs nicht erlaubt
                andi.w  #$3FFF,2(A5)    ;Flags löschen
                bsr.s   a_if1           ;Bedingung auswerten
                tst.b   D1              ;Bedingung erfüllt
                beq.s   a_if13          ;nein =>
                st      if_flag(A4)     ;ja, Flag setzen
                ori.w   #$8000,2(A5)    ;Flag für Pass2 setzen
                bra     a_dc14
a_if11:         move.w  4(A3,D0.l),D1   ;defined-flag holen
                ext.l   D1
                bra.s   a_if10          ;in die IF-Auswertung zurück
a_if13:         adda.w  -2(A5),A1
                addq.w  #1,D6
                addq.l  #8,A5           ;eine Zeile weiter
                tst.w   (A5)+
                bmi.s   a_if15          ;Ende des Sourcetext
                moveq   #0,D0
                move.w  (A5),D0
                cmp.w   #$2A00,D0       ;ELSE-Befehl
                beq.s   a_if16
                cmp.w   #$2C00,D0       ;ENDC-Befehl
                bne.s   a_if13
                moveq   #0,D0
                bra     a_dc14
a_if16:         move.b  #1,if_flag(A4)
                moveq   #0,D0
                bra     a_dc14
a_if15:         moveq   #32,D0          ;IF nicht abgeschlossen
                lea     -10(A5),A5
                bsr     _mark_error
                bra     a_pass2
a_if17:         moveq   #32,D0
                bsr     _mark_error
                bra     a_dc14
a_if1:          move.w  2(A5),D0        ;Index holen
                and.l   #$3FFF,D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel?
                beq.s   a_if11          ;nein (IFD,IFND)
                bsr     a_calc_formel   ;Formel ausrechnen
                move.l  0(A3,D0.l),D1   ;Wert holen
a_if10:         moveq   #0,D0
                move.b  1(A5),D0        ;Condition
                add.w   D0,D0           ;mal 2
                tst.l   D1              ;Bedingung testen
                jmp     a_if14(PC,D0.w) ;und Flagauswertung anspringen
a_if14:         nop                     ;IF ohne Condition
                bra.s   a_if12
                seq     D1              ;IFEQ
                bra.s   a_if12
                sne     D1              ;IFNE
                bra.s   a_if12
                sgt     D1              ;IFGT
                bra.s   a_if12
                sge     D1              ;IFGE
                bra.s   a_if12          ;besser als selbstmodifizierender Code
                slt     D1              ;IFLT
                bra.s   a_if12
                sle     D1              ;IFLE
                bra.s   a_if12
                smi     D1              ;IFD
                bra.s   a_if12
                spl     D1              ;IFND
                bra.s   a_if12
                smi     D1              ;???
                bra.s   a_if12
                spl     D1              ;???
a_if12:         rts

a_else:         tst.b   if_flag(A4)
                bpl.s   a_else10
a_else11:       adda.w  -2(A5),A1
                addq.w  #1,D6
                addq.l  #8,A5           ;nächste Zeile
                tst.w   (A5)+
                bmi.s   a_if15          ;letzte Zeile
                moveq   #0,D0
                cmpi.b  #$2C,(A5)       ;ENDC
                bne.s   a_else11
                sf      if_flag(A4)
                bra     a_dc14
a_else10:       moveq   #33,D0          ;ELSE ohne IF
                bsr     _mark_error
                bra     a_dc14
a_endc:         tst.b   if_flag(A4)
                beq.s   a_endc10
                sf      if_flag(A4)
                bra     a_dc14
a_endc10:       moveq   #34,D0          ;ENDC ohne IF
                bsr     _mark_error
                bra     a_dc14
a_cnop:         move.l  A6,D2
                moveq   #0,D0
                move.b  1(A5),D0        ;Alignment
                move.l  D0,D1
                bsr     ldiv            ;D2=D2/D1
                move.l  D0,D1
                bsr     lmult           ;D2=D2*D1
                add.l   D0,D2
                movea.l D2,A6
                adda.w  2(A5),A6        ;Offset
                bra     a_dc14

a_outp:         st      output_flag(A4) ;Flag für gefundenen OUTPUT setzen
                move.l  A1,-(SP)
                moveq   #0,D1
                move.w  2(A5),D1
                lsl.l   #5,D1
                lea     31(A3,D1.l),A0  ;Zeiger auf Ende des Filenamen
                moveq   #31,D2
a_outp2:        cmpi.b  #'\',-(A0)
                dbeq    D2,a_outp2
                addq.l  #1,A0
                move.l  A0,D0
                lea     fname_code(A4),A1
                moveq   #11,D2
a_outp3:        move.b  (A0)+,(A1)+     ;Filename kopieren
                dbeq    D2,a_outp3
                lea     0(A3,D1.l),A0
                lea     fpath_code(A4),A1
                cmp.l   A0,D0
                beq.s   a_outp5
a_outp4:        move.b  (A0)+,(A1)+     ;Pfadnamen kopieren
                cmp.l   A0,D0
                bne.s   a_outp4
                move.b  #'*',(A1)+
                move.b  #'.',(A1)+
                move.b  #'*',(A1)+
                clr.b   (A1)
a_outp5:        lea     zreserve(A4),A1 ;Buffer für Commandline
                clr.w   (A1)
                tst.w   -2(A5)          ;Commandline vorhanden?
                beq.s   a_outp6         ;nein
                movea.l (SP),A0         ;Zeiger auf Commandline
                addq.l  #1,A1
                moveq   #-1,D0
a_outp7:        addq.w  #1,D0           ;Zeichen zählen
                move.b  (A0)+,(A1)+     ;kopieren
                bne.s   a_outp7
                move.b  #13,-1(A1)      ;CR als Abschluß
                clr.b   (A1)
                move.b  D0,zreserve(A4) ;Länge speichern
a_outp6:        moveq   #0,D0
                movea.l (SP)+,A1
                adda.w  -2(A5),A1       ;Programmcode-Zeiger korregieren
                bra     a_dc14

a_ibytes:       move.l  A1,-(SP)
                moveq   #0,D1
                move.w  2(A5),D1        ;Index holen
                lsl.l   #5,D1
                lea     0(A3,D1.l),A0   ;Zeiger auf Eintrag
                move.w  #7,-(SP)        ;read-only, hidden & system suchen
                pea     12(A0)          ;Filename
                move.w  #$4E,-(SP)
                bsr     do_trap_1       ;Fsfirst
                addq.l  #8,SP
                tst.w   D0
                bmi     a_ibytes12      ;Fehler beim Zugriff
                lea     dta_buffer(A4),A1 ;Zeiger auf DTA-Buffer
                move.l  26(A1),D0       ;Dateilänge
                cmp.l   4(A0),D0        ;Position größer Dateilänge ?
                blo     a_ibytes13      ;ja, Fehler
                sub.l   D0,D5
                add.l   4(A0),D5
                ble     a_ibytes14      ;Speicher voll
                moveq   #1,D0
                jsr     _graf_mouse
                clr.w   -(SP)
                pea     12(A0)
                move.w  #$3D,-(SP)
                bsr     do_trap_1       ;Fopen
                addq.l  #8,SP
                tst.w   D0
                bmi.s   a_ibytes12      ;Fehler
                move.w  D0,fhandle(A4)
                clr.w   -(SP)
                move.w  D0,-(SP)
                move.l  4(A0),-(SP)
                move.w  #$42,-(SP)
                bsr     do_trap_1       ;Fseek
                lea     10(SP),SP
                move.l  A6,-(SP)
                move.l  (A0),-(SP)
                bne.s   a_ibytes11      ;Anzahl angegeben
                move.l  #$FFFFFF,(SP)   ;Lesen bis zum Dateiende
a_ibytes11:     move.w  fhandle(A4),-(SP)
                move.w  #$3F,-(SP)
                bsr     do_trap_1       ;Fread
                lea     12(SP),SP
                tst.l   D0
                bmi.s   a_ibytes12      ;Fehler
                move.l  D0,8(A0)        ;Anzahl der gelesenen Bytes eintragen
                adda.l  D0,A6
                bsr     fclose
                moveq   #0,D0
                jsr     _graf_mouse
                movea.l (SP)+,A1
                moveq   #0,D0
                bra     a_dc14
a_ibytes12:     moveq   #0,D0           ;Fehler beim Laden
                jsr     _graf_mouse
                movea.l (SP)+,A1
a_ibytes121:    moveq   #-3,D0          ;Fehler beim Lesen
                swap    D0
                move.w  D6,D0           ;Zeilennummer
                rts
a_ibytes13:     moveq   #11,D0
                bsr     _mark_error     ;'Position außerhalb der Datei'
                moveq   #0,D0
                jsr     _graf_mouse
                movea.l (SP)+,A1
                moveq   #0,D0
                bra     a_dc14
a_ibytes14:     movea.l (SP)+,A1
                bra     out_of_mem

a_path:         moveq   #0,D0
                moveq   #0,D1
                move.w  2(A5),D1        ;Index holen
                lsl.l   #5,D1
                lea     0(A3,D1.l),A0   ;Zeiger auf Pfadnamen
                cmpi.b  #':',1(A0)
                bne.s   a_path2
                move.b  (A0),D0
                subi.w  #'A',D0
                move.w  D0,-(SP)
                move.w  #$0E,-(SP)
                bsr     do_trap_1       ;Dsetdrv
                addq.l  #4,SP
                addq.l  #2,A0
a_path2:        move.l  A0,-(SP)
                move.w  #$3B,-(SP)
                bsr     do_trap_1       ;Dsetpath
                addq.l  #6,SP
                bra     a_dc14

a_isymbol:      moveq   #0,D1
                move.w  2(A5),D1        ;Index holen
                lsl.l   #5,D1
                lea     0(A3,D1.l),A0   ;Zeiger auf Filename
                bsr     s_load_sym0     ;SYM-File laden und Symbole updaten
                tst.w   D0
                bne.s   a_ibytes121     ;Fehler beim Laden oder Formatfehler
                bra     a_dc14

a_rsset:        move.l  (A5),D0
                and.l   #$0FFFFF,D0
                btst    #6,1(A5)        ;Symbol
                bne.s   a_rsset01       ;ja
                btst    #19,D0          ;Vorzeichenbit testen
                beq.s   a_rsset02       ;positiv
                or.l    #$FFF00000,D0   ;negativ machen
a_rsset02:      move.l  D0,rs_count(A4)
                bra     a_dc14
a_rsset01:      lsl.l   #5,D0
                move.l  0(A3,D0.l),rs_count(A4)
                bra     a_dc14
a_rsreset:      clr.l   rs_count(A4)
                bra     a_dc14
a_rsbss:        move.l  rs_count(A4),D0
                add.l   D0,rs_merk(A4)
                clr.l   rs_count(A4)
                bra     a_dc14
a_rseven:       move.l  rs_count(A4),D0
                addq.l  #1,D0
                andi.w  #$FFFE,D0       ;Counter begradigen
                move.l  D0,rs_count(A4)
                bra     a_dc14
a_breakp:       moveq   #0,D0
                move.w  D7,D0           ;Länge des Strings
                subq.l  #2,D5
                sub.l   D0,D5
                bls     out_of_mem      ;Zielcodespeicher am Ende
                clr.b   (A6)+
                move.l  A6,D0           ;Adresse begradigen
                bclr    #0,D0
                seq     1(A5)           ;wenn Füllbyte nötig war, 1(a5)<>0
                movea.l D0,A6
                move.w  #$4848,(A6)+    ;bkpt #0
                move.w  D7,D0
                bra.s   a_breakp02
a_breakp01:     move.b  (A1)+,(A6)+     ;Text übertragen
a_breakp02:     dbra    D0,a_breakp01
                bra     a_dc14

a_dxset:        moveq   #0,D0
                move.b  2(A5),D0        ;Anzahl holen
                move.w  D0,dx_anzahl(A4)
                move.b  3(A5),D0        ;Füllbyte holen
                move.b  D0,dx_wert(A4)
                bra     a_dc14
a_dx:           moveq   #0,D0
                move.w  2(A5),D0        ;Index holen
                lsl.l   #5,D0
                lea     0(A3,D0.l),A2
                moveq   #0,D0
                move.w  dx_anzahl(A4),D0 ;Anzahl
                sub.l   D0,D5
a_pat2:         bls     out_of_mem      ;Zielcodespeicher am Ende
                subq.w  #1,D0           ;minus 1
a_dx01:         move.b  (A2)+,(A6)+
                dbeq    D0,a_dx01
                bne.s   a_dx02          ;Anzahl erreicht
                subq.w  #1,A6
a_dx03:         move.b  dx_wert(A4),(A6)+ ;Rest mit Wert auffüllen
                dbra    D0,a_dx03
                moveq   #0,D0
                bra     a_dc14
a_dx02:         tst.b   (A2)            ;Ende erreicht
                bne.s   a_dx04          ;nein
                moveq   #0,D0
                bra     a_dsb1
a_dx04:         moveq   #30,D0          ;'String zu lang'
                bsr     _mark_error
                bra     a_dsb1
a_even:         clr.b   (A6)+
                move.l  A6,D0
                bclr    #0,D0           ;Adresse gerade machen
                seq     1(A5)           ;wenn Füllbyte nötig war, 1(a5)<>0
                movea.l D0,A6
                bra     a_copy4
a_data:         clr.b   (A6)+
                move.l  A6,D0
                bclr    #0,D0           ;Adresse gerade machen
                seq     1(A5)           ;wenn Füllbyte nötig war, 1(a5)<>0
                movea.l D0,A6
                move.l  D0,segm_adr+4(A4) ;Startadresse des DATA-Segments
                sub.l   D4,D0           ;Länge des TEXT-Segments
                movea.l ass_adr(A4),A0
                move.l  D0,2(A0)        ;in Header eintragen
                moveq   #1,D3
                move.b  #4,sym_typ(A4)
                bra     a_copy4
a_bss:          clr.b   (A6)+
                move.l  A6,D0
                bclr    #0,D0           ;Adresse gerade machen
                seq     1(A5)           ;wenn Füllbyte nötig war, 1(a5)<>0
                movea.l D0,A6
                move.l  D0,segm_adr+8(A4) ;Startadresse des BSS-Segments
                move.w  #$6004,a_copy2  ;BRA.S *+4 einsetzen
                move.w  #$6000+(a_bss_error2-a_copy6-2),a_copy6 ;BRA.S a_bss_error
                move.w  #a_bss_error-a_tab,D7
                move.w  D7,a_tab01      ;DX, DCB und IBYTES auf Fehler
                move.w  D7,a_tab02
                move.w  D7,a_tab03
                move.w  #$6000,a_dc+2   ;BRA a_bss_error
                move.w  #a_bss_error-a_dc-4,a_dc+4
                move.b  #a_dsll2-a_dsll,a_dsll-1 ;DS schreibt nichts mehr in
                move.b  #a_dswl2-a_dswl,a_dswl-1 ;den Speicher
                move.b  #a_dsbl2-a_dsbl,a_dsbl-1
                move.b  #a_dsll2-a_dsll3-2,a_dsll3+1
                move.b  #a_dswl2-a_dswl3-2,a_dswl3+1
                move.b  #a_dsbl2-a_dsbl3-2,a_dsbl3+1
                move.w  #$6002,D7       ;BLS out_of_mem durch BRA.S *+2
                move.w  D7,a_pat1       ;ersetzen
                move.w  D7,a_pat2
                move.w  D7,a_pat3
                move.w  D7,a_pat4
                move.w  D7,a_pat5
                move.w  D7,a_pat6
                move.w  D7,a_pat7
                move.w  #$528E,D7
                move.w  D7,a_dsl
                move.w  D7,a_dsw
                move.w  D7,a_pass2
                bsr     clr_cache
                moveq   #0,D7
                move.b  #1,sym_typ(A4)
                movea.l ass_adr(A4),A0
                sub.l   D4,D0
                sub.l   2(A0),D0        ;minus Länge TEXT-Segment
                tst.w   D3              ;=1, wenn DATA-Segment existiert
                beq.s   a_bss1
                move.l  D0,6(A0)        ;in Header eintragen
                moveq   #2,D3
                bra     a_copy4
a_bss1:         move.l  D0,2(A0)        ;als TEXT-Länge eintragen
                moveq   #2,D3
                bra     a_copy4

a_equ04:        moveq   #0,D1
                move.w  4(A5),D1        ;Index der Symboldef
                lsl.l   #5,D1
                move.b  #$FE,5(A3,D1.l) ;Flag für Konstante
                bset    #7,4(A3,D1.l)   ;defined-bit setzen
                bne.s   a_equ03         ;doppelte Deklaration
                bra     a_dc14
a_equ:          tst.b   1(A5)           ;Symbol/Formel
                beq.s   a_equ04         ;nein, direkter Wert
                moveq   #0,D0
                move.w  2(A5),D0        ;Index
                and.w   #$3FFF,D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel ?
                beq.s   a_equ01         ;nein
                bsr     a_calc_formel
a_equ01:        moveq   #0,D1
                move.w  4(A5),D1        ;Index des Zielsymbols
                lsl.l   #5,D1
                bset    #7,4(A3,D1.l)
                bne.s   a_equ03
                move.l  0(A3,D0.l),0(A3,D1.l) ;Wert übertragen
                move.w  4(A3,D0.l),4(A3,D1.l) ;Flags übertragen
                bpl.s   a_equ02         ;undefined
                tst.b   4(A3,D1.l)      ;Typ
                blt     a_dc14          ;Label und Konstante, ok
                moveq   #14,D0          ;unerlaubter Operant
                bsr     _mark_error
                bra     a_dc14
a_equ02:        moveq   #19,D0          ;undefiniertes Symbol
                bsr     _mark_error
                bra     a_dc14
a_equ03:        moveq   #4,D0           ;Redefinition
                bsr     _mark_error
                bra     a_dc14
a_set:          moveq   #0,D0
                move.w  2(A5),D0
                lsl.l   #5,D0
                bsr     a_calc_formel
                moveq   #0,D1
                move.w  4(A5),D1        ;Index des Zielsymbols
                lsl.l   #5,D1
                cmpi.b  #$FE,5(A3,D1.l)
                beq.s   a_set01         ;EQU-Wert
                move.l  0(A3,D0.l),0(A3,D1.l) ;Wert übertragen
                move.w  4(A3,D0.l),4(A3,D1.l) ;Flags übertragen
                moveq   #0,D0
                bra     a_dc14
a_set01:        moveq   #37,D0
                bsr     _mark_error
                moveq   #0,D0
                bra     a_dc14
a_switch:       tst.b   switch_flag(A4)
                bne.s   a_switch11
                moveq   #0,D0
                move.w  2(A5),D0
                lsl.l   #5,D0
                bsr     a_calc_formel
                move.w  2(A3,D0.l),switch_wert(A4) ;Ergebnis merken
                move.l  A5,switch_adr(A4) ;Zeileninfoadresse merken
                st      switch_flag(A4)
                moveq   #0,D0
                bra     a_dc14
a_switch11:     moveq   #38,D0          ;SWITCH nicht abgeschlossen
                move.l  A5,-(SP)
                movea.l switch_adr(A4),A5 ;auf SWITCH-Befehl
                bsr     _mark_error
                movea.l (SP)+,A5
                bra     a_dc14
a_switch12:     moveq   #0,D0
                st      switch_aktiv(A4) ;SWITCH ist in der CASE-Struktur
                bra     a_dc14
a_switch13:     moveq   #38,D0
                movea.l switch_adr(A4),A5 ;auf SWITCH-Befehl
                bsr     _mark_error
                bra     a_pass2

a_case:         tst.b   switch_flag(A4) ;Gab's einen SWITCH-Befehl?
                beq.s   a_case11        ;Nein => Fehler
a_case13:       tst.b   switch_aktiv(A4) ;SWITCH bereits in CASE?
                bne.s   a_case12        ;Ja! => Nichts vergleichen
                tst.b   1(A5)
                bmi.s   a_switch12      ;default-CASE
                move.w  2(A5),D0        ;CASE-Wert holen
                cmp.w   switch_wert(A4),D0
                beq.s   a_switch12      ;gleich
a_case12:       adda.w  -2(A5),A1
                addq.w  #1,D6
                addq.l  #8,A5           ;nächste Zeile
                tst.w   (A5)+
                bmi.s   a_switch13      ;letzte Zeile
                cmpi.b  #$44,(A5)       ;ENDS
                beq.s   a_ends12
                cmpi.b  #$40,(A5)       ;SWITCH
                beq.s   a_switch11      ;Fehler
                cmpi.b  #$42,(A5)       ;CASE
                bne.s   a_case12
                bra.s   a_case13        ;CASE ausführen
a_case11:       moveq   #39,D0          ;CASE ohne SWITCH
                bsr     _mark_error
                moveq   #0,D0
                bra     a_dc14

a_ends:         tst.b   switch_flag(A4)
                beq.s   a_ends11
a_ends12:       sf      switch_flag(A4)
                sf      switch_aktiv(A4)
                bra     a_dc14
a_ends11:       moveq   #40,D0          ;ENDS ohne SWITCH
                bsr     _mark_error
                bra     a_dc14

a_global:       moveq   #0,D0
                move.w  2(A5),D0        ;Index des GLOBAL-Eintrags
                lsl.l   #5,D0
                lea     0(A3,D0.l),A0   ;Zeiger auf Eintrag
a_global2:      moveq   #0,D0
                move.w  (A0)+,D0        ;Symbolindex holen
                bmi.s   a_global1       ;Ende des Eintrags
                lsl.l   #5,D0
                ori.b   #$20,4(A3,D0.l) ;GLOBAL-Flag setzen
                bra.s   a_global2       ;zum nächsten Index
a_global1:      bra     a_dc14

a_common:       moveq   #0,D0
                move.w  4(A5),D0        ;Index des Symbols
                lsl.l   #5,D0
                lea     0(A3,D0.l),A0   ;Zeiger auf Symboleintrag
                move.w  #$A8FF,4(A0)    ;defined,global,external & Konstante
                moveq   #0,D0
                move.w  2(A5),D0        ;Index der Formel
                lsl.l   #5,D0
                bsr     a_calc_formel   ;Wert (=Bufferlänge) berechnen
                move.l  0(A3,D0.l),(A0) ;und als Symbolwert sichern
                bra     a_dc14

a_default:      move.w  2(A5),default_but(A4) ;Buttonnr. merken
                bra     a_dc14

a_ds:           moveq   #$30,D1         ;Flag für Konstante/Formel
                and.b   1(A5),D1
                moveq   #0,D0
                move.w  2(A5),D7        ;Anzahl/Index
                cmp.b   #$30,D1         ;Konstante/Formel
                bne.s   a_ds01          ;nein
                move.w  D7,D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Erkennungflag testen
                beq.s   a_ds02          ;keine Formel
                bsr     a_calc_formel   ;Formel ausrechnen
a_ds02:         move.l  0(A3,D0.l),D7   ;Wert holen
                tst.b   4(A3,D0.l)      ;defined-flag
                bmi.s   a_ds03
                moveq   #19,D0          ;"Symbol nicht definiert"
                bra.s   a_ds07
a_ds03:         tst.b   5(A3,D0.l)      ;Typ
                bmi.s   a_ds04          ;Konstante
                moveq   #22,D0          ;"Label hier nicht erlaubt"
a_ds07:         bsr     _mark_error
                bra.s   a_ds06
a_ds04:         tst.l   D7              ;Wert testen
                bpl.s   a_ds01          ;positiv
                moveq   #20,D0          ;"Wert wird negativ"
                bsr     _mark_warn
a_ds06:         moveq   #0,D7           ;nichts erzeugen
a_ds01:         move.l  (A1)+,D2        ;Füllwert
                move.b  1(A5),D1
                and.w   #$C0,D1         ;Flags für Breite
                cmp.w   #$40,D1
                blt     a_dsb
                beq.s   a_dsw
a_dsl:          clr.b   (A6)+
                move.l  A6,D0
                bclr    #0,D0
                movea.l D0,A6
                bne.s   a_dsl0
                moveq   #25,D0          ;'Adresse wurde begradigt'
                bsr     _mark_warn
a_dsl0:         sub.l   D7,D5
                sub.l   D7,D5
                sub.l   D7,D5
                sub.l   D7,D5
a_pat3:         bls     out_of_mem      ;Zielcodespeicher am Ende
                moveq   #0,D0
                move.w  4(A5),D0        ;Labelindex
a_dsll3:        bmi.s   a_dsll1         ;kein Label
                lsl.l   #5,D0
                bset    #7,4(A3,D0.l)
                bne.s   a_dsl10
                move.l  A6,0(A3,D0.l)   ;Adresse übertragen
                move.b  sym_typ(A4),D1
                or.b    D1,4(A3,D0.l)
a_dsl11:        bra.s   a_dsll1         ;Sprung wird gepatched
a_dsll:         move.l  D2,(A6)+        ;DS.L
a_dsll1:        dbra    D7,a_dsll
                bra     a_copy4
a_dsll2:        lsl.l   #2,D7
                adda.l  D7,A6
                moveq   #0,D7
                bra     a_copy4
a_dsl10:        moveq   #4,D0           ;'Redefinitionsfehler'
                bsr     _mark_error
                bra.s   a_dsl11
a_dsw:          clr.b   (A6)+
                move.l  A6,D0
                bclr    #0,D0
                movea.l D0,A6
                bne.s   a_dsw0
                moveq   #25,D0          ;'Adresse wurde begradigt'
                bsr     _mark_warn
a_dsw0:         sub.l   D7,D5
                sub.l   D7,D5
a_pat4:         bls     out_of_mem      ;Zielcodespeicher am Ende
                moveq   #0,D0
                move.w  4(A5),D0        ;Labelindex
a_dswl3:        bmi.s   a_dswl1         ;kein Label
                lsl.l   #5,D0
                bset    #7,4(A3,D0.l)
                bne.s   a_dswl5
                move.l  A6,0(A3,D0.l)   ;Adresse übertragen
                move.b  sym_typ(A4),D1
                or.b    D1,4(A3,D0.l)
a_dswl4:        bra.s   a_dswl1         ;Sprung wird gepatched
a_dswl:         move.w  D2,(A6)+        ;DS.W
a_dswl1:        dbra    D7,a_dswl
                bra     a_copy4
a_dswl2:        add.l   D7,D7
                adda.l  D7,A6
                moveq   #0,D7
                bra     a_copy4
a_dswl5:        moveq   #4,D0           ;'Redefinitionsfehler'
                bsr     _mark_error
                bra.s   a_dswl4
a_dsb:          sub.l   D7,D5
a_pat5:         bls     out_of_mem      ;Zielcodespeicher am Ende
                moveq   #0,D0
                move.w  4(A5),D0        ;Labelindex
a_dsbl3:        bmi.s   a_dsbl1         ;kein Label
                lsl.l   #5,D0
                bset    #7,4(A3,D0.l)
                bne.s   a_dsbl5
                move.l  A6,0(A3,D0.l)   ;Adresse übertragen
                move.b  sym_typ(A4),D1
                or.b    D1,4(A3,D0.l)
a_dsbl4:        bra.s   a_dsbl1         ;Sprung wird gepatched
a_dsbl:         move.b  D2,(A6)+        ;DS.B
a_dsbl1:        dbra    D7,a_dsbl
                bra.s   a_dsb1
a_dsbl2:        adda.l  D7,A6
                moveq   #0,D7
a_dsb1:         bra     a_dc14
a_dsbl5:        moveq   #4,D0           ;Redefinition
                bsr     _mark_error
                bra.s   a_dsbl4

a_dc:           moveq   #0,D1
                move.b  1(A5),D1        ;Operationsbreite
                beq.s   a_dc11          ;DC.B
                clr.b   (A6)+
                move.l  A6,D0
                bclr    #0,D0           ;Adresse gerade machen
                movea.l D0,A6
                bne.s   a_dc01
                moveq   #25,D0          ;'Adresse wurde begradigt'
                bsr     _mark_warn
a_dc01:         moveq   #0,D0
                move.w  4(A5),D0        ;Labelindex
                bmi.s   a_dcl01         ;kein Label
                lsl.l   #5,D0
                bset    #7,4(A3,D0.l)
                bne.s   a_dcl14
                move.l  A6,0(A3,D0.l)   ;Adresse übertragen
                move.b  sym_typ(A4),D1
                or.b    D1,4(A3,D0.l)
a_dcl01:        sub.l   D7,D5
a_pat6:         bls     out_of_mem
                lsr.w   #1,D7
                bra.s   a_dcl12
a_dc12:         move.w  (A1)+,(A6)+     ;DC.W und DC.L
a_dcl12:        dbra    D7,a_dc12
                bra     a_copy4
a_dcl14:        moveq   #4,D0           ;Redefinition
                bsr     _mark_error
                bra.s   a_dcl01
a_dcl15:        moveq   #4,D0           ;Redefinition Fehler
                bsr     _mark_error
                bra.s   a_dcl13
a_dc11:         sub.l   D7,D5
a_pat7:         bls     out_of_mem
                moveq   #0,D0
                move.w  4(A5),D0        ;Labelindex
                bmi.s   a_dcl13         ;kein Label
                lsl.l   #5,D0
                bset    #7,4(A3,D0.l)
                bne.s   a_dcl15
                move.l  A6,0(A3,D0.l)   ;Adresse übertragen
                move.b  sym_typ(A4),D1
                or.b    D1,4(A3,D0.l)
                bra.s   a_dcl13
a_dc13:         move.b  (A1)+,(A6)+
a_dcl13:        dbra    D7,a_dc13
                tst.w   2(A5)
                bpl.s   a_dc14          ;wenn ungerade Anzahl, dann eins
                subq.l  #1,A6           ;abziehen
a_dc14:         tst.l   8(A5)           ;Länge und Operand testen
                bne.s   a_dc15          ;keine Leerzeile
                move.w  14(A5),D0       ;Wurde ein Label in der Zeile definiert?
                bmi.s   a_dcb16         ;nö
                ext.l   D0
                lsl.l   #5,D0           ;Labelnummer * 32
                bset    #7,4(A3,D0.l)
                bne.s   a_dcb17
                move.l  A6,0(A3,D0.l)   ;Destadr in die Labeltabelle
                move.b  sym_typ(A4),D1
                or.b    D1,4(A3,D0.l)
                moveq   #0,D0           ;D0 wieder löschen
a_dcb16:        lea     10(A5),A5       ;eine Zeile weiter
                addq.w  #1,D6
                bra.s   a_dc14
a_dc15:         cmpi.b  #2,10(A5)       ;nächste Zeile testen
                bge     a_copy4         ;Spezialbefehl
                clr.b   (A6)+           ;in der nächsten Zeile ein
                move.l  A6,D1           ;normaler Opcode -> Adresse
                bclr    #0,D1           ;muß gerade sein
                movea.l D1,A6
                bne     a_copy4         ;war gerade
                lea     10(A5),A5       ;eine Zeile vor
                moveq   #25,D0          ;'Adresse wurde begradigt'
                bsr     _mark_warn
                lea     -10(A5),A5      ;wieder zurück
                moveq   #0,D0
                bra     a_copy4

a_dcb17:        moveq   #4,D0           ;Redefinition
                bsr     _mark_error
                moveq   #0,D0
                bra.s   a_dcb16
                ENDPART
                >PART 'a_pass2'
************************************************************************
* Der 2.Pass                                                           *
************************************************************************
a_pass2:        clr.b   (A6)+
                move.l  A6,D0
                and.w   #$FFFE,D0       ;EVEN
                movea.l D0,A6           ;erste freie Adr hinter dem Programm
                sub.l   D4,D0           ;Gesamtlänge
                movea.l ass_adr(A4),A0  ;Start
                move.l  rs_merk(A4),10(A0) ;Größe des RS-BSS-Bereichs einsetzen
                addq.w  #2,A0
                bra.s   a_pas24
a_pas25:        sub.l   (A0)+,D0        ;Länge der vorhergehenden
a_pas24:        dbra    D3,a_pas25      ;Segmente abziehen
                add.l   D0,(A0)         ;Teillänge in den Header
                tst.l   segm_adr+4(A4)  ;DATA-Segment definiert?
                bne.s   a_pas26         ;Ja! =>
                move.l  segm_adr+8(A4),D0 ;Anfangadr des BSS-Segments
                bne.s   a_pas28         ;vorhanden =>
                move.l  A6,D0
a_pas28:        move.l  D0,segm_adr+4(A4) ;DATA-Segment-Adr setzen
a_pas26:        tst.l   segm_adr+8(A4)  ;BSS-Segment definiert?
                bne.s   a_pas27         ;Ja! =>
                move.l  A6,segm_adr+8(A4) ;BSS-Segment-Adr setzen
a_pas27:        bra.s   a_pass4

a_return2:      tst.b   reloc_fl(A4)
                bmi.s   a_retur
                clr.b   (A2)+
                clr.b   (A2)+
                clr.b   (A2)+           ;Kein Relocinfo
a_retur:        clr.b   (A2)+           ;Abschuß des Relocinfos
                move.l  segm_adr+4(A4),D0 ;Stadr des DATA-Seg
                sub.l   D0,segm_adr+8(A4) ;- Stadr des BSS-Seg = DATA-Länge
                move.l  segm_adr(A4),D0 ;Stadr des TEXT-Seg
                sub.l   D0,segm_adr+4(A4) ;- Stadr des DATA-Seg = TEXT-Länge
                moveq   #0,D0
                tst.b   opt_p_flag(A4)
                beq.s   a_retur2        ;OPT P nicht aktiv
                tst.b   reloc_fl(A4)
                bpl.s   a_retur2        ;kein Relocinfo
                movea.l ass_adr(A4),A0  ;Startadresse
                lea     $1C(A0),A2      ;plus Länge Header=Start Relocinfo
                adda.l  2(A0),A2        ;plus Länge TEXT
                adda.l  6(A0),A2        ;plus Länge DATA
                move.l  (A2),D1         ;Offset aus Relocinfo holen
                bsr     s_calc_line     ;Zeile berechnen
                or.l    #$FFFC0000,D0   ;-4 als Fehlerkennung
a_retur2:       rts

a_pass4:        clr.b   reloc_fl(A4)
                move.b  #'2',ass_rsc9
                sf      switch_flag(A4)
                sf      switch_aktiv(A4)
                move.w  #8,dx_anzahl(A4)
                move.w  #$FFFF,rept_pointer(A4)
                movea.l label_base(A4),A3 ;Zeiger auf Labeltabelle
                movea.l z_info_base(A4),A5 ;Zeiger auf Tabelle der Zeile
                movea.l ass_adr(A4),A6  ;Startadresse
                movea.l A6,A2
                adda.l  2(A6),A2        ;plus Länge TEXT
                adda.l  6(A6),A2        ;plus Länge DATA
                lea     $1C(A2),A2      ;plus Länge Header=Start Relocinfo
                clr.l   (A2)            ;Vorbesetzung Relocinfo
                move.l  max_code_len(A4),D4
                move.l  A2,D0
                sub.l   A6,D0           ;ak. Länge des Programms
                sub.l   D0,D4
                move.l  D4,end_adr(A4)  ;Anzahl freie Bytes für Relocinfo
                moveq   #4,D0
                cmp.l   D0,D4
                blt     out_of_mem      ;weniger als 4 Bytes -> reicht nicht
                lea     $1C(A6),A6      ;Start des TEXT-Segments
                move.l  A6,D4
                clr.l   rs_count(A4)
                moveq   #-1,D6
                moveq   #0,D0
a_pass4loop2:   move.l  D6,base_adreßreg(A4,D0.w) ;Default für BASE (erzeugt Fehler !)
                addq.w  #4,D0
                cmp.w   #36,D0
                bls.s   a_pass4loop2
                moveq   #0,D6           ;Zeile = 0
                moveq   #0,D0           ;oberes Word immer 0!
                move.l  A6,D5           ;Distanz für Relocinfo
a_pass4loop:    move.w  (A5)+,D7
                tst.b   (A5)            ;high-Byte Operator
                beq.s   a_pas41
                lea     a_pas41(PC),A1
                moveq   #0,D0
                move.w  (A5),D0
                bmi.s   other_cmds      ;Quick
                cmp.w   #$0200,D0
                blo.s   nrm_label       ;Label
                bra     spez_cmds       ;Pseudoopcodes
a_pas41:        tst.b   2(A5)           ;high-Byte Operand
                beq.s   a_pas42
                lea     a_pas42(PC),A1
                moveq   #0,D0
                move.w  2(A5),D0
                bpl.s   nrm_label       ;Label
                bra.s   other_cmds      ;Quick
a_pas42:        adda.w  D7,A6           ;Nächster Opcode
                addq.w  #8,A5           ;Nächste Zeile
                addq.w  #1,D6           ;INC Zeilennr
                bra.s   a_pass4loop

other_cmds:     btst    #14,D0
                bne     quick           ;Quick
                bra     special         ;$xx(An,Rn.X)

************************************************************************
* Verwaltung normaler Labels                                           *
************************************************************************
;normales Label einsetzen
nrm_label:      moveq   #$0F,D1
                and.w   D0,D1           ;Einsetz-Offset
                lea     0(A6,D1.w),A0   ;Adresse für das Label
                btst    #5,D0
                beq     nrmlab1         ;kein Long
                move.w  D0,D1
;Long (kein PC-relativ mgl.)
                move.l  (A0),D0         ;Labelnummer holen
                lsl.l   #5,D0           ;mal Labelgröße
                tst.b   31(A3,D0.l)     ;Formel
                beq.s   nrm_label7      ;nein
                bsr     a_calc_formel
nrm_label7:     move.l  0(A3,D0.l),D2   ;Label holen
                tst.b   4(A3,D0.l)      ;defined-flag testen
                bpl     _qerr3          ;undefiniert!
                btst    #6,D1           ;Vorzeichen
                beq.s   nrm_label8
                neg.l   D2
nrm_label8:     tst.b   5(A3,D0.l)      ;Typflag testen
                bmi     nrm_label5      ;Konstante, nicht relozieren
                move.w  (A6),D3         ;Opcode holen
                cmp.w   #$2F3C,D3       ;MOVE.L #,-(SP)
                beq.s   nrm_label85     ;nach PEA wandeln => Warnung
                and.w   #$F1FF,D3
                cmp.w   #$207C,D3       ;MOVE.L #,An
                bne.s   nrm_label86     ;nach LEA wandeln => Warnung
                move.l  D0,D3
                moveq   #52,D0          ;Wandlung nach LEA sinnvoll!
                bsr     _mark_opt
                bra.s   nrm_label87
nrm_label85:    move.l  D0,D3
                moveq   #51,D0          ;Wandlung nach PEA sinnvoll!
                bsr     _mark_opt
nrm_label87:    move.l  D3,D0
nrm_label86:    move.l  D2,D1           ;Wert retten
                sub.l   D4,D2           ;minus TEXT-Start
                move.l  D2,(A0)         ;Label einsetzen
                sub.l   A0,D1           ;Offset ausrechnen
                cmp.l   #$7FFF,D1
                bls.s   nrm_label81     ;reicht für Word
                move.w  D1,D2
                ext.l   D2
                cmp.l   D2,D1
                bne     nrm_label82     ;kann nicht optimiert werden
nrm_label81:    move.w  (A6),D0         ;Opcode holen
                cmp.w   #$4EB9,D0       ;JSR
                beq     nrm_label83     ;ja
                cmp.w   #$4EF9,D0       ;JMP
                beq     nrm_label83     ;ja
                cmpa.l  #a_pas41,A1     ;Operator?
                bne     nrm_label82     ;Ja! => kein PC-rel möglich!
                and.w   #$F03F,D0       ;Maske für Datenregister ignorien
                cmp.w   #$1039,D0       ;MOVE.B adr.l,<ea>
                beq.s   nrm_label84     ;ja
                cmp.w   #$2039,D0       ;MOVE.L adr.l,<ea>
                beq.s   nrm_label84     ;ja
                cmp.w   #$3039,D0       ;MOVE.W adr.l,<ea>
                beq.s   nrm_label84     ;ja
                move.w  (A6),D0         ;Opcode nochmals holen
                cmp.w   #$0839,D0       ;BTST #x,adr.l
                beq.s   nrm_label84
                cmp.w   #$4879,D0       ;PEA adr.l
                beq.s   nrm_label84
                cmp.w   #$46F9,D0       ;MOVE adr.l,SR
                beq.s   nrm_label84
                and.w   #$FFBF,D0
                cmp.w   #$4CB9,D0       ;MOVEM.x <ea>,Reglist
                beq.s   nrm_label84
                cmp.w   #$81B9,D0       ;DIVS <ea>,Dn
                beq.s   nrm_label84
                cmp.w   #$C1B9,D0       ;MULS <ea>,Dn
                beq.s   nrm_label84
                move.w  (A6),D0         ;und den Opcode nochmals holen
                and.w   #$F1FF,D0
                cmp.w   #$0139,D0       ;BTST Dn,adr.l
                beq.s   nrm_label84
                cmp.w   #$41B9,D0       ;CHK adr.l,Dn
                beq.s   nrm_label84
                cmp.w   #$41F9,D0       ;LEA adr.l,An
                beq.s   nrm_label84
                cmp.w   #$B1F9,D0       ;CMPA.L <ea>,An
                beq.s   nrm_label84
                and.w   #$F13F,D0
                cmp.w   #$8039,D0       ;OR.x <ea>,Dn und DIVU <ea>,Dn
                beq.s   nrm_label84
                cmp.w   #$9039,D0       ;SUB.x <ea>,Dn und SUBA <ea>,An
                beq.s   nrm_label84
                cmp.w   #$C039,D0       ;AND.x <ea>,Dn und MULU <ea>,An
                beq.s   nrm_label84
                cmp.w   #$D039,D0       ;ADD.x <ea>,Dn und ADDA <ea>,An
                beq.s   nrm_label84     ;keine Optimierung möglich
                cmp.w   #$B039,D0       ;CMP.x <ea>,Dn und CMPA.W <ea>,An
                bne.s   nrm_label82
nrm_label84:    moveq   #50,D0          ;PC-relativ möglich
                move.l  (A0),D2         ;Labeladresse bezügl. TEXT-Start
                add.l   D4,D2           ;plus TEXT-Start
                cmp.l   segm_adr+4(A4),D2 ;mit Startadresse des DATA-Segments vergleichen
                blo.s   nrm_label842    ;Label im TEXT-Segment
                moveq   #55,D0          ;PC-relativ über Segmentgrenze
nrm_label842:   bsr     _mark_opt
                bra.s   nrm_label82
nrm_label83:    moveq   #42,D0          ;JSR -> BSR
                bsr     _mark_opt
nrm_label82:    move.l  A0,D2           ;Adresse retten
                suba.l  D5,A0           ;Distanz berechnen
                tas.b   reloc_fl(A4)
                bmi.s   nrm_label2      ;Byte-Offset
                move.l  A0,(A2)+        ;1. Relozierinfo
                move.l  D2,D5           ;neue Bezugsadresse
                subq.l  #4,end_adr(A4)
                ble.s   out_of_mem2
                jmp     (A1)
out_of_mem2:    bra     out_of_mem      ;Speicher voll
nrm_label5:     move.l  D2,(A0)         ;Wert einsetzen
                cmpi.b  #$FC,5(A3,D0.l) ;RS-Konstante ?
                beq.s   nrm_label51     ;ja
                move.w  D2,D0
                ext.l   D0
                cmp.l   D2,D0
                beq.s   nrm_label54     ;kann zu Short optimiert werden
                jmp     (A1)
nrm_label2:     move.l  A0,D1
                move.l  #254,D3
nrm_label4:     cmp.l   D3,D1
                bls.s   nrm_label3      ;Offset <= 254
                move.b  #1,(A2)+
                sub.l   D3,D1
                subq.l  #1,end_adr(A4)
                bgt.s   nrm_label4
nrm_label6:     bra     out_of_mem      ;Speicher voll
nrm_label3:     move.b  D1,(A2)+
                subq.l  #1,end_adr(A4)
                ble.s   nrm_label6
                move.l  D2,D5
                jmp     (A1)
nrm_label51:    moveq   #$0F,D0
                and.w   D1,D0           ;Der Einsetzoffset
                subq.b  #2,D0
                bne.s   nrm_wrn_rslong  ;<>2? dann raus =>
                moveq   #$F0,D0
                and.b   (A6),D0
                beq.s   nrm_label52     ;Immediate-Befehle => nie warnen
                moveq   #$3F,D0
                and.w   (A6),D0         ;<ea> holen
                cmp.w   #$3C,D0         ;Immediate
                beq.s   nrm_label52     ;dann keine Warnung
nrm_wrn_rslong: moveq   #46,D0
                bsr     _mark_warn      ;RS-Konstante als long
nrm_label52:    jmp     (A1)
nrm_label54:    moveq   #$3F,D0
                and.w   (A6),D0         ;EA extrahieren
                cmp.w   #$39,D0         ;absolut lang?
                bne.s   nrm_label55     ;keine Optimierung möglich
nrm_opt_short:  moveq   #54,D0
                bsr     _mark_opt       ;Short-Optimierung möglich
                jmp     (A1)
nrm_label55:    move.b  (A6),D0         ;Typ
                lsr.b   #4,D0
                subq.b  #1,D0
                cmp.b   #2,D0
                bhi.s   nrm_label52     ;kein MOVE.x =>
                moveq   #$0F,D0
                and.w   D1,D0           ;Einsetzoffset
                subq.w  #2,D0           ;gleich 2 (1.Operand)?
                beq.s   nrm_label52     ;ja, Test überflüssig
                move.w  #$0FC0,D0
                and.w   (A6),D0         ;Destination-<ea>
                cmp.w   #$03C0,D0       ;= absolut lang?
                bne.s   nrm_label52     ;Nein! =>
                bra.s   nrm_opt_short
;Word
nrmlab1:        move.w  D0,D1
                move.w  (A0),D0         ;Labelnummer holen
                lsl.l   #5,D0           ;mal Labelgröße
                tst.b   31(A3,D0.l)     ;Formel
                beq.s   nrmlab7         ;nein
                bsr     a_calc_formel
nrmlab7:        tst.b   4(A3,D0.l)      ;defined-flag testen
                bpl     _qerr3          ;undefiniert!
                move.l  0(A3,D0.l),D2   ;Wert holen
                tst.b   D1
                bmi     pc_relativw     ;PC-relativ
                btst    #6,D1           ;Vorzeichen
                beq.s   nrmlab8
                neg.l   D2
nrmlab8:        tst.b   5(A3,D0.l)      ;Typflag
                bmi.s   nrmlab4         ;Konstante
                bne     nrmlab5         ;Registerliste nicht erlaubt
                move.w  (A6),D0         ;Opcode holen
                cmp.w   #$3FFF,D0       ;MOVE ?
                bhi.s   nrmlab9         ;nein
                cmp.w   #$1000,D0       ;MOVE
                bhs.s   nrmlab10        ;ja
                andi.w  #$F138,D0
                cmp.w   #$0108,D0       ;MOVEP
                bne.s   nrmlab91        ;nein
                move.w  (A6),D0
                andi.w  #7,D0
                lsl.w   #2,D0
                move.l  base_adreßreg(A4,D0.w),D0 ;BASE-Wert holen
                bmi.s   nrmlab4         ;nicht aktiv
                sub.l   D0,D2           ;Offset bilden
                bra.s   nrmlab4
nrmlab10:       cmpa.l  #a_pas42,A1     ;Rücksprung
                bne.s   nrmlab9         ;erster Operand
                lsr.w   #3,D0           ;Ziel-EA umkopieren
                move.w  D0,D1
                lsr.w   #6,D1
                andi.w  #$38,D0
                andi.w  #7,D1
                or.w    D1,D0
                bra.s   nrmlab9
nrmlab91:       move.w  (A6),D0
nrmlab9:        andi.w  #$3F,D0         ;EA ausmaskieren
                sub.w   #$28,D0         ;d(A0) abziehen
                bmi.s   nrmlab4
                cmp.w   #7,D0           ;d(A7)
                bhi.s   nrmlab4
                lsl.w   #2,D0
                move.l  base_adreßreg(A4,D0.w),D0 ;BASE-Wert holen
                bmi.s   nrmlab4         ;nicht aktiv
                sub.l   D0,D2           ;Offset bilden
nrmlab4:        move.w  D2,D3
                ext.l   D3              ;Extend auf Long
                cmp.l   D2,D3           ;Label ein Long?
                bne.s   nrmlab3         ;Out of range!
nrmlab2:        move.w  D2,(A0)         ;Label in Objektcode einsetzen
                jmp     (A1)
nrmlab3:        move.l  D2,D0
                clr.w   D0
                tst.l   D0              ;paßt das Word doch?
                bne.s   nrmlab31        ;geht nicht!
                moveq   #20,D0          ;'Offset wird negativ'
                bsr     _mark_warn
                bra.s   nrmlab2
nrmlab31:       moveq   #18,D0          ;'Out of range'
                bsr     _mark_error
                st      optimize_flag(A4)
                bra.s   nrmlab2

nrmlab5:        moveq   #14,D0          ;'unerlaubter Operand'
                bsr     _mark_error
                bra.s   nrmlab2
pc_relativw:    btst    #6,D1           ;Vorzeichen
                beq.s   pc_relaw3
                neg.l   D2
pc_relaw3:      tst.b   5(A3,D0.l)      ;Typflag
                bmi.s   pc_relaw2       ;Konstante
                move.l  D2,D1           ;Symbolwert merken
                sub.l   A0,D2           ;minus dem aktuellen PC
                move.w  D2,D0           ;Unteres Word
                ext.l   D0              ;zu Long machen
                cmp.l   D0,D2
                bne.s   pc_relawe       ;ungleich => paßt nicht
pc_relaw1:      move.w  D2,(A0)         ;PC-Offset einsetzen
                cmp.l   segm_adr+4(A4),D1 ;mit Startadresse des DATA-Segments vergleichen
                blo.s   pc_relaw10      ;nicht über Segmentgrenze
                moveq   #56,D0          ;PC-relativ über Segmentgrenze
                bsr     _mark_opt
pc_relaw10:     move.b  (A6),D0         ;Befehlscode holen
                moveq   #$60,D1         ;Bitmaske für Bcc
                and.w   D1,D0
                cmp.w   D1,D0
                beq.s   pc_relaw11      ;ist Bcc
                jmp     (A1)
pc_relaw2:      move.w  D2,D0
                ext.l   D0
                cmp.l   D0,D2
                beq.s   pc_relaw1
                clr.w   D0
                tst.l   D0
                bne.s   pc_relawe       ;paßt nicht!
                moveq   #20,D0          ;Wert wird negativ
                bsr     _mark_warn
                bra.s   pc_relaw1
pc_relawe:      move.w  (A6),D0         ;Opcode holen
                and.w   #$F0F8,D0
                cmp.w   #$50C8,D0       ;DBRA Dn,?
                bne.s   pc_relawf       ;Nein! =>
                moveq   #18,D0
                bsr     _mark_error     ;Offset zu groß
                bra.s   pc_relaw1
pc_relawf:      moveq   #53,D0          ;Offset zu groß
                bsr     _mark_error
                st      optimize_flag(A4)
                bra.s   pc_relaw1
pc_relaw11:     tst.w   4(A5)           ;ein Label in der Zeile definiert?
                bpl.s   pc_relaw15      ;Ja! =>
                move.w  -12(A5),D0      ;Länge der vorherigen Zeile
                beq.s   pc_relaw15      ;Leerzeile
                neg.w   D0              ;abziehen
                cmpi.b  #$60,0(A6,D0.w) ;BRA in der letzten Zeile?
                bne.s   pc_relaw15
                moveq   #49,D0          ;Unnötiger Sprung
                bsr     _mark_warn
pc_relaw15:     cmp.w   #2,D2           ;Bcc auf nächste Adresse
                beq.s   pc_relaw13      ;Sprung auf die nächste Adresse
                cmp.w   #$80,D2
                bls.s   pc_relaw12
                move.b  D2,D0
                ext.w   D0
                cmp.w   D2,D0
                beq.s   pc_relaw12
                jmp     (A1)            ;kann nicht optimiert werden
pc_relaw12:     moveq   #41,D0          ;'kann zu Bcc.S optimiert werden'
                bsr     _mark_opt
                jmp     (A1)
pc_relaw13:     moveq   #$0F,D0
                and.b   (A6),D0
                subq.w  #1,D0           ;BSR rausfiltern
                beq.s   pc_relaw14
                moveq   #48,D0          ;Sprung auf die nächste Adresse
                bsr     _mark_warn
pc_relaw14:     jmp     (A1)

************************************************************************
* Quick- und sonstige Operanden                                        *
************************************************************************
quick:          and.w   #$3FFF,D0
                ext.l   D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel ?
                beq.s   quick01         ;nein
                bsr     a_calc_formel
quick01:        tst.b   4(A3,D0.l)      ;defined-flag testen
                bpl     _qerr3
                move.l  0(A3,D0.l),D3   ;Wert des Labels holen
                lea     quwtab-2(PC),A0 ;Zeiger auf Opcodetab
                move.w  (A6),D2         ;Opcode holen
quickl:         addq.w  #2,A0
                move.w  D2,D1           ;Opcode holen
                and.w   (A0)+,D1        ;entspr.Bits ausmaskieren
                cmp.w   (A0)+,D1        ;Opcode gefunden?
                bne.s   quickl          ;Nö!
                move.w  (A0),D1         ;Sprungoffset holen
                beq.s   quicke          ;Fehler (kein Opcode gefunden)
                adda.w  D1,A0
                jmp     (A0)            ;Ab in die Verwaltung
quicke:         moveq   #17,D0          ;Internal Error
                bsr     _mark_error
                jmp     (A1)

                BASE DC.W,*
quwtab:         DC.W $F0FF,$6002,_q4 ;BSR.S/BRA.S/...
                DC.W $F000,$7000,_q2 ;MOVEQ
                DC.W $FFF0,$4E40,_q3 ;TRAP
                DC.W $F000,$A000,_q3 ;LINEA
                DC.W $F0C0,$5000,_q1 ;ADDQ.B / SUBQ.B
                DC.W $F0C0,$5040,_q1 ;ADDQ.W / SUBQ.W
                DC.W $F0C0,$5080,_q1 ;ADDQ.L / SUBQ.L
                DC.W $F000,$E000,_q1 ;Rotationsbefehle
                DC.W $FFF8,$4848,_q5 ;BKPT
                DC.W 0,0,0

;ADDQ / SUBQ / Rotationsbefehle
_q1:            tst.l   D3
                beq.s   _qerr1          ;=0 ist nicht erlaubt
                moveq   #8,D1
                cmp.l   D1,D3
                bhi.s   _qerr1          ;>8 ist nicht erlaubt
                beq.s   _q12            ;8 wird zu 0 => nichts einsetzen
                add.b   D3,D3           ;nach Bit 9-11
                andi.b  #$F1,(A6)
                or.b    D3,(A6)
_q12:           jmp     (A1)

;MOVEQ
_q2:            move.l  D3,D0
                ext.w   D0
                ext.l   D0              ;Vorzeichen auf Long bringen
                cmp.l   D3,D0           ;Werte noch gleich?
                bne.s   _q23            ;NEIN! => evtl. nur zu lang?
                move.b  D3,1(A6)        ;Die Zahl einsetzen
                jmp     (A1)
_q23:           move.l  D3,D0
                clr.b   D0
                tst.l   D0              ;Dies soll MOVEQ #$F3,D0 erlauben
                bne.s   _qerr1          ;Obere Bytes Null?
                moveq   #20,D0          ;'Wert wird negativ'
                bsr     _mark_warn
                move.b  D3,1(A6)        ;Byte einsetzen
                jmp     (A1)
_qerr1:         moveq   #5,D0           ;Label zu groß (klein)
                bsr     _mark_error
                jmp     (A1)

;TRAP / LINEA
_q3:            moveq   #$F0,D1         ;$FFFFFFF0
                move.l  D3,D0
                and.l   D1,D0
                bne.s   _qerr1
                or.b    D3,1(A6)        ;Trapnummer einsetzen
                bra     a_pas42

;BKPT
_q5:            moveq   #$F8,D1
                move.l  D3,D0
                and.l   D1,D0
                bne.s   _qerr1
                or.w    D3,(A6)         ;Nummer einsetzen
                bra     a_pas42

;B??.S
_q4:            tst.w   4(A5)           ;ein Label in der Zeile definiert?
                bpl.s   _q62            ;Ja! =>
                move.w  -12(A5),D0      ;Länge der vorherigen Zeile
                beq.s   _q62            ;Leerzeile
                neg.w   D0              ;abziehen
                cmpi.b  #$60,0(A6,D0.w) ;BRA in der letzten Zeile?
                bne.s   _q62
                moveq   #49,D0          ;Unnötiger Sprung
                bsr     _mark_warn
_q62:           sub.l   A6,D3           ;Label-PC
                subq.l  #2,D3           ;-2 (Länge des Branch-Short)
                beq.s   _q6             ;Offset gleich 0
                move.w  D3,D0
                ext.w   D0
                ext.l   D0              ;Vorzeichen des Bytes zu Long
                cmp.l   D0,D3
                bne.s   _qerr21         ;out of range
                move.b  D3,1(A6)        ;Sprungweite ins untere Byte
                bra     a_pas42
_q6:            cmpi.b  #$61,(A6)       ;BSR ?
                beq.s   _q61            ;dann Fehler erzeugen
                move.w  #$4E71,(A6)     ;B??.S durch NOP ersetzen
                moveq   #31,D0
                bsr     _mark_warn
                bra     a_pas42
_q61:           moveq   #23,D0          ;Offset zu klein
                bsr     _mark_error
                bra     a_pas42
_qerr21:        moveq   #18,D0          ;(53)Sprung zu weit
                bsr     _mark_error
                st      optimize_flag(A4)
                bra     a_pas42
_qerr3:         moveq   #19,D0          ;Label not defined
                bsr     _mark_error
                jmp     (A1)

************************************************************************
* $xx(An,Rn.x)                                                         *
************************************************************************
;$xx(An,Rn.x) / $xx(PC,Rn.x)
special:        move.w  D0,D1
                andi.w  #7,D1           ;Einsetzoffset
                lea     0(A6,D1.w),A0   ;Zeiger auf Einsetzposition
                move.w  D0,D1           ;für Vorzeichen
                tst.b   D0
                bmi     spezpc
                btst    #4,D0
                bne     splist          ;Registerliste
                move.b  (A0),D0         ;Unteres Nibble des Labelindex einsetzen
                andi.l  #$3FFF,D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel ?
                beq.s   specia3         ;nein
                bsr     a_calc_formel
specia3:        tst.b   4(A3,D0.l)      ;defined-flag testen
                bpl.s   _qerr3          ;undefiniert
                move.l  0(A3,D0.l),D2   ;Wert der Variablen holen
                btst    #6,D1           ;Vorzeichen
                beq.s   specia5
                neg.l   D2
specia5:        tst.b   5(A3,D0.l)      ;Typflag
                bmi.s   specia4         ;Konstante
                bne     nrmlab5         ;Reglist verboten
                move.w  (A6),D0         ;Opcode holen
                cmp.w   #$1000,D0       ;MOVE
                blo.s   specia9
                cmp.w   #$3FFF,D0       ;MOVE
                bhi.s   specia9
                andi.w  #$0F,D1         ;EOffset
                cmp.w   #3,D1           ;erster Operand
                beq.s   specia9
                lsr.w   #3,D0           ;Ziel-EA umkopieren
                move.w  D0,D1
                lsr.w   #6,D1
                andi.w  #$38,D0
                andi.w  #7,D1
                or.w    D1,D0
specia9:        andi.w  #7,D0           ;Adressregisternummer ausmaskieren
                lsl.w   #2,D0
                sub.l   base_adreßreg(A4,D0.w),D2 ;Offset bilden
specia4:        move.l  D2,D0
                ext.w   D0
                ext.l   D0
                cmp.l   D0,D2           ;Bytegröße?
                bne.s   specia1         ;Leider zu groß!?!
specia2:        move.b  D2,(A0)         ;Offset einsetzen
                jmp     (A1)
specia1:        move.l  D2,D0
                clr.b   D0
                tst.l   D0
                bne.s   _qerr2          ;paßt immer noch nicht!
                moveq   #20,D0
                bsr     _mark_warn      ;'Offset wird negativ'
                bra.s   specia2

;PC-relativ
spezpc:         move.b  (A0),D0         ;Unteres Nibble des Labelindex einsetzen
                andi.l  #$3FFF,D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel ?
                beq.s   spezpc4         ;nein
                bsr     a_calc_formel
spezpc4:        tst.b   4(A3,D0.l)      ;defined-flag testen
                bpl     _qerr3
                move.l  0(A3,D0.l),D2   ;Wert des Labels holen
                btst    #6,D1           ;Vorzeichen
                beq.s   spezpc5
                neg.l   D2
spezpc5:        tst.b   5(A3,D0.l)
                bmi.s   spezpc1         ;nur eine Variable
                sub.l   A0,D2
                addq.l  #1,D2           ;PC-relativ machen
spezpc1:        move.l  D2,D0
                ext.w   D0
                ext.l   D0
                cmp.l   D0,D2           ;Bytegröße?
                bne.s   spezpc2         ;Leider zu groß!
spezpc3:        move.b  D2,(A0)         ;Offset einsetzen
                jmp     (A1)
spezpc2:        tst.b   5(A3,D0.l)
                beq.s   _qerr2          ;Bei einem Label ist alles zu spät
                move.l  D2,D0
                clr.b   D0
                tst.l   D0
                beq.s   _qerr2          ;paßt nicht mehr
                moveq   #20,D0          ;Warning:Offset wird negativ
                bsr.s   _mark_warn
                bra.s   spezpc3
_qerr2:         moveq   #18,D0          ;Offset zu groß
                bsr.s   _mark_error
                bra     a_pas42

splist:         move.w  2(A6),D0        ;Index
                lsl.l   #5,D0
                move.w  2(A3,D0.l),D0   ;Regbits
                move.w  (A6),D1
                andi.w  #$38,D1
                cmp.w   #$20,D1         ;-(sp)
                bne.s   splist2
                moveq   #15,D1
                move.w  D0,D2
splist3:        addx.w  D2,D2
                roxr.w  #1,D0           ;D0 spiegeln
                dbra    D1,splist3
splist2:        move.w  D0,2(A6)
                jmp     (A1)

************************************************************************
* Fehler in D0 in ak. Zeile eintragen                                  *
************************************************************************
_mark_error:    tst.b   6(A5)
                bne.s   _mark_1
                move.b  D0,6(A5)
                addq.w  #1,err_count(A4)
_mark_1:        rts
_mark_warn:     tst.b   opt_w_flag(A4)
                bmi.s   _mark_1
                tst.b   6(A5)
                bne.s   _mark_1
                move.b  D0,6(A5)
                addq.w  #1,warn_count(A4)
                rts
_mark_opt:      tst.b   opt_o_flag(A4)
                bmi.s   _mark_1         ;keine Optimierungen zugelassen
                tst.b   6(A5)
                bne.s   _mark_1
                move.l  A0,-(SP)
                lea     err_tab,A0      ;Zeiger auf Flagtabelle
                tst.b   0(A0,D0.w)      ;Optimierung freigegeben?
                bpl.s   _mark_opt1
                move.b  D0,6(A5)        ;Nummer eintragen
                addq.w  #1,warn_count(A4)
                st      optimize_flag(A4) ;ANPASSEN-Flag setzen
_mark_opt1:     movea.l (SP)+,A0
                rts

************************************************************************
* Sonderbefehle                                                        *
************************************************************************
spez_cmds:      move.w  D0,D1
                lsr.w   #8,D0
                move.w  a_tab2(PC,D0.w),D0
                jmp     a_tab2(PC,D0.w)

                BASE DC.W,a_tab2
a_tab2:         DC.W 0          ;Dummy
                DC.W a_dc2      ;DC
                DC.W a_ds3      ;DS
                DC.W a_dc53     ;TEXT
                DC.W a_even2    ;DATA
                DC.W a_return2  ;BSS
                DC.W a_even2    ;EVEN
                DC.W a_dc53     ;EQU
                DC.W a_opt2     ;OPT
                DC.W a_return2  ;END
                DC.W a_rsres2   ;RSRESET
                DC.W a_pas42    ;RSBSS
                DC.W a_rs2      ;RS
                DC.W a_rsset2   ;RSSET
                DC.W a_dc53     ;REG
                DC.W a_ibytes2  ;IBYTES
                DC.W a_base     ;BASE
                DC.W a_dc53     ;PATH
                DC.W a_cnop2    ;CNOP
                DC.W a_dc531    ;OUTPUT
                DC.W a_if2      ;IF
                DC.W a_else2    ;ELSE
                DC.W a_endc2    ;ENDC
                DC.W a_rseven2  ;RSEVEN
                DC.W a_dx2      ;DX.B
                DC.W a_dxset2   ;DXSET
                DC.W a_ds3      ;DCB
                DC.W a_pas42    ;FAIL
                DC.W a_dc531    ;ORG
                DC.W a_set2     ;SET
                DC.W a_rept2    ;REPT
                DC.W a_endr2    ;ENDR
                DC.W a_switch2  ;SWITCH
                DC.W a_case2    ;CASE
                DC.W a_ends2    ;ENDS
                DC.W a_dc53     ;GLOBAL
                DC.W a_dc53     ;COMMON
                DC.W a_dc53     ;DEFAULT
                DC.W 0          ;MACRO
                DC.W 0          ;ENDM
                DC.W 0          ;Macroaufruf
                DC.W a_dc53     ;PART
                DC.W a_dc53     ;ENDPART
                DC.W a_dc53     ;ISYMBOL
                DC.W a_dc53     ;==
                DC.W a_breakp2  ;BREAKPT

a_ibytes2:      moveq   #0,D1
                move.w  2(A5),D1
                lsl.l   #5,D1
                adda.l  8(A3,D1.l),A6
                bra     a_dc53
a_cnop2:        move.l  A6,D2
                moveq   #0,D0
                move.b  1(A5),D0        ;Alignment
                move.l  D0,D1
                bsr     ldiv            ;D2=D2/D1
                move.l  D0,D1
                bsr     lmult           ;D2=D2*D1
                add.l   D0,D2
                movea.l D2,A6
                adda.w  2(A5),A6        ;Offset
                bra     a_dc53
a_switch2:      tst.b   switch_flag(A4)
                bne     a_dc53
                moveq   #0,D0
                move.w  2(A5),D0
                lsl.l   #5,D0
                move.w  2(A3,D0.l),switch_wert(A4)
                st      switch_flag(A4)
                bra     a_dc53

a_case2:        tst.b   switch_flag(A4)
                beq     a_dc53
a_case22:       tst.b   switch_aktiv(A4) ;SWITCH bereits in CASE?
                bne.s   a_case21        ;Ja! => Nichts vergleichen
                tst.b   1(A5)
                bmi.s   a_case23        ;default-CASE
                move.w  2(A5),D0        ;CASE-Wert holen
                cmp.w   switch_wert(A4),D0
                beq.s   a_case23
a_case21:       addq.w  #1,D6
                addq.l  #8,A5
                tst.w   (A5)+
                bmi.s   a_if25          ;Ende des Sourcetexts
                move.b  (A5),D0
                cmpi.b  #$44,D0         ;ENDS
                beq.s   a_ends2
                cmp.b   #$42,D0         ;CASE
                bne.s   a_case21
                bra.s   a_case22
a_case23:       st      switch_aktiv(A4) ;SWITCH ist in der CASE-Struktur
                bra     a_dc53
a_ends2:        sf      switch_flag(A4)
                sf      switch_aktiv(A4)
                bra     a_dc53
a_if2:          tst.b   if_flag(A4)
                bne     a_dc53          ;geschachtelte IFs nicht erlaubt
                bsr     a_if1           ;Bedingung auswerten
                tst.b   D1              ;Bedingung erfüllt
                beq.s   a_if23          ;nein
                st      if_flag(A4)     ;ja, Flag setzen
                bra     a_dc53
a_if23:         addq.w  #1,D6
                addq.l  #8,A5           ;eine Zeile weiter
                tst.w   (A5)+
                bmi.s   a_if25          ;Ende des Sourcetext
                move.w  (A5),D0
                cmp.w   #$2A00,D0       ;ELSE-Befehl
                beq.s   a_if26
                cmp.w   #$2C00,D0       ;ENDC-Befehl
                bne.s   a_if23
                moveq   #0,D0
                bra     a_dc53
a_if25:         bra     a_return2
a_if26:         move.b  #1,if_flag(A4)
                moveq   #0,D0
                bra     a_dc53
a_else2:        tst.b   if_flag(A4)
                bpl     a_dc53
a_else21:       addq.w  #1,D6
                addq.l  #8,A5           ;nächste Zeile
                tst.w   (A5)+
                bmi.s   a_if25          ;letzte Zeile
                cmpi.b  #$2C,(A5)       ;ENDC
                bne.s   a_else21
                sf      if_flag(A4)
                bra     a_dc53
a_endc2:        sf      if_flag(A4)
                bra     a_dc53
a_rseven2:      move.l  rs_count(A4),D0
                addq.l  #1,D0
                andi.w  #$FFFE,D0
                move.l  D0,rs_count(A4)
                bra     a_dc53

a_breakp2:      tst.b   1(A5)
                beq.s   a_breakp21      ;es wurde nicht begradigt
                addq.l  #1,A6
a_breakp21:     addq.l  #2,A6           ;ILLEGAL
                adda.w  D7,A6           ;Textlänge
                bra     a_dc531

a_dxset2:       moveq   #0,D0
                move.b  2(A5),D0        ;Anzahl holen
                move.w  D0,dx_anzahl(A4)
                move.b  3(A5),D0        ;Füllbyte holen
                move.b  D0,dx_wert(A4)
                bra     a_dc53
a_dx2:          adda.w  dx_anzahl(A4),A6 ;Bytes überspringen
                bra     a_dc53

a_rsres2:       clr.l   rs_count(A4)
                bra     a_dc53
a_rsset2:       move.l  (A5),D0
                andi.l  #$0FFFFF,D0
                btst    #6,1(A5)        ;Symbol
                bne.s   a_rsset21       ;ja
                btst    #19,D0          ;Vorzeichenbit testen
                beq.s   a_rsset22       ;positiv
                or.l    #$FFF00000,D0   ;negativ machen
a_rsset22:      move.l  D0,rs_count(A4)
                bra     a_dc53
a_rsset21:      lsl.l   #5,D0
                move.l  0(A3,D0.l),rs_count(A4)
                bra     a_dc53

a_opt2:         move.w  2(A5),D0
                btst    #12,D0          ;W
                beq.s   a_opt21
                btst    #13,D0
                sne     opt_w_flag(A4)
a_opt21:        btst    #10,D0          ;O
                beq.s   a_opt22
                btst    #11,D0
                sne     opt_o_flag(A4)
a_opt22:        bra     a_dc53

a_rept2:        tst.w   rept_pointer(A4)
                bpl     a_dc53
                moveq   #0,D0
                move.w  2(A5),D0        ;Anzahl/Index
                move.w  (A5),D2
                lsr.w   #4,D2           ;Flags für Breite
                bcc.s   a_rept22        ;kein Symbol
                lsl.l   #5,D0
                tst.b   4(A3,D0.l)      ;defined_flag testen
                bpl.s   a_rept24        ;undefiniert
                tst.b   5(A3,D0.l)      ;Typflag
                beq.s   a_rept24        ;Symbol
                bpl.s   a_rept24        ;Reglist
                move.l  0(A3,D0.l),D0   ;Wert holen
a_rept22:       move.l  D0,rept_count(A4)
                move.w  D6,rept_line(A4)
                move.l  A5,rept_pointer+4(A4)
                moveq   #0,D0
                move.w  D0,rept_pointer(A4)
                bra     a_dc53
a_rept24:       moveq   #1,D0
                bra.s   a_rept22
a_endr2:        tst.w   rept_pointer(A4)
                bmi     a_dc53
                subq.l  #1,rept_count(A4)
                bcs.s   a_endr22
                beq.s   a_endr22        ;Zähler auf Null
                movea.l rept_pointer+4(A4),A5
                move.w  rept_line(A4),D6
                bra     a_dc53
a_endr22:       move.w  #$FFFF,rept_pointer(A4)
                bra     a_dc53
a_rs2:          moveq   #0,D0
                move.w  2(A5),D0        ;Anzahl/Index
                move.w  (A5),D1
                lsr.w   #4,D1           ;Flags für Breite
                bcc.s   a_rs23          ;kein Symbol
                moveq   #0,D1
                lsl.l   #5,D0
                tst.b   4(A3,D0.l)      ;defined_flag testen
                bpl.s   a_rs23          ;undefiniert
                tst.b   5(A3,D0.l)      ;Typflag
                beq.s   a_rs23          ;Symbol
                bpl.s   a_rs23          ;Reglist
                move.l  0(A3,D0.l),D1   ;Wert holen
a_rs23:         andi.w  #3,D1
                beq.s   a_rs22          ;RS.B
                lsl.l   D1,D0           ;mal Breite
                move.l  rs_count(A4),D1
                addq.l  #1,D1
                andi.w  #$FFFE,D1       ;Counter begradigen
                add.l   D0,D1
                add.l   D1,rs_count(A4) ;zum Zähler dazu
                moveq   #0,D1
                bra     a_dc53
a_rs22:         add.l   D0,rs_count(A4)
                bra     a_dc53

a_base:         moveq   #0,D1
                move.b  1(A5),D1        ;Nummer des Adressregisters
                lsl.w   #2,D1
                moveq   #0,D0
                move.w  2(A5),D0        ;Index holen
                bmi.s   a_base2         ;Sonderindex (OFF,etc.)
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel ?
                beq.s   a_base3         ;nein
                bsr     a_calc_formel
a_base3:        tst.b   4(A3,D0.l)      ;definiert ?
                bpl.s   a_base5         ;nein
                move.l  0(A3,D0.l),base_adreßreg(A4,D1.w)
                bra     a_dc53
a_base2:        clr.l   base_adreßreg(A4,D1.w)
                and.w   #$3FFF,D0
                beq     a_pas42         ;PC
                subq.w  #6,D0
                bmi.s   a_base4         ;OFF
                add.w   D0,D0
                move.l  segm_adr(A4,D0.w),base_adreßreg(A4,D1.w)
                bra     a_dc53
a_base4:        moveq   #-1,D0
                move.l  D0,base_adreßreg(A4,D1.w) ;Wert zurücksetzen
                moveq   #0,D0
                bra     a_dc53
a_base5:        moveq   #19,D0          ;Label not defined
                bsr     _mark_error
                bra     a_dc53

a_even2:        tst.b   D1              ;Füllbyte nötig ?
                beq     a_pas42         ;nein !
                addq.l  #1,A6           ;sonst INC a6
                bra     a_pas42

a_set2:         moveq   #0,D0
                move.w  2(A5),D0
                lsl.l   #5,D0
                bsr     a_calc_formel
                moveq   #0,D1
                move.w  4(A5),D1        ;Index des Zielsymbols
                lsl.l   #5,D1
                cmpi.b  #$FE,5(A3,D1.l)
                beq.s   a_set21
                move.l  0(A3,D0.l),0(A3,D1.l) ;Wert übertragen
                move.w  4(A3,D0.l),4(A3,D1.l) ;Flags übertragen
a_set21:        moveq   #0,D0
                bra     a_dc53
a_dc2:          andi.w  #3,D1
                moveq   #0,D0
                move.w  2(A5),D0
                andi.w  #$3FFF,D0
                lsl.l   #5,D0
                lea     0(A3,D0.l),A0   ;Zeiger DC-Eintrag
                tst.w   D1
                beq     a_dc5           ;DC.B
                addq.w  #1,A6
                move.l  A6,D0
                andi.w  #$FFFE,D0       ;Adresse begradigen
                movea.l D0,A6
                cmp.w   #1,D1
                beq     a_dc3           ;DC.W
a_dc4:          move.w  (A0)+,D1        ;DC.L
                moveq   #0,D0
                move.w  D1,D0
                bpl     a_dc41
                andi.w  #$3FFF,D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel ?
                beq.s   a_dc44
                bsr     a_calc_formel
a_dc44:         tst.b   4(A3,D0.l)
                bmi.s   a_dc40
                moveq   #19,D0          ;Label not defined
                bsr     _mark_error
                bra.s   a_dc43
a_dc40:         move.l  0(A3,D0.l),(A6)
                btst    #14,D1          ;Vorzeichen
                beq.s   a_dc45
                neg.l   (A6)
a_dc45:         tst.b   5(A3,D0.l)      ;Typflag testen
                bmi.s   a_dc43          ;Konstante, nicht relozieren
                sub.l   D4,(A6)
                move.l  A6,D2           ;Adresse kopieren
                sub.l   D5,D2           ;Distanz berechnen
                tas.b   reloc_fl(A4)
                bmi.s   a_dcrel1        ;Byte-Offset
                move.l  D2,(A2)+        ;1. Relozierinfo
                move.l  A6,D5           ;neue Bezugsadresse
                subq.l  #4,end_adr(A4)
                bgt.s   a_dc43
                bra     out_of_mem      ;Speicher voll
a_dcrel1:       move.l  #254,D3
a_dcrel3:       cmp.l   D3,D2
                bls.s   a_dcrel2        ;Offset <= 254
                move.b  #1,(A2)+        ;'1' schreiben
                sub.l   D3,D2           ;minus 254
                subq.l  #1,end_adr(A4)
                bgt.s   a_dcrel3
a_dcrel4:       bra     out_of_mem      ;Speicher voll
a_dcrel2:       move.b  D2,(A2)+
                subq.l  #1,end_adr(A4)
                ble.s   a_dcrel4
                move.l  A6,D5           ;neue Bezugsadresse
a_dc43:         moveq   #0,D0
                addq.w  #4,A6
                move.w  (A0),D0
                andi.w  #$C0FF,D0
                cmp.w   #$FF,D0         ;Fortsetzungskennung ?
                beq.s   a_dc46          ;ja
                cmp.w   #$FE,D0         ;Ende erreicht ?
                bne     a_dc4           ;nein
                moveq   #0,D7
                bra     a_pas42
a_dc41:         lsr.w   #2,D0
                andi.w  #$01FC,D0
                addq.w  #4,D0
                adda.w  D0,A6
                move.w  (A0),D0
                andi.w  #$C0FF,D0
                cmp.w   #$FF,D0
                beq.s   a_dc46          ;ja
                cmp.w   #$FE,D0         ;Ende erreicht
                bne     a_dc4
                moveq   #0,D7
                bra     a_pas42
a_dc46:         move.w  (A0),D0         ;High-Byte des Index holen
                move.b  2(A0),D0        ;Low-Byte des Index holen
                lsl.l   #5,D0
                lea     0(A3,D0.l),A0   ;Zeiger auf neuen Eintrag
                bra     a_dc4
a_dc3:          move.w  (A0)+,D1
                moveq   #0,D0
                move.w  D1,D0
                bpl.s   a_dc31
                andi.w  #$3FFF,D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel ?
                beq.s   a_dc34
                bsr     a_calc_formel
a_dc34:         tst.b   4(A3,D0.l)      ;defined-flag testen
                bmi.s   a_dc30
                moveq   #19,D0          ;Symbol not defined
                bsr     _mark_error
                bra.s   a_dc35
a_dc30:         move.l  0(A3,D0.l),D2   ;Wert holen
                btst    #14,D1          ;Vorzeichen
                beq.s   a_dc36
                neg.l   D2
a_dc36:         tst.b   5(A3,D0.l)
                bmi.s   a_dc33          ;Symbol ist Konstante
                tst.w   dcwbase(A4)
                bmi.s   a_dc33          ;BASE nicht aktiv
                sub.l   dcwbase(A4),D2  ;Label -> Offset zum angegebenen Label
                tst.l   dcwbase(A4)
                bne.s   a_dc33          ;normales Label
                sub.l   A6,D2           ;PC relativ
a_dc33:         move.l  D2,D0
                ext.l   D0
                cmp.l   D0,D2           ;Offset auf Longbreite ?
                beq.s   a_dc35          ;nein
                move.l  D2,D0
                clr.w   D0
                tst.l   D0              ;paßt das Word doch ?
                bne.s   a_dc351         ;nein
                moveq   #20,D0
                bsr     _mark_warn      ;Offset wird negativ
                bra.s   a_dc35
a_dc351:        moveq   #18,D0
                bsr     _mark_error     ;Offset zu groß
a_dc35:         move.w  D2,(A6)+
                moveq   #0,D0
                move.w  (A0),D0
                andi.w  #$C0FF,D0
                cmp.w   #$FF,D0         ;Fortsetzungskennung ?
                beq.s   a_dc37
                cmp.w   #$FE,D0         ;Ende erreicht ?
                bne.s   a_dc3           ;nein
                moveq   #0,D7
                bra     a_pas42
a_dc31:         lsr.w   #3,D0
                andi.w  #$FE,D0
                addq.w  #2,D0
                adda.w  D0,A6
                move.w  (A0),D0
                andi.w  #$C0FF,D0
                cmp.w   #$FF,D0         ;Fortsetzungskennung ?
                beq.s   a_dc37
                cmp.w   #$FE,D0         ;Ende erreicht
                bne     a_dc3
                moveq   #0,D7
                bra     a_pas42
a_dc37:         move.w  (A0),D0         ;High-Byte des Index holen
                move.b  2(A0),D0        ;Low-Byte des Index holen
                lsl.l   #5,D0
                lea     0(A3,D0.l),A0   ;Zeiger auf neuen Eintrag
                bra     a_dc3

a_dc5:          move.w  (A0)+,D1
                moveq   #0,D0
                move.w  D1,D0
                bpl.s   a_dc51
                andi.w  #$3FFF,D0
                lsl.l   #5,D0
                tst.b   31(A3,D0.l)     ;Formel
                beq.s   a_dc54
                bsr     a_calc_formel
a_dc54:         tst.b   4(A3,D0.l)      ;defined-flag testen
                bmi.s   a_dc50
                moveq   #19,D0          ;Label not defined
                bsr     _mark_error
                bra.s   a_dc56
a_dc50:         move.l  0(A3,D0.l),D2
                btst    #14,D1          ;Vorzeichen
                beq.s   a_dc57
                neg.l   D2
a_dc57:         tst.b   5(A3,D0.l)
                bmi.s   a_dc55          ;Symbol ist Konstante
                tst.w   dcbbase(A4)
                bmi.s   a_dc55          ;BASE nicht aktiv
                sub.l   dcbbase(A4),D2  ;Label -> Offset zum angegebenen Label
                tst.l   dcbbase(A4)
                bne.s   a_dc55          ;normales Label
                sub.l   A6,D2           ;PC relativ
a_dc55:         move.l  D2,D0
                ext.w   D0
                ext.l   D0
                cmp.l   D0,D2           ;Offset zu groß
                beq.s   a_dc56          ;nein
                move.l  D2,D0
                clr.b   D0
                tst.l   D0              ;paßt Offset doch ?
                bne.s   a_dc561         ;nein
                moveq   #20,D0
                bsr     _mark_warn      ;Offset wird negativ
                bra.s   a_dc56
a_dc561:        moveq   #18,D0
                bsr     _mark_error     ;Offset zu groß
a_dc56:         move.b  D2,(A6)
                addq.w  #1,A6
                move.w  (A0),D0
                andi.w  #$C0FF,D0
                cmp.w   #$FF,D0         ;Fortsetzungskennung ?
                beq.s   a_dc58          ;ja
                cmp.w   #$FE,D0         ;Ende erreicht ?
                bne.s   a_dc5           ;nein
                moveq   #0,D7
                bra.s   a_dc53
a_dc51:         lsr.w   #4,D0
                andi.w  #$7F,D0
                addq.w  #1,D0
                adda.w  D0,A6
                move.w  (A0),D0
                andi.w  #$C0FF,D0
                cmp.w   #$FF,D0         ;Fortsetzungskennung ?
                beq.s   a_dc58          ;ja
                cmp.w   #$FE,D0         ;Ende erreicht ?
                bne     a_dc5           ;nein
a_dc531:        moveq   #0,D7
a_dc53:         tst.l   8(A5)           ;Länge und Operand testen
                bmi.s   a_dc59
                bne.s   a_dc52          ;keine Leerzeile
                lea     10(A5),A5       ;eine Zeile weiter
                addq.w  #1,D6
                bra.s   a_dc53
a_dc52:         cmpi.b  #2,10(A5)       ;nächste Zeile testen
                bge     a_pas42         ;Spezialbefehl
                addq.w  #1,A6           ;in der nächsten Zeile ein
                move.l  A6,D1           ;normaler Opcode -> Adresse
                bclr    #0,D1           ;muß gerade sein
                movea.l D1,A6
                bra     a_pas42         ;bne
a_dc59:         bra     a_pas42
a_dc58:         move.w  (A0),D0         ;High-Byte des Index holen
                move.b  2(A0),D0        ;Low-Byte des Index holen
                lsl.l   #5,D0
                lea     0(A3,D0.l),A0   ;Zeiger auf neuen Eintrag
                bra     a_dc5

a_ds32:         moveq   #0,D0
                bra.s   a_ds31
a_ds3:          moveq   #0,D0
                move.w  2(A5),D0        ;Anzahl
                and.w   #$30,D1         ;Flags für Konstante/Formel
                cmp.w   #$30,D1
                bne.s   a_ds31          ;nein
                lsl.l   #5,D0
                tst.b   5(A3,D0.l)      ;Konstante?
                bpl.s   a_ds32          ;Nein! =>
                tst.b   4(A3,D0.l)      ;defined-flag
                bpl.s   a_ds32          ;Fehler
                move.l  0(A3,D0.l),D0   ;Wert holen
                bmi.s   a_ds32          ;ist negativ
a_ds31:         move.b  1(A5),D1
                rol.b   #2,D1
                andi.w  #3,D1
                beq.s   a_ds21          ;DS.B
                lsl.l   D1,D0
                addq.l  #1,A6
                move.l  A6,D1
                and.w   #$FFFE,D1
                movea.l D1,A6
                adda.l  D0,A6
                moveq   #0,D7
                bra     a_pas42
a_ds21:         adda.l  D0,A6
                moveq   #0,D7
a_ds23:         tst.l   8(A5)           ;Länge und Operand testen
                bmi.s   a_ds24
                bne.s   a_ds22          ;keine Leerzeile
                lea     10(A5),A5       ;eine Zeile weiter
                addq.w  #1,D6
                bra.s   a_ds23
a_ds22:         cmpi.b  #2,10(A5)       ;nächste Zeile testen
                bge     a_pas42         ;Spezialbefehl
                addq.w  #1,A6           ;in der nächsten Zeile ein
                move.l  A6,D1           ;normaler Opcode -> Adresse
                bclr    #0,D1           ;muß gerade sein
                movea.l D1,A6
                bne     a_pas42         ;war gerade
                moveq   #25,D0          ;Adresse wurde begradigt
                bsr     _mark_warn
a_ds24:         bra     a_pas42
                ENDPART
                >PART 'a_calc_formel'
************************************************************************
* berechnet einen Formelausdruck ab A0 ,Ergebnis in D1                 *
************************************************************************
a_calc_formel:  movem.l D1-D5/D7-A0/A2,-(SP)
                lea     6(A3,D0.l),A0   ;Start der Formel
                ori.b   #$80,4(A3,D0.l) ;defined-flag setzen
                move.l  D0,D4           ;Index retten
                movea.l SP,A2           ;Stack für Rücksprung retten
                moveq   #0,D3           ;Flag für Konstante/Label
                moveq   #0,D0
                moveq   #0,D7
                move.b  (A0),D0
                and.b   #$0C,D0
                bne.s   a_internal      ;Fehler in Formeltoken
                move.b  (A0)+,D0        ;Operation
                and.b   #$F0,D0         ;Operationbits löschen
                bsr.s   a_vergleich
                move.l  D4,D0           ;Index zurückholen
                btst    #0,6(A3,D0.l)   ;Minus vor Klammer ?
                beq.s   a_calc_f3       ;nein
                btst    #1,6(A3,D0.l)
                beq.s   a_calc_f31      ;minus
                not.l   D1              ;not
                bra.s   a_calc_f3
a_calc_f31:     neg.l   D1              ;sonst Ergebnis negieren
a_calc_f3:      move.l  D1,0(A3,D0.l)   ;Ergebnis eintragen
                cmp.w   #1,D5
                bhi.s   a_calc_for1
                tst.w   D5
                bmi.s   a_calc_for1
                seq     5(A3,D0.l)      ;Typflag setzen
                movem.l (SP)+,D1-D5/D7-A0/A2
                rts
a_calc_for1:    tst.b   6(A5)
                bne.s   a_calc_for11
                move.b  #29,6(A5)       ;unerlaubte Rechenoperation
                addq.w  #1,err_count(A4)
                andi.b  #$7F,4(A3,D4.l) ;defined-flag löschen
a_calc_for11:   move.l  D4,D0
                movem.l (SP)+,D1-D5/D7-A0/A2
                rts
a_internal:     move.b  #17,6(A5)       ;Internal error
                bra.s   a_calc_for2
a_overflow:     move.b  #5,6(A5)        ;Overflow error
a_calc_for2:    addq.w  #1,err_count(A4)
                andi.b  #$7F,4(A3,D4.l) ;defined-flag löschen
                movea.l A2,SP           ;Stackpointer rekonstruieren
                bra.s   a_calc_for11
a_illequan:     move.b  #24,6(A5)
                bra.s   a_calc_for2
a_vergleich:    movem.l D2-D3,-(SP)
                bsr.s   a_ausdruck
                move.w  D5,D3
                move.l  D1,D2
a_vergleichl:   cmpi.b  #$FF,(A0)       ;Ende der Formel?
                beq.s   a_vergleichend  ;Ja! => raus
                cmp.b   #10,D0
                blo.s   a_vergleichend  ;kein Vergleich?
                cmp.b   #15,D0          ;Ja! => raus
                bhi.s   a_vergleichend
                move.w  D0,D0
                sub.w   #10,D0
                add.w   D0,D0           ;mal 4 (Größe pro Operation)
                add.w   D0,D0
                pea     a_vergleich1(PC,D0.w) ;Sprungoffset auf den Stack
                bsr.s   a_ausdruck
                moveq   #0,D3           ;Ergebnis des Vergleichs->Konstante
                cmp.l   D1,D2
                rts                     ;Vergleich anspringen
a_vergleich1:   seq     D2              ;0
                bra.s   a_vergleich2
                slo     D2              ;1
                bra.s   a_vergleich2
                shi     D2              ;2
                bra.s   a_vergleich2
                sls     D2              ;3
                bra.s   a_vergleich2
                shs     D2              ;4
                bra.s   a_vergleich2
                sne     D2              ;5
a_vergleich2:   ext.w   D2
                ext.l   D2
                bra.s   a_vergleichl
a_vergleichend: move.l  D2,D1
                move.w  D3,D5
                movem.l (SP)+,D2-D3
                rts

a_ausdruck:     movem.l D2-D3,-(SP)
                bsr.s   a_einf_ausdr
                move.w  D5,D3           ;Typflag übertragen
                move.l  D1,D2
a_ausdruckl:    cmpi.b  #$FF,(A0)       ;Ende der Formel
                beq.s   a_ausdruckend
                tst.b   D0              ;Addition
                bne.s   a_ausdruck1
                bsr.s   a_einf_ausdr
                add.w   D5,D3
                add.l   D1,D2
                bvs     a_overflow
                bra.s   a_ausdruckl
a_ausdruck1:    cmp.b   #1,D0           ;Subtraktion
                bne.s   a_ausdruck2
                bsr.s   a_einf_ausdr
                sub.w   D5,D3
                sub.l   D1,D2
                bvs     a_overflow
                bra.s   a_ausdruckl
a_ausdruck2:    cmp.b   #2,D0           ;OR
                bne.s   a_ausdruck3
                bsr.s   a_einf_ausdr
                or.l    D1,D2
                bra.s   a_ausdruckl
a_ausdruck3:    cmp.b   #3,D0           ;EOR
                bne.s   a_ausdruck4
                bsr.s   a_einf_ausdr
                eor.l   D1,D2
                bra.s   a_ausdruckl
a_ausdruck4:    cmp.b   #4,D0           ;SHL
                bne.s   a_ausdruck5
                bsr.s   a_einf_ausdr
                tst.w   D5
                bne.s   a_einf_error
                lsl.l   D1,D2
                bra.s   a_ausdruckl
a_ausdruck5:    cmp.b   #5,D0           ;SHR
                bne.s   a_ausdruckend
                bsr.s   a_einf_ausdr
                tst.w   D5
                bne.s   a_einf_error
                lsr.l   D1,D2
                bra.s   a_ausdruckl
a_ausdruckend:  move.l  D2,D1
                move.w  D3,D5
                movem.l (SP)+,D2-D3
                rts
a_einf_error:   move.b  #29,6(A5)       ;'unerlaubte Rechenoperation'
                bra     a_calc_for2
a_einf_ausdr:   movem.l D2-D3,-(SP)
                bsr.s   a_faktor
                move.w  D5,D3
                move.l  D1,D2
a_eausdruckl:   cmp.b   #6,D0           ;Multiplikation
                bne.s   a_eausdruck1
                tst.w   D3
                bne.s   a_einf_error
                bsr.s   a_faktor
                tst.w   D5
                bne.s   a_einf_error    ;relozierbares Label
                bsr     lmult           ;D2=D1*D2
                bvs     a_overflow      ;Wert zu groß
                bra.s   a_eausdruckl
a_eausdruck1:   cmp.b   #7,D0           ;Division
                bne.s   a_eausdruck2
                tst.w   D3
                bne.s   a_einf_error
                bsr.s   a_faktor
                tst.w   D5
                bne.s   a_einf_error    ;relozierbares Label
                tst.l   D1
                beq     a_illequan      ;Division by zero
                bsr     ldiv            ;D2.L = D2.L/D1.L
                bra.s   a_eausdruckl
a_eausdruck2:   cmp.b   #8,D0           ;AND
                bne.s   a_eausdruck3
                bsr.s   a_faktor
                and.l   D1,D2
                bra.s   a_eausdruckl
a_eausdruck3:   cmp.b   #9,D0           ;MODULO
                bne.s   a_eausdruckend
                bsr.s   a_faktor
                bsr     ldiv            ;D1.L = D2 MOD D1
                move.l  D1,D2
                bra.s   a_eausdruckl
a_eausdruckend: move.l  D2,D1
                move.w  D3,D5
                movem.l (SP)+,D2-D3
                rts

a_faktor:       movem.l D2-D3,-(SP)
                cmp.b   #$0F,D0
                bhi.s   a_faktor1
                tst.b   D7
                bne.s   a_faktor3
                bsr.s   a_get_zahl
                move.b  (A0)+,D0
                move.b  D0,D7
                lsr.w   #4,D7
                and.b   #3,D7           ;Anzahl '('
                and.b   #$CF,D0
                movem.l (SP)+,D2-D3
                rts
a_faktor1:      sub.b   #$10,D0         ;'('
a_faktor31:     bsr     a_vergleich
                cmp.b   #$3F,D0         ;')'
                bls.s   a_faktor2
                sub.b   #$40,D0
a_faktor2:      movem.l (SP)+,D2-D3
                rts
a_faktor3:      subq.b  #1,D7
                bra.s   a_faktor31

a_get_zahl:     moveq   #0,D5
                moveq   #0,D1
                move.b  (A0)+,D2        ;Flags für Wert testen
                bmi.s   a_get_zahl2     ;Label
                btst    #6,D2
                bne.s   a_get_zahl3     ;Longwert
                move.w  (A0)+,D1
                bra.s   a_get_zahl51
a_get_zahl3:    move.l  (A0)+,D1
                bra.s   a_get_zahl51

a_get_zahl2:    moveq   #0,D1
                move.w  (A0)+,D1
                bmi.s   a_get_zahl8     ;interne Variablen
                lsl.l   #5,D1
                tst.b   4(A3,D1.l)      ;defined-flag
                bpl.s   a_get_zahl4     ;nicht definiert
                tst.b   5(A3,D1.l)      ;Typ
                bmi.s   a_get_zahl5     ;Konstante, D5=0
                bne.s   a_get_zahl6     ;kein Label
                move.b  D2,D5           ;Wertflag
                and.b   #8,D5           ;Vorzeichen
                sne     D5
                ext.w   D5              ;wenn minus, dann D5=$ffff
                bmi.s   a_get_zahl5
                moveq   #1,D5           ;wenn plus, dann D5=1
a_get_zahl5:    move.l  0(A3,D1.l),D1   ;Wert des Labels/Konstante holen
a_get_zahl54:   btst    #3,D2           ;Vorzeichen
                beq.s   a_get_zahl51
                neg.l   D1
a_get_zahl51:   btst    #4,D2           ;'~'
                beq.s   a_get_zahl52
                not.l   D1
a_get_zahl52:   btst    #5,D2           ;'!'
                beq.s   a_get_zahl53
                tst.l   D1
                seq     D1
                ext.w   D1
                ext.l   D1
a_get_zahl53:   rts
a_get_zahl6:    move.b  #14,6(A5)       ;unerlaubter Operant
                bra     a_calc_for2
a_get_zahl4:    move.b  #19,6(A5)       ;undefiniertes Symbol
                bra     a_calc_for2
a_get_zahl8:    and.w   #$3FFF,D1       ;negativ-bit löschen
                lsr.w   #2,D1           ;durch 4
                move.w  a_get_tab(PC,D1.w),D1 ;Offset holen
                jmp     a_get_tab(PC,D1.w)

                BASE DC.W,a_get_tab
a_get_tab:      DC.W a_get_z1,a_get_z2 ;*, DATE
                DC.W a_get_z3,a_get_z4 ;TIME, RSCOUNT
                DC.W a_get_z5,a_get_z6 ;RANDOM, SYMTAB
                DC.W a_get_z7   ;RELOC

a_get_z1:       move.l  A6,D1           ;'*', ak. PC
                moveq   #1,D5
                bra.s   a_get_zahl51
a_get_z4:       move.l  rs_count(A4),D1 ;^^RSCOUNT
                bra.s   a_get_zahl54
a_get_z2:       moveq   #0,D1           ;^^DATE
                move.w  a_date(A4),D1
                bra.s   a_get_zahl54
a_get_z3:       moveq   #0,D1           ;^^TIME
                move.w  a_time(A4),D1
                bra.s   a_get_zahl54
a_get_z6:       tst.b   opt_d_flag(A4)  ;OPT D+ oder X+ ?
                sgt     D1              ;^^SYMTAB = 0, wenn nicht
a_get_z61:      ext.w   D1
                ext.l   D1
                bra.s   a_get_zahl54
a_get_z7:       tst.b   reloc_fl(A4)    ;=0, wenn kein Relocinfo
                sne     D1
                bra.s   a_get_z61       ;^^RELOC
a_get_z5:       movem.l D0/D2/A0-A2,-(SP) ;^^RANDOM
                move.w  #$11,-(SP)
                trap    #14
                addq.l  #2,SP
                move.l  D0,-(SP)
                move.w  #$11,-(SP)
                trap    #14
                addq.l  #2,SP
                move.l  (SP)+,D1
                lsl.l   #8,D1
                or.b    D0,D1
                ror.l   #8,D1
                movem.l (SP)+,D0/D2/A0-A2
                bra     a_get_zahl54
                ENDPART
************************************************************************
* weitere Editorroutinen                                               *
************************************************************************
                >PART 's_part_hide'
s_part_hide:    movem.l D0/D6/A0,-(SP)
                movea.l A5,A0
s_part_hide1:   move.b  2(A0),D0
                sub.b   #$52,D0         ;PART-Befehl?
                beq.s   s_part_hide2    ;ja => zu klappenden Part gefunden
                subq.b  #$02,D0         ;ENDPART? (Opcode $54)
                beq.s   s_part_hide3    ;Ja! => raus
                lea     -10(A0),A0      ;eine Zeile hoch
                subq.w  #1,D6           ;am Anfang vom Sourcetext?
                bne.s   s_part_hide1    ;Nein! => weiter suchen
                bra.s   s_part_hide3
s_part_hide2:   cmpi.b  #$F0,3(A0)      ;geschützter PART?
                beq.s   s_part_hide3    ;Ja => raus
                tst.b   3(A0)
                seq     3(A0)           ;Hide-Flag tongeln
                movem.l (SP),D0/D6/A0
                bsr     search_part     ;Part-Tabelle aktualisieren
                move.w  D6,D0           ;ak. Zeile
                bsr     jump_line
s_part_hide3:   movem.l (SP)+,D0/D6/A0
                bra     s_jmp_main
                ENDPART
                >PART 's_apart_hide'
s_apart_hide:   cmpi.b  #$52,2(A5)      ;PART-Befehl?
                bne     s_jmp_main      ;nein
                cmpi.w  #$52F0,2(A5)    ;geschützter PART?
                beq     s_jmp_main      ;ja
                movem.l D0-D1/A0,-(SP)
                movea.l A5,A0           ;ab der ak. Position ein- bzw. ausklappen
                tst.b   3(A5)
                seq     3(A5)           ;Flag tongeln
                move.b  3(A5),D1        ;Flag für folgende PARTs merken
s_apart_h2:     tst.w   (A0)+           ;Ende des Texts?
                bmi.s   s_apart_h3      ;ja
                cmpi.b  #$52,(A0)       ;PART-Befehl?
                bne.s   s_apart_h1      ;nein
                cmpi.w  #$52F0,(A0)     ;geschützter PART?
                beq.s   s_apart_h1      ;ja
                move.b  D1,1(A0)        ;Flag übertragen
s_apart_h1:     addq.l  #8,A0           ;nächste Zeile
                bra.s   s_apart_h2
s_apart_h3:     movem.l (SP)+,D0-D1/A0
                bsr     search_part     ;Part-Tabelle aktualisieren
                move.w  D6,D0           ;ak. Zeile
                bsr     jump_line
                bra     s_jmp_main
                ENDPART
                >PART 's_block_anf'
s_block_anf:    cmp.w   anz_zeilen(A4),D6
                beq     s_jmp_main
                cmp.w   block_end(A4),D6 ;Anfang unter Ende ?
                blo.s   s_block_anf2    ;nein
                move.w  #$FFFF,block_end(A4) ;Blockende auf Textende
s_block_anf2:   move.w  D6,block_anf(A4)
                bsr     redraw_all
                bra     s_jmp_main
                ENDPART
                >PART 's_block_ende'
s_block_ende:   cmp.w   anz_zeilen(A4),D6
                beq     s_jmp_main
                move.w  D6,block_end(A4)
                cmp.w   block_anf(A4),D6 ;Ende vor Anfang?
                bhi.s   s_block_ende2   ;nein
                clr.w   block_anf(A4)   ;sonst Anfang gleich Textanfang
s_block_ende2:  bsr     redraw_all
                bra     s_jmp_main
                ENDPART
                >PART 's_block_hide'
s_block_hide:   moveq   #-1,D0
                move.l  D0,block_anf(A4)
                bsr     redraw_all
                bra     s_jmp_main
                ENDPART
                >PART 's_del_block'
s_del_block1:   addq.l  #2,SP
                bsr     s_new
                bra.s   s_block_hide
s_del_block:    moveq   #$FF,D0
                cmp.l   block_anf(A4),D0
                beq     s_jmp_main      ;kein Block
                move.w  block_anf(A4),D0
                cmp.w   block_end(A4),D0
                bhs     s_jmp_main
                cmp.w   anz_zeilen(A4),D0
                beq.s   s_block_hide
                move.w  D0,-(SP)
                bsr     calc_pointer
                movem.l A3/A5-A6,block_pointer(A4)
                move.w  block_end(A4),D2
                cmp.w   anz_zeilen(A4),D2
                bls.s   s_del_block3
                move.w  anz_zeilen(A4),D2
s_del_block3:   move.w  anz_zeilen(A4),D3
                sub.w   D2,D3           ;D3=Anzahl der zu kopierenden Zeilen
                sub.w   (SP),D2         ;D2=Anzahl der Zeilen im Block
                cmp.w   anz_zeilen(A4),D2
                beq.s   s_del_block1    ;gesamten Sourcetext löschen
                move.w  D2,(SP)
                subq.w  #1,D2
                bclr    #7,sym_flag(A4) ;dirty-Flag
                movea.l ass_adr(A4),A0  ;Buffer für Flagtabelle
                movea.l A0,A1
                move.w  #1024,D1        ;1024*16=16384 Bytes
s_del_block31:  clr.l   (A0)+
                clr.l   (A0)+           ;Buffer löschen
                clr.l   (A0)+
                clr.l   (A0)+
                dbra    D1,s_del_block31
                movea.l z_info_base(A4),A0
                subq.l  #2,A0
                move.w  anz_zeilen(A4),D0
s_del_block32:  subq.w  #1,D0
                blo.s   s_del_block2    ;Textende
                addq.l  #8,A0
                move.w  (A0)+,D1        ;Index holen
                bmi.s   s_del_block32   ;keine Symboldefinition
                add.w   D1,D1           ;mal 2
                addq.w  #1,0(A1,D1.w)   ;Anzahl zählen
                bra.s   s_del_block32
s_del_block2:   bsr     del_entry_block
                moveq   #0,D1
                adda.w  (A5),A6
                move.b  9(A5),D1
                adda.w  D1,A3
                lea     10(A5),A5
                dbra    D2,s_del_block2
                movea.l A5,A1
                movea.l block_pointer+4(A4),A0
                subq.w  #1,D2
s_del_block4:   move.l  (A1)+,(A0)+
                move.l  (A1)+,(A0)+     ;Zeileninfo kopieren
                move.w  (A1)+,(A0)+
                dbra    D3,s_del_block4
                movea.l block_pointer(A4),A0
                move.l  A3,D1
                sub.l   A0,D1
                move.l  comment_top(A4),D0
                sub.l   D1,comment_top(A4)
                sub.l   A3,D0
                lsr.l   #1,D0
                movea.l A3,A1
                bra.s   s_del_block51
s_del_block52:  swap    D0
s_del_block5:   move.w  (A1)+,(A0)+
s_del_block51:  dbra    D0,s_del_block5
                swap    D0
                dbra    D0,s_del_block52
                movea.l block_pointer+8(A4),A0
                move.l  A6,D1
                sub.l   A0,D1
                move.l  program_top(A4),D0
                sub.l   D1,program_top(A4)
                sub.l   A6,D0
                lsr.l   #1,D0
                movea.l A6,A1
                bra.s   s_del_block61
s_del_block62:  swap    D0
s_del_block6:   move.w  (A1)+,(A0)+
s_del_block61:  dbra    D0,s_del_block6
                swap    D0
                dbra    D0,s_del_block62
                moveq   #0,D2
                move.w  (SP)+,D2        ;Anzahl der Zeilen im Block
                lea     marker(A4),A1
                moveq   #12,D1          ;10 Marker + TEXT,DATA,BSS
s_delb2:        move.w  (A1)+,D0
                cmp.w   #$FFFF,D0       ;Marker nicht gesetzt
                beq.s   s_delb4
                cmp.w   block_anf(A4),D0
                blo.s   s_delb4         ;Marker vor Block
                cmp.w   block_end(A4),D0
                bhs.s   s_delb3         ;Marker hinter Block
                move.w  #$FFFF,-2(A1)   ;Marker im Block
                bra.s   s_delb4
s_delb3:        sub.w   D2,-2(A1)       ;Blocklänge abziehen
s_delb4:        dbra    D1,s_delb2      ;nächsten Marker
                move.l  D2,D0
                sub.w   D0,anz_zeilen(A4)
                add.l   D0,D0
                move.l  D0,D1
                lsl.l   #2,D0
                add.l   D1,D0
                sub.l   D0,z_info_top(A4)
                moveq   #0,D0
                move.w  block_anf(A4),D6
                bsr     search_part     ;PART-Tabelle updaten
                bsr     jump_line
                st      change_flag(A4) ;Sourcetext geändert
                clr.w   undo_buff(A4)   ;kein UNDO möglich
                bra     s_block_hide
                ENDPART
                >PART 'del_entry_block'
del_entry_block:movea.l ass_adr(A4),A0  ;Zeiger auf Anzahl-Tabelle
                moveq   #0,D0
                move.w  6(A5),D0        ;Label definiert
                bmi.s   del_entry_b1    ;nein
                add.w   D0,D0           ;mal 2
                subq.w  #1,0(A0,D0.w)   ;Anzahl erniedrigen
                move.w  0(A0,D0.w),D1   ;Anzahl holen
                movea.l label_base(A4),A0
                lsl.l   #4,D0           ;mal 16
                subq.w  #1,D1
                bhi.s   del_entry_b2    ;immer noch mehrmal definiert
                andi.b  #$7F,6(A0,D0.l) ;Bit für doppelte Deklaration löschen
                tst.w   D1
                beq.s   del_entry_b2    ;noch einmal definiert
                andi.b  #$7F,4(A0,D0.l) ;defined-Bit löschen
del_entry_b2:   jmp     del_entry2      ;weiter in Zeilenlösch-Routine
del_entry_b1:   movea.l label_base(A4),A0
                jmp     del_entry2
                ENDPART
                >PART 's_move_block'
s_move_block:   moveq   #$FF,D0
                cmp.l   block_anf(A4),D0
                beq     s_jmp_main      ;kein Block
                move.w  block_anf(A4),D0
                cmp.w   block_end(A4),D0
                bhs     s_jmp_main
                cmp.w   D0,D6
                blo.s   s_move_blocky
                cmp.w   block_end(A4),D6
                blo     s_jmp_main
s_move_blocky:  bclr    #7,sym_flag(A4)
                movem.l D2-D4,-(SP)
                movem.l A3/A5-A6,-(SP)
                move.w  D0,-(SP)
                bsr     calc_pointer
                movem.l A3/A5-A6,block_pointer(A4)
                move.w  block_end(A4),D2
                cmp.w   anz_zeilen(A4),D2
                bls.s   s_move_blockx
                move.w  anz_zeilen(A4),D2
                move.w  D2,block_end(A4)
s_move_blockx:  sub.w   (SP)+,D2        ;Anzahl der zu verschiebenen Zeilen
                move.w  D2,D0
                movea.l A5,A1
                movea.l A6,A2
                movea.l A3,A0
                moveq   #0,D1
                subq.w  #1,D0
s_move_block4:  adda.w  (A1),A2
                move.b  9(A1),D1        ;Endadresse des Blocks bestimmen
                adda.w  D1,A0
                lea     10(A1),A1
                dbra    D0,s_move_block4
                movem.l A0-A2,block_pointer2(A4)
                move.l  max_code_len(A4),D4
                movea.l block_pointer(A4),A1
                move.l  block_pointer2(A4),D2
                sub.l   A1,D2           ;Länge der Remarks
                beq     s_move_block10
                lsr.l   #1,D2
                move.l  D2,D1
                movea.l ass_adr(A4),A0
                move.l  D4,D0
                bra.s   s_move_block5
s_move_block0:  swap    D0
s_move_block5:  move.w  (A1)+,(A0)+     ;in Buffer
                subq.l  #1,D1
                dbeq    D0,s_move_block5
                beq.s   s_move_block01
                swap    D0
                dbra    D0,s_move_block0
s_move_block01: cmpa.l  (SP),A1         ;ak. Zeile
                bls.s   s_move_block6   ;Block nach unten
                movea.l block_pointer(A4),A0
                move.l  block_pointer(A4),D0
                sub.l   (SP),D0
                lsr.l   #1,D0
                beq.s   s_move_blockx6
                subq.l  #1,D0
                bra.s   s_move_block7
s_move_block9:  swap    D0
s_move_block7:  move.w  -(A0),-(A1)
                dbra    D0,s_move_block7
                swap    D0
                dbra    D0,s_move_block9
s_move_blockx6: movea.l (SP),A1
                movea.l ass_adr(A4),A0
                move.l  D2,D0
                subq.l  #1,D0
                bra.s   s_move_block8
s_move_block08: swap    D0
s_move_block8:  move.w  (A0)+,(A1)+     ;Buffer in Quelltext
                dbra    D0,s_move_block8
                swap    D0
                dbra    D0,s_move_block08
                bra.s   s_move_block10
s_move_block6:  move.l  (SP),D0
                sub.l   block_pointer2(A4),D0
                lsr.l   #1,D0
                beq.s   s_move_blockx1
                subq.w  #1,D0
                movea.l block_pointer(A4),A0
                bra.s   s_move_block3
s_move_block1:  swap    D0
s_move_block3:  move.w  (A1)+,(A0)+
                dbra    D0,s_move_block3
                swap    D0
                dbra    D0,s_move_block1
s_move_blockx1: movea.l ass_adr(A4),A1
                move.l  D2,D0
                subq.l  #1,D0
                bra.s   s_move_block2
s_move_block02: swap    D0
s_move_block2:  move.w  (A1)+,(A0)+
                dbra    D0,s_move_block2
                swap    D0
                dbra    D0,s_move_block02
s_move_block10: movea.l block_pointer+8(A4),A1
                move.l  block_pointer2+8(A4),D2
                sub.l   A1,D2           ;Länge des Programmcode
                beq     s_move_block20
                lsr.l   #1,D2
                move.l  D2,D1
                movea.l ass_adr(A4),A0
                move.l  D4,D0
                bra.s   s_move_block15
s_move_block12: swap    D0
s_move_block15: move.w  (A1)+,(A0)+     ;in Buffer
                subq.l  #1,D1
                dbeq    D0,s_move_block15
                beq.s   s_move_block1a
                swap    D0
                dbra    D0,s_move_block12
s_move_block1a: cmpa.l  8(SP),A1        ;ak. Zeile
                bls.s   s_move_block16  ;Block nach unten
                movea.l block_pointer+8(A4),A0
                move.l  block_pointer+8(A4),D0
                sub.l   8(SP),D0
                lsr.l   #1,D0
                beq.s   s_move_blockx7
                subq.l  #1,D0
                bra.s   s_move_block17
s_move_block11: swap    D0
s_move_block17: move.w  -(A0),-(A1)
                dbra    D0,s_move_block17
                swap    D0
                dbra    D0,s_move_block11
s_move_blockx7: movea.l 8(SP),A1
                movea.l ass_adr(A4),A0
                move.l  D2,D0
                subq.l  #1,D0
                bra.s   s_move_block18
s_move_block1b: swap    D0
s_move_block18: move.w  (A0)+,(A1)+     ;Buffer in Quelltext
                dbra    D0,s_move_block18
                swap    D0
                dbra    D0,s_move_block1b
                bra.s   s_move_block20
s_move_block16: move.l  8(SP),D0
                sub.l   block_pointer2+8(A4),D0
                lsr.l   #1,D0
                beq.s   s_move_blockx2
                subq.l  #1,D0
                movea.l block_pointer+8(A4),A0
                bra.s   s_move_block13
s_move_block19: swap    D0
s_move_block13: move.w  (A1)+,(A0)+
                dbra    D0,s_move_block13
                swap    D0
                dbra    D0,s_move_block19
s_move_blockx2: movea.l ass_adr(A4),A1
                move.l  D2,D0
                subq.l  #1,D0
                bra.s   s_move_block14
s_move_block1c: swap    D0
s_move_block14: move.w  (A1)+,(A0)+
                dbra    D0,s_move_block14
                swap    D0
                dbra    D0,s_move_block1c
s_move_block20: movea.l block_pointer+4(A4),A1
                move.l  block_pointer2+4(A4),D2
                sub.l   A1,D2           ;Länge des Zeileninfo
                lsr.l   #1,D2
                move.l  D2,D1
                movea.l ass_adr(A4),A0
                move.l  D4,D0
                bra.s   s_move_block25
s_move_block22: swap    D0
s_move_block25: move.w  (A1)+,(A0)+     ;in Buffer
                subq.l  #1,D1
                dbeq    D0,s_move_block25
                beq.s   s_move_block2a
                swap    D0
                dbra    D0,s_move_block22
s_move_block2a: cmpa.l  4(SP),A1        ;ak. Zeile
                bls     s_move_block26  ;Block nach unten
                movea.l block_pointer+4(A4),A0
                move.l  block_pointer+4(A4),D0
                sub.l   4(SP),D0
                lsr.l   #1,D0
                beq.s   s_move_blockx8
                subq.l  #1,D0
                bra.s   s_move_block27
s_move_block21: swap    D0
s_move_block27: move.w  -(A0),-(A1)
                dbra    D0,s_move_block27
                swap    D0
                dbra    D0,s_move_block21
s_move_blockx8: movea.l 4(SP),A1
                movea.l ass_adr(A4),A0
                move.l  D2,D0
                subq.l  #1,D0
                bra.s   s_move_block28
s_move_block2b: swap    D0
s_move_block28: move.w  (A0)+,(A1)+     ;Buffer in Quelltext
                dbra    D0,s_move_block28
                swap    D0
                dbra    D0,s_move_block2b
                movem.l (SP)+,A3/A5-A6  ;Block nach oben
                move.w  block_end(A4),D2
                sub.w   block_anf(A4),D2
                move.w  block_anf(A4),D3
                sub.w   D6,D3
                lea     marker(A4),A1
                moveq   #12,D1          ;10 Marker + TEXT,DATA,BSS
s_movb5:        move.w  (A1)+,D0
                cmp.w   #$FFFF,D0       ;Marker nicht gesetzt
                beq.s   s_movb7
                cmp.w   block_end(A4),D0
                bhs.s   s_movb7         ;Marker hinter Quellblock
                cmp.w   D6,D0
                blo.s   s_movb7         ;Marker vor Zielblock
                cmp.w   block_anf(A4),D0
                blo.s   s_movb6         ;Marker vor Quellblock
                sub.w   D3,D0           ;Marker im Quellblock
                move.w  D0,-2(A1)
                bra.s   s_movb7
s_movb6:        add.w   D2,D0           ;Blocklänge addieren
                move.w  D0,-2(A1)
s_movb7:        dbra    D1,s_movb5      ;nächsten Marker
                move.w  D6,block_anf(A4) ;neue Blockgrenzen
                add.w   D2,D6
                move.w  D6,block_end(A4)
                movem.l (SP)+,D2-D4
                st      change_flag(A4) ;Sourcetext geändert
                clr.w   undo_buff(A4)   ;kein UNDO möglich
                bsr     search_part     ;PART-Tabelle updaten
                bsr     jump_line
                jmp     main_loop
s_move_block26: move.l  4(SP),D0
                sub.l   block_pointer2+4(A4),D0
                lsr.l   #1,D0
                beq.s   s_move_blockx3
                subq.l  #1,D0
                movea.l block_pointer+4(A4),A0
                bra.s   s_move_block23
s_move_block29: swap    D0
s_move_block23: move.w  (A1)+,(A0)+
                dbra    D0,s_move_block23
                swap    D0
                dbra    D0,s_move_block29
s_move_blockx3: movea.l ass_adr(A4),A1
                move.l  D2,D0
                subq.l  #1,D0
                bra.s   s_move_block24
s_move_block2c: swap    D0
s_move_block24: move.w  (A1)+,(A0)+
                dbra    D0,s_move_block24
                swap    D0
                dbra    D0,s_move_block2c
                movem.l (SP)+,A3/A5-A6
                move.w  block_end(A4),D2 ;Block nach unten
                sub.w   block_anf(A4),D2
                move.w  D6,D3
                sub.w   block_end(A4),D3
                lea     marker(A4),A1
                moveq   #12,D1          ;10 Marker + TEXT,DATA,BSS
s_movb2:        move.w  (A1)+,D0
                cmp.w   #$FFFF,D0       ;Marker nicht gesetzt
                beq.s   s_movb4
                cmp.w   block_anf(A4),D0
                blo.s   s_movb4         ;Marker vor Quellblock
                cmp.w   D6,D0
                bhs.s   s_movb4         ;Marker hinter Zielblock
                cmp.w   block_end(A4),D0
                bhs.s   s_movb3         ;Marker hinter Block
                add.w   D3,D0           ;Marker im Quellblock
                move.w  D0,-2(A1)
                bra.s   s_movb4
s_movb3:        sub.w   D2,D0           ;Blocklänge abziehen
                move.w  D0,-2(A1)
s_movb4:        dbra    D1,s_movb2      ;nächsten Marker
                move.w  D6,block_end(A4) ;neue Blockgrenzen
                move.w  D6,block_anf(A4)
                sub.w   D2,block_anf(A4)
                movem.l (SP)+,D2-D4
                moveq   #0,D0
                bsr     calc_pointer
                movem.l A3/A5-A6,top_ptr(A4)
                clr.w   top_line(A4)
                clr.w   undo_buff(A4)   ;kein UNDO möglich
                bsr     search_part     ;PART-Tabelle updaten
                bsr     jump_line
                jmp     main_loop
                ENDPART
                >PART 's_copy_block'
s_copy_block:   moveq   #$FF,D0
                cmp.l   block_anf(A4),D0
                beq     s_jmp_main      ;kein Block
                move.w  block_anf(A4),D0
                cmp.w   block_end(A4),D0
                bhs     s_jmp_main
                cmp.w   D0,D6
                bls.s   s_copy_blocky   ;Cursor über Block
                cmp.w   block_end(A4),D6
                bhs.s   s_copy_blocky   ;Cursor hinter Block
                cmp.w   anz_zeilen(A4),D6
                blo     s_jmp_main
s_copy_blocky:  movem.l D2-D4,-(SP)
                movem.l A3/A5-A6,-(SP)  ;Zeiger auf ak. Zeile retten
                move.w  D0,-(SP)
                bsr     calc_pointer    ;Zeiger auf Blockanfang setzen
                movem.l A3/A5-A6,block_pointer(A4) ;und merken
                moveq   #0,D2
                move.w  block_end(A4),D2
                cmp.w   anz_zeilen(A4),D2
                bls.s   s_copy_block1
                move.w  anz_zeilen(A4),D2
                move.w  D2,block_end(A4)
s_copy_block1:  move.w  D2,D4           ;Blockende (Zeile) in D4 merken
                sub.w   (SP)+,D2        ;Anzahl der zu verschiebenen Zeilen
                move.w  D2,D0
                movea.l A5,A1
                movea.l A6,A2
                movea.l A3,A0
                moveq   #0,D1
                subq.w  #1,D0
s_copy_block2:  adda.w  (A1),A2
                move.b  9(A1),D1        ;Endadresse des Blocks bestimmen
                adda.w  D1,A0
                lea     10(A1),A1
                dbra    D0,s_copy_block2
                movem.l A0-A2,block_pointer2(A4)
                lsl.l   #6,D2           ;ca. 2 Einträge pro Zeile
                add.l   label_top(A4),D2
                cmp.l   label_max(A4),D2
                bhs     s_copy_err      ;reicht nicht
                move.l  A0,D0
                sub.l   block_pointer(A4),D0 ;Länge der Remarks im Block
                add.l   comment_top(A4),D0
                cmp.l   comment_max(A4),D0
                bhs     s_copy_err      ;reicht nicht
                move.l  A1,D0
                sub.l   block_pointer+4(A4),D0 ;Länge des Zeileninfo im Block
                add.l   z_info_top(A4),D0
                cmp.l   z_info_max(A4),D0
                bhs     s_copy_err      ;reicht nicht
                move.l  A2,D0
                sub.l   block_pointer+8(A4),D0 ;Länge des Codes im Block
                add.l   program_top(A4),D0
                cmp.l   program_max(A4),D0
                bhs     s_copy_err      ;reicht nicht

                move.l  block_pointer2(A4),D2
                sub.l   block_pointer(A4),D2
                beq.s   s_copy_block10
                movea.l comment_top(A4),A0
                move.l  A0,D0
                sub.l   (SP),D0
                beq.s   s_copy_block6
                lsr.l   #1,D0
                addq.l  #2,A0
                lea     0(A0,D2.w),A1
                bra.s   s_copy_block4
s_copy_block5:  swap    D0
s_copy_block4:  move.w  -(A0),-(A1)     ;Kommentare kopieren
                dbra    D0,s_copy_block4
                swap    D0
                dbra    D0,s_copy_block5
                movea.l block_pointer(A4),A0
                cmpa.l  (SP),A0
                blt.s   s_copy_block6
                add.l   D2,block_pointer(A4)
                add.l   D2,block_pointer2(A4)
s_copy_block6:  add.l   D2,comment_top(A4)
                movea.l (SP),A1
                movea.l block_pointer(A4),A0
                move.l  D2,D0
                lsr.l   #1,D0
                subq.l  #1,D0
                bra.s   s_copy_block7
s_copy_block8:  swap    D0
s_copy_block7:  move.w  (A0)+,(A1)+
                dbra    D0,s_copy_block7
                swap    D0
                dbra    D0,s_copy_block8
s_copy_block10: move.l  block_pointer2+8(A4),D2
                sub.l   block_pointer+8(A4),D2
                beq.s   s_copy_block20
                movea.l program_top(A4),A0
                move.l  A0,D0
                sub.l   8(SP),D0
                beq.s   s_copy_block16
                lsr.l   #1,D0
                addq.l  #2,A0
                lea     0(A0,D2.w),A1
                bra.s   s_copy_block14
s_copy_block15: swap    D0
s_copy_block14: move.w  -(A0),-(A1)
                dbra    D0,s_copy_block14
                swap    D0
                dbra    D0,s_copy_block15
                movea.l block_pointer+8(A4),A0
                cmpa.l  8(SP),A0
                blt.s   s_copy_block16
                add.l   D2,block_pointer+8(A4)
                add.l   D2,block_pointer2+8(A4)
s_copy_block16: add.l   D2,program_top(A4)
                movea.l 8(SP),A1
                movea.l block_pointer+8(A4),A0
                move.l  D2,D0
                lsr.l   #1,D0
                subq.l  #1,D0
                bra.s   s_copy_block17
s_copy_block18: swap    D0
s_copy_block17: move.w  (A0)+,(A1)+     ;Programmcode kopieren
                dbra    D0,s_copy_block17
                swap    D0
                dbra    D0,s_copy_block18
s_copy_block20: move.l  block_pointer2+4(A4),D2
                sub.l   block_pointer+4(A4),D2
                movea.l z_info_top(A4),A0
                move.l  A0,D0
                sub.l   4(SP),D0
                beq.s   s_copy_block26
                lsr.l   #1,D0
                addq.l  #2,A0
                lea     0(A0,D2.w),A1
                bra.s   s_copy_block24
s_copy_block25: swap    D0
s_copy_block24: move.w  -(A0),-(A1)
                dbra    D0,s_copy_block24
                swap    D0
                dbra    D0,s_copy_block25
                movea.l block_pointer+4(A4),A0
                cmpa.l  4(SP),A0
                blt.s   s_copy_block26
                add.l   D2,block_pointer+4(A4)
                add.l   D2,block_pointer2+4(A4)
s_copy_block26: add.l   D2,z_info_top(A4)
                movea.l 4(SP),A1
                movea.l block_pointer+4(A4),A0
                move.l  D2,D0
                lsr.l   #1,D0
                subq.l  #1,D0
                bra.s   s_copy_block27
s_copy_block28: swap    D0
s_copy_block27: move.w  (A0)+,(A1)+     ;Zeileninfo kopieren
                dbra    D0,s_copy_block27
                swap    D0
                dbra    D0,s_copy_block28
                movea.l z_info_top(A4),A0
                moveq   #-1,D1
                move.w  D1,(A0)         ;Endekennung neu setzen
                move.w  D1,6(A0)
                sub.w   block_anf(A4),D4 ;Länge des Blocks
                add.w   D4,anz_zeilen(A4) ;Anzahl der Zeilen um Blocklänge erhöhen
                cmp.w   block_anf(A4),D6 ;ist der Zielblock vor dem Quellblock?
                bhi.s   s_copb1         ;nein, Blockmarken müssen nicht angepaßt werden
                add.w   D4,block_anf(A4) ;Blockmarken um Blocklänge nach
                add.w   D4,block_end(A4) ;hinten schieben
s_copb1:        lea     marker(A4),A1
                moveq   #12,D1          ;10 Marker + TEXT,DATA,BSS
s_copb2:        move.w  (A1)+,D0
                cmp.w   #$FFFF,D0       ;Marker nicht gesetzt
                beq.s   s_copb4
                cmp.w   D6,D0           ;D6 gleich Startzeile des Zielblocks
                blo.s   s_copb4         ;Marker vor Zielblock
                add.w   D4,D0
                move.w  D0,-2(A1)
s_copb4:        dbra    D1,s_copb2      ;nächsten Marker
                movem.l (SP),A3/A5-A6   ;Zeiger auf Anfang des neuen Blocks
                lea     op_buffer(A4),A3
                move.l  label_base(A4),D3
                moveq   #0,D1
                subq.w  #1,D4
s_copy_block31: movea.l A3,A2
                move.w  (A5),D0
                bra.s   s_copy_block34
s_copy_block35: move.b  0(A6,D0.w),14(A2,D0.w)
s_copy_block34: dbra    D0,s_copy_block35
                move.l  2(A5),2(A2)
                jsr     s_dup_line0
                move.l  2(A2),2(A5)
                lea     14(A3),A2
                move.w  (A5),D0
                lsr.w   #1,D0
                bra.s   s_copy_block32
s_copy_block33: move.w  (A2)+,(A6)+
s_copy_block32: dbra    D0,s_copy_block33
                move.w  6(A5),D0
                bmi.s   s_copy_block36
                ext.l   D0
                lsl.l   #5,D0
                movea.l D3,A0
                ori.b   #$80,6(A0,D0.l) ;Bit für doppelte Deklaration
s_copy_block36: lea     10(A5),A5
                dbra    D4,s_copy_block31
                movem.l (SP)+,A3/A5-A6
                movem.l (SP)+,D2-D4
                moveq   #0,D0
                bsr     calc_pointer    ;Zeiger auf erste Zeile
                movem.l A3/A5-A6,top_ptr(A4)
                st      change_flag(A4) ;Sourcetext geändert
                clr.w   undo_buff(A4)   ;kein UNDO möglich
                clr.w   top_line(A4)
                bsr     search_part     ;PART-Tabelle updaten
                bsr     jump_line       ;Sprung in Zeile D6
                jmp     main_loop
s_copy_err:     movem.l (SP)+,A3/A5-A6
                movem.l (SP)+,D2-D4
                lea     outofmem_rsc(PC),A0
                jsr     _form_do
                jmp     main_loop

outofmem_rsc:   DC.W 0,0,43,6,1
                DC.W 8,1
                DC.L outofmem_0
                DC.W 8
                DC.W 8,2
                DC.L outofmem_1
                DC.W 8
                DC.W 16,4
                DC.L ok_button
                DC.W $26
                DC.W 1,1
                DC.L stop_icn
                DC.W $3303
                DC.W -1
                SWITCH sprache
                CASE 0
outofmem_0:     DC.B 'Das Komando wurde wegen',0
outofmem_1:     DC.B 'Speicherplatzmangel abgebrochen.',0
                CASE 1
outofmem_0:     DC.B 'The commando has been canceled',0
outofmem_1:     DC.B 'because of less memory.',0
                ENDS
                EVEN
                ENDPART
                >PART 's_block_end'
s_block_end:    move.l  block_anf(A4),D0
                addq.l  #1,D0
                beq     s_jmp_main      ;D0=-1
                subq.l  #1,D0
                ext.l   D0
                bra.s   s_pgend2
                ENDPART
                >PART 's_block_start'
s_block_start:  move.l  block_anf(A4),D0
                addq.l  #1,D0
                beq     s_jmp_main      ;D0=-1
                subq.l  #1,D0
                swap    D0
                ext.l   D0
                bra.s   s_pgend2
                ENDPART
                >PART 's_pgend/2'
s_pgend:        move.w  anz_zeilen(A4),D0
s_pgend2:       move.w  D6,letzte_zeile(A4)
                move.w  D0,D6
                bsr     jump_line
                clr.w   save_pos(A4)
                jmp     main_loop
                ENDPART
                >PART 's_pgstart/2'
s_pgstart:      tst.w   D6
                beq.s   s_pgend
s_pgstart2:     moveq   #0,D0
                bra.s   s_pgend2
                ENDPART
                >PART 's_home'
s_home:         clr.w   save_pos(A4)
                tst.w   scr_z(A4)
                beq.s   s_bottom
                clr.w   scr_z(A4)
                move.w  top_line(A4),D6
                movem.l top_ptr(A4),A3/A5-A6
                jmp     main_loop
                ENDPART
                >PART 's_bottom'
s_bottom:       lea     lin_tab2(A4),A0 ;Tabelle der Zeilennummern
                move.w  sdrv_zanz(A4),D0
                add.w   D0,D0
                move.w  anz_zeilen(A4),D1
                move.w  0(A0,D0.w),D6   ;Zeilennummer holen
                cmp.w   D1,D6           ;Zeile hinter Ende?
                bls.s   s_bott1         ;nein
                sub.w   D1,D6           ;Anz. Zeilen über das Ende hinaus
                add.w   D6,D6           ;mal 2
                sub.w   D6,D0
                move.w  D1,D6           ;ak. Zeile=letzte Zeile
s_bott1:        lsr.w   #1,D0           ;durch 2
                move.w  D0,scr_z(A4)    ;neue Bildschirmzeile
                move.w  D6,D0
                bsr     calc_pointer    ;Zeiger auf Zeile berechnen
                jmp     main_loop
                ENDPART
                >PART 's_scroll2_dn'
s_scroll2_dn:   move.w  anz_zeilen(A4),D0
                sub.w   D6,D0
                beq     s_jmp_main      ;in letzter Zeile
                cmp.w   sdrv_zanz(A4),D0
                bls.s   s_scroll2_dn3
                move.w  scr_z(A4),D0
                tst.w   D0              ;am oberen Bildschirmrand
                bne.s   s_scroll2_dn2
                jsr     down
s_scroll2_dn2:  subq.w  #1,scr_z(A4)
                jsr     scrollu         ;raufscrollen
                bra     s_jmp_main
s_scroll2_dn3:  jmp     s_down          ;einfach Cursor down
                ENDPART
                >PART 's_scroll_dn'
s_scroll_dn:    move.w  anz_zeilen(A4),D0
                sub.w   D6,D0
                beq     s_jmp_main
                jsr     scrollu
                lea     lin_tab2(A4),A0
                move.w  scr_z(A4),D0    ;ak. Screenzeile
                add.w   D0,D0           ;mal 2
                move.w  0(A0,D0.w),D6   ;ak. Zeile
                move.w  D6,D0
                bsr     calc_pointer    ;Zeiger auf ak. Zeile berechnen
                bra     s_jmp_main
                ENDPART
                >PART 's_10pgdown'
s_10pgdown:     move.w  sdrv_zanz(A4),D1
                addq.w  #1,D1
                mulu    #10,D1          ;10 Seiten nach unten
                bra.s   s_pgdown5
                ENDPART
                >PART 's_pgdown'
s_pgdown:       move.w  sdrv_zanz(A4),D1
                addq.w  #1,D1           ;eine Seite nach unten
s_pgdown5:      move.w  D1,D0           ;Anzahl der Screenzeilen
                subq.w  #1,D0           ;wegen DBRA
                bmi     s_pgend         ;Anzahl zu klein
                bsr     calc_anz_down   ;berechnet die Anzahl der Soucezeilen(D1)
                move.w  D1,D0           ;Anzahl der Sourcezeilen, die es nach unten geht
                subq.w  #1,D0           ;wegen DBRA
                jsr     top_pl2         ;Zeiger auf top_line berechnen
                bsr     redraw_all      ;alles updaten
                move.w  scr_z(A4),D0    ;ak. Screenzeile
                add.w   D0,D0           ;mal 2
                lea     lin_tab2(A4),A0
                move.w  0(A0,D0.w),D0   ;Zeilennummer holen
                cmp.w   anz_zeilen(A4),D0 ;mit max. Anzahl vergleichen
                bhs     s_pgend         ;zu groß -> ans Ende springen
                move.w  D0,D6           ;ist ak.Zeile
                bsr     calc_pointer    ;Zeiger auf ak. Zeile berechnen
                bra     s_jmp_main
                ENDPART
                >PART 's_scroll2_up'
s_scroll2_up:   tst.w   top_line(A4)
                beq     s_jmp_main      ;in oberster Zeile
                move.w  scr_z(A4),D0
                cmp.w   sdrv_zanz(A4),D0 ;am unteren Bildschirmrand
                bne.s   s_scroll2_up2
                jsr     up
s_scroll2_up2:  addq.w  #1,scr_z(A4)
                jsr     scrolld         ;runtersrollen
                bra     s_jmp_main
                ENDPART
                >PART 's_scroll_up'
s_scroll_up:    tst.w   top_line(A4)
                beq.s   s_scroll_up2
                jsr     scrolld
                lea     lin_tab2(A4),A0
                move.w  scr_z(A4),D0    ;ak. Screenzeile
                add.w   D0,D0           ;mal 2
                move.w  0(A0,D0.w),D6   ;ak. Zeile
                move.w  D6,D0
                bsr     calc_pointer    ;Zeiger auf ak. Zeile berechnen
                bra     s_jmp_main
s_scroll_up2:   jsr     up              ;Cursor up
                bra     s_jmp_main
                ENDPART
                >PART 's_10pgup'
s_10pgup:       move.w  sdrv_zanz(A4),D0
                addq.w  #1,D0
                mulu    #10,D0          ;10 Seiten nach oben
                bra.s   s_pgup6
                ENDPART
                >PART 's_pgup'
s_pgup:         move.w  sdrv_zanz(A4),D0
                addq.w  #1,D0           ;eine Seite nach oben
s_pgup6:        tst.w   D6
                beq     s_jmp_main      ;in erster Zeile
                cmp.w   D6,D0
                bhs     s_pgstart
                cmp.w   top_line(A4),D0
                blo.s   s_pgup5
                move.w  top_line(A4),D0
s_pgup5:        subq.w  #1,D0           ;wegen DBRA
                bmi     s_jmp_main
                bsr.s   calc_anz_up     ;Anzahl der Sourcezeilen berechnen(D1)
                move.w  D1,D0
                subq.w  #1,D0           ;wegen DBRA
                jsr     top_mi2         ;Zeiger auf top_line berechnen
                bsr     redraw_all      ;alles updaten
                move.w  scr_z(A4),D0    ;ak. Screenzeile
                add.w   D0,D0           ;mal 2
                lea     lin_tab2(A4),A0
                move.w  0(A0,D0.w),D0   ;Zeilennummer holen
                move.w  D0,D6           ;ist ak.Zeile
                bsr     calc_pointer    ;Zeiger auf ak. Zeile berechnen
                bra     s_jmp_main
                ENDPART
************************************************************************
* berechnet die tatsächliche Anzahl der Zeilen für Page up             *
* ->D0: Anzahl der Sceenzeilen, die es runter geht                     *
* <-D1: Anzahl der Sourcezeilen                                        *
************************************************************************
                >PART 'calc_anz_up'
calc_anz_up:    move.l  A0,-(SP)
                move.w  top_line(A4),D1
                beq.s   s_pgup531       ;oberste Zeile
                lea     partbuffer(A4),A0
                tst.l   (A0)
                beq.s   s_pgup52        ;keine versteckten Teile
s_pgup50:       tst.l   (A0)+           ;Ende suchen
                bne.s   s_pgup50
                subq.l  #8,A0
s_pgup51:       cmp.w   2(A0),D1        ;mit Endzeile vergleichen
                bhi.s   s_pgup53        ;größer
                cmp.w   (A0),D1         ;mit Startzeile vergleichen
                bls.s   s_pgup54        ;kleiner
                move.w  (A0),D1         ;Block überspringen
                bra.s   s_pgup54
s_pgup53:       subq.w  #1,D1           ;eine Zeile weiter hoch
                dbeq    D0,s_pgup51     ;Abbruch, wenn in oberster Zeile
                cmp.w   2(A0),D1        ;enthält Zielzeile ENDPART?
                bhi.s   s_pgup531       ;nein
                move.w  (A0),D1         ;überspringen
s_pgup531:      move.w  D1,D0
                move.w  top_line(A4),D1 ;Anzahl berechnen
                sub.w   D0,D1
                movea.l (SP)+,A0
                rts
s_pgup54:       subq.l  #4,A0           ;nächsten Eintrag
                tst.l   (A0)
                bne.s   s_pgup51        ;noch nicht am Ende
s_pgup52:       sub.w   D0,D1           ;restlichen Zeilen abziehen
                bls.s   s_pgup521       ;Unterlauf
                subq.w  #1,D1           ;wegen DBRA
                move.w  D1,D0
                move.w  top_line(A4),D1
                sub.w   D0,D1           ;Anzahl berechnen
                movea.l (SP)+,A0
                rts
s_pgup521:      move.w  top_line(A4),D1 ;Zeilen bis zum Anfang
                movea.l (SP)+,A0
                rts
                ENDPART
************************************************************************
* berechnet die tatsächliche Anzahl der Zeilen für Page down           *
* ->D0: Anzahl der Sceenzeilen, die es runter geht                     *
* <-D1: Anzahl der Sourcezeilen                                        *
************************************************************************
                >PART 'calc_anz_down'
calc_anz_down:  move.l  A0,-(SP)
                move.w  top_line(A4),D1 ;Anzahl der Zeilen ermitteln
                lea     partbuffer(A4),A0
                tst.l   (A0)
                beq.s   s_pgdown52      ;keine versteckten Teile
s_pgdown51:     cmp.w   (A0),D1         ;mit Startzeile vergleichen
                bls.s   s_pgdown53      ;kleiner
                cmp.w   2(A0),D1        ;mit Endzeile vergleichen
                bhi.s   s_pgdown54      ;größer
                move.w  2(A0),D1        ;Block überspringen
                addq.w  #1,D1
                bra.s   s_pgdown54
s_pgdown53:     addq.w  #1,D1           ;eine Zeile weiter
                dbra    D0,s_pgdown51
                sub.w   top_line(A4),D1
                movea.l (SP)+,A0
                rts
s_pgdown54:     addq.l  #4,A0           ;nächsten Eintrag
                tst.l   (A0)
                bne.s   s_pgdown51      ;weiter vergleichen
s_pgdown52:     add.w   D0,D1           ;restlichen Zeilen dazuaddieren
                addq.w  #1,D1           ;wegen DBRA
                sub.w   top_line(A4),D1
                movea.l (SP)+,A0
                rts
                ENDPART
************************************************************************
* spezielle Initialisierung für Assembler                              *
************************************************************************
                >PART 'ass_init'
ass_init:       moveq   #20,D0          ;Defaultbutton=1.Button
                sf      debugger_da(A4)
                movea.l 8.w,A0          ;Busfehlervektor holen
                cmpi.l  #'TASS',-8(A0)  ;Assembler schon installiert?
                bne.s   ass_init4       ;Nein! =>
                movea.l -(A0),A0        ;dann eine Ebene runter
ass_init4:      cmpi.w  #'∑-',-(A0)
                bne.s   no_debugger     ;Vektor des Debuggers?
                cmpi.l  #'Soft',-(A0)
                bne.s   no_debugger
                move.l  -(A0),debugger_adr(A4) ;Startadresse
                addq.b  #1,debugger_da(A4) ;Debugger nicht resident, aber da
                st      debugger_da(A4) ;Debugger resident im Speicher
                lea     debugger_entry,A0
                andi.b  #$FD,(A0)       ;Debugger im Menü enablen
                ori.b   #2,debugger_entry2-debugger_entry(A0) ;'Debugger nachladen' disablen
                ori.b   #2,debugger_entry3-debugger_entry(A0) ;'Debugger löschen' disablen
                btst    #4,ass_rsc_c+1(PC)
                bne.s   no_debugger     ;wenn 1.Button disabled =>
                moveq   #10,D0          ;Defaultbutton=Debugger
no_debugger:    move.w  D0,asm_default(A4)
                lea     code_tab,A0
                moveq   #-1,D0
tabloop:        addq.l  #1,D0           ;Länge der Befehlstabelle bestimmen
                move.w  D0,D1
                lsl.w   #4,D1
                tst.b   0(A0,D1.w)
                bpl.s   tabloop
                move.w  D0,tablen(A4)
                move.w  #16,tabs(A4)    ;Befehlstab
                move.w  #24,tabs+2(A4)  ;Operantentab
                move.w  #40,tabs+4(A4)  ;Remarktab
                move.w  #16,tabs+6(A4)  ;Pseudooptab
                move.w  #32,tabs+8(A4)  ;Remarktab für Pseudoopcodes
                move.b  #$20,opcodesize_flag(A4)
                clr.b   pcodesize_flag(A4)
                clr.b   reg_flag(A4)
                clr.b   hex_flag(A4)
                clr.b   hexlen_flag(A4)
                move.b  #$20,sp_flag(A4)
                st      bak_flag(A4)
                sf      uhr_flag(A4)
                moveq   #1,D0
                jsr     _graf_mouse     ;Diskette an
                move.w  #$19,-(SP)
                bsr     do_trap_1       ;aktuelles Drive holen
                addq.l  #2,SP
                move.w  D0,D1
                lea     fpath_src(A4),A0
                lea     ass_path(PC),A1
                bsr     ass_get_path    ;Pfad für Sourcetext
                lea     fpath_code(A4),A0
                lea     ass_path2(PC),A1
                bsr     ass_get_path    ;Pfad für Zielcode
                lea     fpath_temp(A4),A0
                lea     ass_path3(PC),A1
                bsr     ass_get_path    ;Pfad für Zuladen
                lea     fpath_sel(A4),A0 ;Fileselector-Pfad für
                lea     ass_path3(PC),A1 ;'Debugger nachladen' gesondert
                bsr     ass_get_path    ;setzen
                lea     ass_path5+1(PC),A3
                lea     fpath_inf(A4),A0
                move.w  D1,-(SP)
                bsr     hunt_environment ;Environment-String ?
                movem.w (SP)+,D1
                beq.s   ass_init1       ;Ja! =>
                subq.l  #1,A3           ;'\' vor dem Filenamen!
                movea.l A3,A1
                bsr     ass_get_path    ;Pfad für INF-Datei ermitteln
ass_init1:      sf      block_pointer(A4) ;Flag löschen
                clr.w   -(SP)
                pea     fpath_inf(A4)
                move.w  #$3D,-(SP)      ;Fopen
                bsr     do_trap_1
                addq.l  #8,SP
                move.w  D0,fhandle(A4)
                bmi     ass_loop4

                lea     dbuffer(A4),A0
                move.l  A0,-(SP)
                pea     32000.w
                move.w  fhandle(A4),-(SP)
                move.w  #$3F,-(SP)      ;Fread
                bsr     do_trap_1
                lea     12(SP),SP
                tst.l   D0
                ble     ass_loop4
                bsr     fclose

                moveq   #(s_suchzeichen+1-tabs)/2,D1 ;Länge der aktuellen INF-Datei
                add.w   #(screen_delay+4-bak_flag)/2+8,D1
                add.w   #(tmacro_tab_end-tmacro_tab)/4,D1

                cmpi.l  #'∑ASM',(A0)+
                bne     ass_loop4       ;INF-File ist Mist
                cmp.w   (A0)+,D1        ;stimmt die Länge
                bne     ass_loop5       ;nein

                st      block_pointer(A4) ;Flag setzen (INF-File gefunden)
                moveq   #(s_suchzeichen+1-tabs)/2-1,D0
                lea     tabs(A4),A1
ass_loop41:     move.w  (A0)+,(A1)+
                dbra    D0,ass_loop41
                moveq   #(screen_delay+4-bak_flag)/2-1,D0
                lea     bak_flag(A4),A1
ass_loop42:     move.w  (A0)+,(A1)+
                dbra    D0,ass_loop42
                move.b  asc_show_flag(A4),D0 ;Wenn <>0, dann Flag auf 1 setzen
                sne     D0              ;wenn =0, dann Flag auf 0 belassen
                neg.b   D0
                move.b  D0,asc_show_flag(A4)
                lea     spezial_11(PC),A1
                move.l  (A0)+,(A1)+     ;Default-Extension
                lea     alquantor(PC),A1
                move.b  (A0)+,(A1)      ;'*'-Joker
                move.b  (A0)+,2(A1)     ;'?'-Joker
                lea     uhr_button(PC),A1
                SWITCH sprache
                CASE 0
                move.l  #' AUS',D0
                CASE 1
                move.l  #' ON ',D0
                ENDS
                tst.b   uhr_flag(A4)
                beq.s   uhrinit         ;Uhr aus?
                SWITCH sprache
                CASE 0
                move.l  #' EIN',D0
                CASE 1
                move.l  #' OFF',D0
                ENDS
uhrinit:        move.l  D0,(A1)
                move.w  #(tmacro_tab_end-tmacro_tab)/4-1,D0
                lea     tmacro_tab(A4),A1
ass_loop43:     move.l  (A0)+,(A1)+
                dbra    D0,ass_loop43
                move.b  (A0)+,start_flag(A4)
                move.b  (A0)+,block_pointer+2(A4) ;Debuggerflag merken
                movea.l basepage(A4),A1 ;Adresse der Basepage
                tst.b   128(A1)         ;Commandline vorhanden ?
                bne.s   ass_loop45      ;ja, dann Pfad so lassen
                bsr     test_path       ;gültiger Pfad?
                bmi.s   ass_loop45      ;nein
                lea     fpath_src(A4),A1
ass_loop44:     move.b  (A0)+,(A1)+     ;Sourcepfad übertragen
                bne.s   ass_loop44
ass_loop45:     lea     $FFFF8240.w,A0
                move.w  col0(A4),(A0)+
                move.w  col1(A4),D0
                move.w  D0,(A0)+
                move.w  D0,(A0)+
                move.w  D0,(A0)+
                moveq   #' ',D0
                tst.b   skip_warn(A4)   ;Warnflag testen
                beq.s   s_warnflag2
                moveq   #'',D0
s_warnflag2:    move.b  D0,warn_entry+1
ass_loop4:      lea     fname_temp(A4),A0
                move.l  #'NONA',(A0)+
                move.w  #'ME',(A0)+
                move.b  #'.',(A0)+
                lea     spezial_11(PC),A1
                moveq   #2,D1
ass_loop:       move.b  (A1)+,D0
                beq.s   ass_loop3
                cmp.b   #' ',D0
                beq.s   ass_loop2
                move.b  D0,(A0)+
ass_loop2:      dbra    D1,ass_loop
ass_loop3:      clr.b   (A0)+
                lea     fname_code(A4),A0
                move.l  #'NONA',(A0)+
                move.l  #'ME.P',(A0)+
                move.w  #'RG',(A0)+
                clr.b   (A0)+
                bsr     read_cfg        ;Printerkonfiguration lesen
                tst.w   D0
                beq.s   ass_init3       ;Datei gefunden
                move.l  #prn_default2,prt_tab1(A4)
                move.l  #prn_default3,prt_tab2(A4)
ass_init3:      pea     -1.w
                move.w  #$48,-(SP)
                bsr     do_trap_1       ;verfügbare Bytes holen
                addq.w  #6,SP
                move.l  D0,D2           ;D0=verfügbarer Speicher
                move.l  D0,memory_free(A4)
                tst.b   block_pointer(A4) ;INF-File geladen ?
                beq.s   ass_init21      ;nein !
                bsr     ass_chk_mem     ;Zielcode und GEM Speicher testen
                bge.s   ass_init2       ;Konfiguration kann übernommen werden
ass_init21:     moveq   #12,D1
                bsr     ldiv            ;durch 12 teilen
                move.l  D2,max_code_len(A4)
                move.l  #40000,memory_gem(A4)
                tst.b   debugger_da(A4)
                bpl.s   ass_init2
                addi.l  #120000,memory_gem(A4)
ass_init2:      move.l  memory_free(A4),D3
                sub.l   memory_gem(A4),D3 ;minus Speicher fürs GEM
                cmp.l   #120000,D3      ;absolutes Minimum
                ble.s   no_memory       ;Speicher reicht nicht
                move.l  D3,-(SP)        ;Gesamtbedarf für Source + Zielcode
                move.w  #$48,-(SP)
                bsr     do_trap_1
                addq.w  #6,SP
                bsr     mem_verteilung  ;Speicher verteilen
                bsr.s   ass_init20      ;Labeltabelle löschen (wegen Ascii-Laden)
                movea.l z_info_base(A4),A0
                move.w  #$FFFF,(A0)
                clr.w   label_top_ind(A4)
                clr.w   anz_zeilen(A4)
                moveq   #0,D0
                jsr     _graf_mouse     ;Pfeil wieder an
                rts
no_memory:      moveq   #0,D0
                jsr     _graf_mouse     ;Pfeil wieder an
                lea     no_mem_rsc(PC),A0
                jsr     _form_do
                bra     do_quit         ;Assembler verlassen
ass_init20:     move.w  max_index(A4),D0 ;Anzahl der Symboleinträge
                movea.l label_base(A4),A0 ;Zeiger auf Labeltabelle
                bra.s   ass_init201
ass_init200:    clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+           ;32 Bytes löschen
                clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+
                clr.l   (A0)+
ass_init201:    dbra    D0,ass_init200
                rts

prn_default2:   DC.B 4,1,$0D,$0A,0 ;CR/LF
                EVEN
prn_default3:   DC.W 0          ;keine Zeichenkonvertierung

ass_loop5:      moveq   #0,D0
                jsr     _graf_mouse     ;Pfeil wieder an
                lea     ass_loop_rsc(PC),A0
                jsr     _form_do
                bra     ass_loop4
                ENDPART
************************************************************************
* testet, ob Pfad ab A0 gültig ist                                     *
************************************************************************
                >PART 'test_path'
test_path:      movem.l D0-D2/A0-A1,-(SP)
                moveq   #$FF,D2
                move.w  #$19,-(SP)      ;Dgetdrv
                bsr     do_trap_1
                addq.l  #2,SP
                move.w  D0,D1           ;Drive merken
                move.b  (A0),D0
                cmp.b   #'A',D0
                blt.s   test_path1
                cmp.b   #'P',D0
                bgt.s   test_path1      ;ungültiges Laufwerk
                sub.w   #'A',D0
                move.w  D0,-(SP)
                move.w  #$0E,-(SP)      ;Dsetdrv
                bsr     do_trap_1
                addq.l  #4,SP
                clr.w   -(SP)           ;ak. Laufwerk
                pea     dbuffer(A4)
                move.w  #$47,-(SP)      ;Dgetpath
                bsr     do_trap_1
                addq.l  #8,SP
                movea.l A0,A1
test_path2:     tst.b   (A0)+           ;Ende des Pfads suchen
                bne.s   test_path2
test_path3:     cmpi.b  #'\',-(A0)
                bne.s   test_path3
                clr.b   (A0)            ;Extension abschneiden
                move.l  A1,-(SP)
                move.w  #$3B,-(SP)      ;Dsetpath
                bsr     do_trap_1
                addq.l  #6,SP
                tst.w   D0
                bmi.s   test_path4      ;Ordner nicht gefunden
                moveq   #0,D2           ;Pfad ok
test_path4:     move.b  #'\',(A0)       ;Pfad rekonstruieren
                pea     dbuffer(A4)     ;alten Pfad wieder setzen
                move.w  #$3B,-(SP)      ;Dsetpath
                bsr     do_trap_1
                addq.l  #6,SP
test_path1:     move.w  D1,-(SP)        ;altes Laufwerk
                move.w  #$0E,-(SP)      ;wieder setzen
                bsr     do_trap_1
                addq.l  #4,SP
                tst.w   D2              ;Flags setzen
                movem.l (SP)+,D0-D2/A0-A1
                rts
                ENDPART
                >PART 'aes_loop_rsc'
ass_loop_rsc:   DC.W 0,0,28,6,0
                DC.W 1,1
                DC.L ass_loop_1
                DC.W 8
                DC.W 1,2
                DC.L ass_loop_2
                DC.W 8
                DC.W 9,4
                DC.L ok_button
                DC.W $26
                DC.W -1
no_mem_rsc:     DC.W 0,0,26,7,0
                DC.W 1,1
                DC.L no_mem_1
                DC.W 8
                DC.W 3,3
                DC.L no_mem_2
                DC.W 8
                DC.W 8,5
                DC.L abbruch_button
                DC.W $26
                DC.W -1

                SWITCH sprache
                CASE 0
no_mem_1:       DC.B 'Der vorhandene Speicher',0
no_mem_2:       DC.B 'reicht nicht aus !',0
ass_loop_1:     DC.B 'Das Format des vorhandenen',0
ass_loop_2:     DC.B '.INF-Files ist unbekannt.',0
s_dbg_txt:      DC.B 'DEBUGGER LADEN',0
                CASE 1
no_mem_1:       DC.B 'The memorysize is',0
no_mem_2:       DC.B 'too small!',0
ass_loop_1:     DC.B 'The format of the ',0
ass_loop_2:     DC.B '.INF-File ist unknown.',0
s_dbg_txt:      DC.B 'LOAD DEBUGGER',0
                ENDS
                EVEN
                ENDPART
                >PART 'ass_chk_mem'
ass_chk_mem:    move.l  memory_free(A4),D0
                sub.l   memory_gem(A4),D0
                sub.l   max_code_len(A4),D0 ;Zielcodespeicher
                btst    #1,editor3_flag(A4) ;Debugger nachladen?
                beq.s   ass_chk_mem1    ;nein
                tst.b   block_pointer+2(A4) ;war Debugger da?
                beq.s   ass_chk_mem1    ;nein
                cmp.l   #340000,D0      ;reicht der Platz noch für Debugger?
                blt.s   ass_chk_mem1    ;nein, dann Konfiguration so lassen
                move    SR,-(SP)        ;Flag aus Vergleich retten
                addi.l  #240000,memory_gem(A4) ;Speicher für GEM vergrößern
                move    (SP)+,SR
                rts
ass_chk_mem1:   cmp.l   #100000,D0      ;Mindestspeicher für Sourcetext
                rts
                ENDPART
************************************************************************
* verteilt den angeforderten Speicher für die einzelnen Bereiche       *
* D0=Startadresse des Speichers                                        *
* D3=Speichergröße                                                     *
************************************************************************
                >PART 'mem_verteilung'
mem_verteilung: movea.l D0,A1           ;Adresse nach A1
                move.l  D3,D0
                sub.l   max_code_len(A4),D0
                add.l   A1,D0           ;Anfangsadresse des Zielcodespeichers
                bclr    #0,D0           ;begradigen
                move.l  D0,ass_adr(A4)
                sub.l   max_code_len(A4),D3
                subq.l  #1,D3           ;wegen Begradigung
                move.l  D3,D2
                moveq   #6,D1
                bsr     ldiv            ;Anzahl durch 6
                add.l   D2,D2           ;und wieder mal 2 ->gerade Anzahl
                sub.l   D2,D3
                sub.l   D2,D3
                move.l  D2,D0           ;Ergebnis merken(INFO und LABELTAB)
                moveq   #6,D1
                bsr     ldiv            ;Anzahl durch 6
                add.l   D2,D2           ;und wieder mal 2 -> gerader Wert
                sub.l   D2,D3
                andi.w  #$FFFE,D3       ;gerade Anzahl für Remark
                move.l  D2,-(SP)
                move.l  #65536*10,D2    ;max.Zeileninfogröße
                move.l  D0,D1
                cmp.l   D2,D1           ;max.Zeileninfogröße
                blo.s   mem_verteilung1
                sub.l   D2,D1           ;freier Restspeicher
                add.l   D1,(SP)         ;zum Opcodespeicher
                move.l  D2,D1           ;max.Zeileninfogröße setzen
mem_verteilung1:move.l  #16384*32,D2
                cmp.l   D2,D0           ;max.Labeltabellengröße
                blo.s   mem_verteilung2
                sub.l   D2,D0           ;freier Restspeicher
                add.l   D0,D3           ;zum Remarkspeicher
                move.l  D2,D0           ;max.Labeltabellengröße setzen
mem_verteilung2:move.l  (SP)+,D2
                move.l  A1,memory_base(A4)
                move.l  A1,program_base(A4) ;Opcodestart
                move.l  A1,program_top(A4)
                adda.l  D2,A1
                move.l  A1,program_max(A4)
                move.l  A1,z_info_base(A4) ;Zeileninfostart
                move.l  A1,z_info_top(A4)
                adda.l  D1,A1
                move.l  A1,z_info_max(A4)
                move.l  A1,label_base(A4) ;Labeltabellenstart
                move.l  A1,label_top(A4)
                adda.l  D0,A1
                move.l  A1,label_max(A4)
                move.l  A1,comment_base(A4) ;Remarkstart
                move.l  A1,comment_top(A4)
                adda.l  D3,A1
                move.l  A1,comment_max(A4)
                move.l  A1,memory_top(A4) ;Ende des Sourcespeichers
                move.l  D1,-(SP)        ;Labeltabellengröße merken
                move.l  D1,D2           ;Zeileninfogröße
                moveq   #10,D1
                bsr     ldiv            ;durch 10
                subq.l  #1,D2           ;eins abziehen
                move.w  #65534,D1       ;max.Zeilenummer
                cmp.l   D1,D2
                bls.s   mem_ver1
                move.w  D1,D2
mem_ver1:       move.w  D2,max_lines(A4)
                move.l  (SP)+,D0        ;Labeltabellengröße
                lsr.l   #5,D0           ;Länge durch 32
                move.w  #$3FFF,D1       ;max.Labelindex
                cmp.w   D1,D0
                bls.s   mem_ver2
                move.w  D1,D0
mem_ver2:       move.w  D0,max_index(A4)
                rts
                ENDPART
                >PART 'ass_get_path'
ass_path:       DC.B '\*.SRC',0
ass_path2:      DC.B '\*.PRG',0
ass_path3:      DC.B '\*.*',0
ass_path5:      DC.B '\TURBOASS.INF',0
                EVEN
ass_get_path:   move.b  #'A',(A0)
                add.b   D1,(A0)+        ;in Pfadnamen einsetzen
                move.b  #':',(A0)+
                clr.w   -(SP)
                pea     (A0)
                move.w  #$47,-(SP)
                bsr     do_trap_1
                addq.l  #8,SP
ass_get1:       tst.b   (A0)+
                bne.s   ass_get1
                subq.l  #1,A0
ass_get2:       move.b  (A1)+,(A0)+
                bne.s   ass_get2
                rts
                ENDPART
************************************************************************
* Fehlervektoren einsetzen (Init)                                      *
************************************************************************
                >PART 'set_spez_vek'
set_spez_vek:   IFEQ ^^SYMTAB
                lea     exc_tab(PC),A0
set_spez_vek1:  movea.w (A0)+,A1
                move.l  A1,D0
                beq.s   set_spez_vek3
                movea.l (A0)+,A2
                move.l  (A1),(A2)+      ;Vektor rettem
                move.l  A2,(A1)         ;neuen Vektoren einsetezn
                bra.s   set_spez_vek1
set_spez_vek3:  ENDC
                rts
reset_spez_vek: IFEQ ^^SYMTAB
                lea     exc_tab(PC),A0
reset_spez_vek1:movea.w (A0)+,A1
                move.l  A1,D0
                beq.s   reset_spez_vek3
                movea.l (A0)+,A2
                move.l  (A2),(A1)       ;Vektor zurück
                bra.s   reset_spez_vek1
reset_spez_vek3:ENDC
                rts

exc_tab:        DC.W $08
                DC.L exception2-4 ;Busfehler
                DC.W $0C
                DC.L exception3-4 ;Adreßfehler
                DC.W $10
                DC.L exception4-4 ;Illegaler Befehl
                DC.W $18
                DC.L exception6-4 ;Befehl CHK
                DC.W $1C
                DC.L exception7-4 ;Befehl TRAPV
                DC.W $20
                DC.L exception8-4 ;Privilegverletzung
                DC.W 0
                ENDPART
************************************************************************
* gibt Install-Alert aus                                               *
************************************************************************
                >PART 'install_alert'
install_alert:  movem.l D1-D4/A0,-(SP)
install_alert5: st      testwrd(A4)
                lea     install_2(PC),A0
                moveq   #6,D4
                move.l  memory_free(A4),D1 ;freier Speicher
                bsr     dezw_out
                lea     install_4(PC),A0
                move.l  memory_gem(A4),D1 ;freizuhaltene Bytes
                bsr     dezw_out
                lea     install_7(PC),A0
                move.l  max_code_len(A4),D1 ;Speicher für Zielcode
                bsr     dezw_out
                sf      testwrd(A4)
                lea     install_rsc(PC),A0
                jsr     _form_do
                tst.w   D0
                bpl.s   install_alert6
                moveq   #2,D0           ;ABBRUCH
install_alert6: subq.w  #2,D0
                beq.s   install_alert4  ;ABBRUCH
                lea     install_4(PC),A0
                moveq   #0,D1
                moveq   #7,D2
                jsr     s_get_zahl
                cmp.l   #40000,D1
                bhs.s   install_alert2
                move.l  #40000,D1
install_alert2: move.l  memory_free(A4),D4
                sub.l   #100000,D4
                cmp.l   D4,D1
                bhi.s   install_alert5
                cmp.l   memory_gem(A4),D1
                beq.s   install_alert22
                move.l  D1,memory_gem(A4)
                moveq   #-2,D0          ;alles reorganisieren
install_alert22:sub.l   D1,D4
                lea     install_7(PC),A0
                moveq   #0,D1
                moveq   #7,D2
                jsr     s_get_zahl
                cmp.l   #32768,D1
                bhs.s   install_alert3
                move.l  #32768,D1
install_alert3: cmp.l   D4,D1
                bhs     install_alert5
                move.l  D1,max_code_len(A4)
                tst.w   D0
                bmi.s   install_alert4
                moveq   #-1,D0          ;nur Zielcode reorganisieren
install_alert4: movem.l (SP)+,D1-D4/A0
                rts

install_rsc:    DC.W 0,0,33,11,1
                DC.W 7,1
                DC.L install_0
                DC.W 8
                DC.W 1,3
                DC.L install_1
                DC.W 8
                DC.W 19,3
                DC.L install_2
                DC.W 8
                DC.W 1,5
                DC.L install_3
                DC.W 8
                DC.W 19,5
                DC.L install_4
                DC.W $A8
                DC.W 27,5
                DC.L install_5
                DC.W 8
                DC.W 1,7
                DC.L install_6
                DC.W 8
                DC.W 19,7
                DC.L install_7
                DC.W $A8
                DC.W 27,7
                DC.L install_5
                DC.W 8
                DC.W 7,9
                DC.L ok_button
                DC.W $24
                DC.W 19,9
                DC.L abbruch_button
                DC.W $26
                DC.W -1
install_4:      DC.B '       ',0
install_7:      DC.B '       ',0
install_2:      DC.B '        Bytes',0
install_5:      DC.B 'Bytes',0
                SWITCH sprache
                CASE 0
install_0:      DC.B 'Speicherreservierung',0
install_1:      DC.B 'freier Speicher',0
install_3:      DC.B 'davon freihalten',0
install_6:      DC.B 'Zielcodespeicher',0
                CASE 1
install_0:      DC.B 'Memoryorganisation',0
install_1:      DC.B 'whole memory',0
install_3:      DC.B 'keep free',0
install_6:      DC.B 'Memory for code',0
                ENDS
                EVEN
                ENDPART
************************************************************************
* Springt in Zeile D6 und zentriert diese                              *
************************************************************************
                >PART 'jump_line'
jump_line:      cmp.w   anz_zeilen(A4),D6
                blo.s   jump_line1
                move.w  anz_zeilen(A4),D6
jump_line1:     lea     partbuffer-4(A4),A0
jump_line2:     addq.l  #4,A0
                tst.l   (A0)
                beq.s   jump_line3
                cmp.w   (A0),D6         ;mit Startzeile vergleichen
                bls.s   jump_line2      ;kleiner
                cmp.w   2(A0),D6        ;mit Endzeile vergleichen
                bhi.s   jump_line2      ;größer
                move.w  (A0),D6         ;wenn im Block->auf PART-Zeile
jump_line3:     move.w  D6,D0
                bsr     calc_pointerx   ;Zeiger auf ak. Zeile berechnen
                movem.l A3/A5-A6,top_ptr(A4) ;gleich top_line
                move.w  D6,top_line(A4)
                move.w  sdrv_zanz(A4),D0
                addq.w  #1,D0
                lsr.w   #1,D0           ;Zentrierung
                move.w  D0,scr_z(A4)    ;Screenzeile
                subq.w  #1,D0           ;wegen DBRA
                bsr     calc_anz_up     ;berechnet die Anzahl der Sourcezeilen
                cmp.w   D6,D1           ;bis in oberste Zeile?
                beq.s   jump_line4      ;dann nicht zentrieren
                move.w  D1,D0           ;Anzahl Sourcezeilen
                subq.w  #1,D0           ;wegen DBRA
                jsr     top_mi2         ;Zeiger der top_line neu setzen
                bra     redraw_all
jump_line4:     clr.w   top_line(A4)
                move.l  comment_base(A4),top_ptr(A4) ;auf Anfang
                move.l  z_info_base(A4),top_ptr+4(A4)
                move.l  program_base(A4),top_ptr+8(A4)
                bsr     redraw_all      ;Screen updaten
                lea     lin_tab2(A4),A0
                moveq   #-1,D0
jump_line5:     addq.w  #1,D0
                cmp.w   (A0)+,D6        ;Screenzeile suchen
                bne.s   jump_line5
                move.w  D0,scr_z(A4)
                rts
                ENDPART
************************************************************************
* berechnet die Zeiger auf die Zeile D0                                *
************************************************************************
                >PART 'calc_pointer'
calc_pointer:   moveq   #0,D1
                movem.l top_ptr(A4),A3/A5-A6 ;berechnet Zeiger der Zeile in D0
                sub.w   top_line(A4),D0 ;auf das Programm
                bhs.s   calc_loop2
                add.w   top_line(A4),D0
                movea.l z_info_base(A4),A5
                movea.l program_base(A4),A6
                movea.l comment_base(A4),A3
                bra.s   calc_loop2
calc_loop:      move.b  9(A5),D1
                adda.w  D1,A3
                adda.w  (A5),A6
                lea     10(A5),A5
calc_loop2:     dbra    D0,calc_loop
                IF slider
                bsr.s   draw_slider
                ENDC
                rts
calc_pointerx:  moveq   #0,D1
                movea.l z_info_base(A4),A5
                movea.l program_base(A4),A6
                movea.l comment_base(A4),A3
                bra.s   calc_loop2x
calc_loopx:     move.b  9(A5),D1
                adda.w  D1,A3
                adda.w  (A5),A6
                lea     10(A5),A5
calc_loop2x:    dbra    D0,calc_loopx
                rts
                ENDPART
                >PART 'draw_slider'
                IF slider
draw_slider:    movem.l D0-A6,-(SP)
                move.w  top_line(A4),D0
                cmp.w   save_top(A4),D0
                bne.s   calc_red
                move.w  anz_zeilen(A4),D1
                cmp.w   save_anz(A4),D1
                beq     calc_nred
calc_red:       movem.w D0-D1,save_top(A4)
                move.w  sdrv_max_x(A4),D0
                move.w  D0,D1           ;X2
                sub.w   #8*slsize-1,D0  ;X1
                moveq   #menu_offset,D2
                mulu    sdrv_cheight(A4),D2 ;Y1
                subq.w  #1,D2
                move.w  sdrv_max_y(A4),D4 ;Y2
                moveq   #0,D3           ;Füllmuster: schwarz
                jsr     DrawFrame
                moveq   #1,D5
                add.w   D4,D5
                sub.w   D2,D5           ;Sliderhöhe in Pixeln
                move.w  D5,D6
                mulu    sdrv_zanz(A4),D5 ;mal die Anzahl der Zeilen auf dem Screen
                divu    save_anz(A4),D5 ;durch die Gesamtanzahl der Zeilen
                cmp.w   sdrv_cheight(A4),D5
                bhs.s   calc_red1
                move.w  sdrv_cheight(A4),D5
calc_red1:      sub.w   D5,D6           ;Anzahl der Sliderpositionen
                mulu    save_top(A4),D6 ;mal oberste Zeile
                move.w  save_anz(A4),D7
                sub.w   sdrv_zanz(A4),D7
                divu    D7,D6           ;Sliderposition
                addq.w  #1,D0           ;X1+1
                addq.w  #1,D2           ;Y1+1
                subq.w  #1,D1           ;X2-1
                subq.w  #1,D4           ;Y2-1
                add.w   D6,D4           ;Sliderposition
                moveq   #3,D3           ;Füllmuster: hellgrau
                jsr     DrawRect
                move.w  D4,D2           ;Y1 = Y2
                add.w   D5,D4           ;Y2 = Y2 + Sliderhöhe
                moveq   #0,D3           ;Füllmuster: schwarz
                jsr     DrawFrame
                movem.w D0-D2/D4,-(SP)
                addq.w  #1,D0           ;X1+1
                addq.w  #1,D2           ;Y1+1
                subq.w  #1,D1           ;X2-1
                subq.w  #1,D4           ;Y2-1
                moveq   #1,D3           ;Füllmuster: weiß
                jsr     DrawRect
                movem.w (SP)+,D0-D2/D4
calc_nred:      movem.l (SP)+,D0-A6
                rts
                ENDC
                ENDPART
                >PART 'Disassembler'
************************************************************************
* Disassembler                                                         *           *
* ->A3,A5,A6: Zeiger auf Zeile                                         *
* ->4(sp): Zeiger auf Buffer                                           *
************************************************************************
hunt3:          addq.l  #1,A0
                rts
disass:         movea.l 4(SP),A0
                moveq   #15,D0
                move.l  #'    ',D1
disass_loop:    move.l  D1,(A0)+        ;256 Spaces
                move.l  D1,(A0)+
                move.l  D1,(A0)+
                move.l  D1,(A0)+
                dbra    D0,disass_loop
                movea.l label_base(A4),A2
                movea.l 4(SP),A0
                moveq   #0,D0
                tst.w   (A5)
                bmi.s   hunt3
                move.w  6(A5),D0
                bmi.s   hunt1
;Label wurde in dieser Zeile definiert
                lsl.l   #5,D0
                move.b  4(A2,D0.l),D1
                lea     8(A2,D0.l),A2
                moveq   #1,D0           ;1.Zeichen auch mitzählen!
                move.b  (A2)+,(A0)+     ;erstes Zeichen
                bne.s   hunt2           ;kein lokales Label
                move.b  local_char(A4),-1(A0) ;Zeichen einsetzen
hunt2:          move.b  (A2)+,(A0)+     ;Label einsetzen
                beq.s   hunte
                addq.w  #1,D0
                bra.s   hunt2
hunte:          cmpi.b  #2,2(A5)        ;kein Pseudo-Opcode?
                ble.s   hunte0          ;Genau! =>
                cmpi.b  #$0E,2(A5)      ;EQU?
                beq.s   hunte00         ;Ja! =>
                cmpi.b  #$1C,2(A5)      ;REG
                beq.s   hunte00         ;Ja! =>
                cmpi.b  #$3A,2(A5)      ;SET
                beq.s   hunte00         ;Ja! =>
                cmpi.b  #$58,2(A5)      ;==
                bne.s   hunte0          ;Nein! =>
hunte00:        move.b  #' ',-1(A0)     ;nur ein Space dran (kein Doppelpkt)
                bra.s   hunte1          ;und weiter =>
hunte0:         move.b  #':',-1(A0)
                btst    #5,D1
                beq.s   hunte1
                move.b  #':',(A0)+      ;globales Symbol
                addq.w  #1,D0
hunte1:         cmpi.b  #2,2(A5)
                bge.s   special_opsx
                cmp.w   tabs(A4),D0
                bge.s   hunt11
                movea.l 4(SP),A0        ;Bufferanfang
hunt1:          cmpi.b  #2,2(A5)
                bge.s   special_opsx2
                adda.w  tabs(A4),A0     ;Befehlstab
                tst.w   tabs(A4)
                bne.s   hunt11
                addq.w  #1,A0
hunt11:         tst.l   (A5)
                beq.s   hunt4
                lea     distab_tab(PC),A1
                move.b  (A6),D1
                lsr.b   #3,D1
                moveq   #30,D0
                and.w   D1,D0
                adda.w  0(A1,D0.w),A1
                bra     dis0
special_opsx:   cmp.w   tabs+6(A4),D0
                bge     special_ops
                movea.l 4(SP),A0        ;Bufferanfang
special_opsx2:  adda.w  tabs+6(A4),A0   ;Pseudoptab
                tst.w   tabs+6(A4)
                bne     special_ops
                addq.l  #1,A0
                bra     special_ops
hunt4:          tst.w   D0
                bpl.s   hunt41
                movea.l 4(SP),A0
hunt41:         lea     tabs+4(A4),A2
                tst.b   9(A5)
                bne     rem_out
                addq.w  #1,A0
                rts

                BASE DC.W,distab_tab
distab_tab:     DC.W distab0
                DC.W distab1
                DC.W distab2
                DC.W distab3
                DC.W distab4
                DC.W distab5
                DC.W distab6
                DC.W distab7
                DC.W distab8
                DC.W distab9
                DC.W distabA
                DC.W distabB
                DC.W distabC
                DC.W distabD
                DC.W distabE
                DC.W distabE

spez_n:         DC.B 'DC.',0
spez_n1:        DC.B 'DS.',0
spez_n2:        DC.B 'TEXT',0
spez_n3:        DC.B 'DATA',0
spez_n4:        DC.B 'BSS',0
spez_n5:        DC.B 'EVEN',0
spez_n6:        DC.B 'EQU ',0
spez_n7:        DC.B 'OPT ',0
spez_n8:        DC.B 'END',0
spez_n9:        DC.B 'RSRESET',0
spez_na:        DC.B 'RSBSS',0
spez_nb:        DC.B 'RS.',0
spez_nc:        DC.B 'RSSET ',0
spez_nd:        DC.B 'REG ',0
spez_ne:        DC.B 'IBYTES ',0
spez_nf:        DC.B 'BASE ',0
spez_ng:        DC.B 'PATH ',0
spez_nh:        DC.B 'CNOP ',0
spez_ni:        DC.B 'OUTPUT ',0
spez_nj:        DC.B 'IF',0
spez_nk:        DC.B 'ELSE',0
spez_nl:        DC.B 'ENDC',0
spez_nm:        DC.B 'RSEVEN',0
spez_nn:        DC.B 'DX.B ',0
spez_no:        DC.B 'DXSET ',0
spez_np:        DC.B 'DCB.',0
spez_nq:        DC.B 'FAIL ',0
spez_nr:        DC.B 'ORG ',0
spez_ns:        DC.B 'SET',0
spez_nt:        DC.B 'REPT ',0
spez_nu:        DC.B 'ENDR',0
spez_nv:        DC.B 'SWITCH',0
spez_nw:        DC.B 'CASE ',0
spez_nx:        DC.B 'ENDS',0
spez_ny:        DC.B 'GLOBAL ',0
spez_nz:        DC.B 'COMMON',0
spez_n11:       DC.B 'DEFAULT ',0
spez_n12:       DC.B 0
spez_n13:       DC.B 0
spez_n14:       DC.B 0
spez_n15:       DC.B 0
spez_n16:       DC.B 'ENDPART',0
spez_n17:       DC.B 'ISYMBOL ',0
spez_n18:       DC.B '== ',0
spez_n19:       DC.B 'BREAKPT ',0
                EVEN

special_ops6:   add.w   D0,D0
                move.w  spez_tab+2(PC,D0.w),D1
                lea     spez_tab(PC,D1.w),A1
special_ops2:   move.b  (A1)+,D1
                beq.s   special_ops4
                cmp.b   #'A',D1
                blo.s   special_ops3
                cmp.b   #'Z',D1
                bhi.s   special_ops3
                add.b   pcodesize_flag(A4),D1
special_ops3:   move.b  D1,(A0)+
                bra.s   special_ops2
special_ops4:   rts

special_ops:    moveq   #0,D0
                move.b  2(A5),D0
                bsr.s   special_ops6
                movea.l label_base(A4),A2
                moveq   #0,D4
                move.w  spez_tab(PC,D0.w),D0
                jsr     spez_tab(PC,D0.w)
                lea     tabs+8(A4),A2   ;Zeiger auf Tabulator
                tst.b   9(A5)
                bne     rem_out
                addq.l  #1,A0
                rts

                BASE DC.W,spez_tab
spez_tab:       DC.W 0,0        ;Dummy
                DC.W d_dc,spez_n ;DC
                DC.W d_ds,spez_n1 ;DS
                DC.W d_return,spez_n2 ;TEXT
                DC.W d_return,spez_n3 ;DATA
                DC.W d_return,spez_n4 ;BSS
                DC.W d_return,spez_n5 ;EVEN
                DC.W d_equ,spez_n6 ;EQU
                DC.W d_opt,spez_n7 ;OPT
                DC.W d_return,spez_n8 ;END
                DC.W d_return,spez_n9 ;RSRESET
                DC.W d_return,spez_na ;RSBSS
                DC.W d_rs,spez_nb ;RS
                DC.W d_rsset,spez_nc ;RSSET
                DC.W d_reg,spez_nd ;REG
                DC.W d_ibytes,spez_ne ;IBYTES
                DC.W d_base,spez_nf ;BASE
                DC.W d_path,spez_ng ;PATH
                DC.W d_cnop,spez_nh ;CNOP
                DC.W d_outp,spez_ni ;OUTPUT
                DC.W d_if,spez_nj ;IFxx
                DC.W d_return,spez_nk ;ELSE
                DC.W d_return,spez_nl ;ENDC
                DC.W d_return,spez_nm ;RSEVEN
                DC.W d_dx,spez_nn ;DX.B
                DC.W d_dxset,spez_no ;DXSET
                DC.W d_ds,spez_np ;DCB
                DC.W d_fail,spez_nq ;FAIL
                DC.W d_org,spez_nr ;ORG
                DC.W d_if1,spez_ns ;SET
                DC.W d_rept,spez_nt ;REPT
                DC.W d_return,spez_nu ;ENDR
                DC.W d_if1,spez_nv ;SWITCH
                DC.W d_case,spez_nw ;CASE
                DC.W d_return,spez_nx ;ENDS
                DC.W d_global,spez_ny ;GLOBAL
                DC.W d_if1,spez_nz ;COMMON
                DC.W d_case,spez_n11 ;DEFAULT
                DC.W d_return,spez_n12 ;MACRO
                DC.W d_return,spez_n13 ;ENDM
                DC.W d_return,spez_n14 ;Macroaufruf
                DC.W d_part,spez_n15 ;PART
                DC.W d_return,spez_n16 ;ENDPART
                DC.W d_path,spez_n17 ;ISYMBOL
                DC.W d_equ,spez_n18 ;==
                DC.W d_breakp,spez_n19 ;BREAKPT

d_dc:           lea     _breite(PC),A1
                moveq   #0,D0
                move.b  3(A5),D0
                move.b  0(A1,D0.w),D0
                add.b   pcodesize_flag(A4),D0
                move.b  D0,(A0)+
                move.b  #' ',(A0)+
                move.w  #250,D0
                sub.w   tabs(A4),D0
                move.w  D0,buff_rest(A4)
                moveq   #0,D0
                move.w  4(A5),D0
                andi.w  #$3FFF,D0
                lsl.l   #5,D0
                movea.l A5,A1
                move.b  3(A5),D1
                lea     -2(A2,D0.l),A5
                moveq   #0,D4
                moveq   #$FF,D6
                cmp.b   #2,D1
                beq     d_dcl
                cmp.b   #1,D1
                beq     d_dcw
                moveq   #0,D6
                move.w  #$FF,D6
d_dcb:          move.w  2(A5,D4.w),D1
                bpl.s   d_dcb1
                btst    #14,D1          ;Vorzeichen
                beq.s   d_dcb6
                move.b  #'-',(A0)+
d_dcb6:         tst.w   buff_rest(A4)
                bmi.s   d_dc2
                addq.w  #1,A6
                andi.w  #$3FFF,D1
                bsr     labelout2
                move.w  #$FF,D6         ;Maske wieder neu setzen
d_dcb2:         move.w  4(A5,D4.w),D0
                bmi.s   d_dcb8          ;Symbol
                cmp.b   #$FF,D0         ;Fortsetzungskennung
                beq.s   d_dcb7
                cmp.w   #$FE,D0
                beq.s   d_dc2
d_dcb8:         addq.w  #2,D4
                move.b  #',',(A0)+
                bra.s   d_dcb
d_dc2:          movea.l A1,A5
                rts
d_dcb1:         move.w  D1,D0
                lsr.w   #4,D1
                andi.w  #%1111111,D1
                andi.w  #7,D0
                cmp.w   #7,D0           ;'String'
                beq.s   d_dcb3
                cmp.w   #6,D0
                beq.s   d_dcb3          ;"String"
                move.w  D1,D0
d_dcb5:         tst.w   buff_rest(A4)
                bmi.s   d_dc2
                move.b  (A6)+,D1
                bsr     numout1
                move.b  #',',(A0)+
                dbra    D0,d_dcb5
                move.b  #' ',-(A0)
                bra.s   d_dcb2
d_dcb3:         andi.w  #1,D0
                sne     D0
                andi.w  #7,D0
                ori.w   #$22,D0
                move.b  D0,(A0)+
d_dcb4:         move.b  (A6)+,(A0)+
                cmp.b   -1(A0),D0       ;Endekennung im String ?
                bne.s   d_dcb41         ;nein
                move.b  D0,(A0)+        ;sonst doppelt ausgeben
d_dcb41:        subq.w  #1,buff_rest(A4)
                dbeq    D1,d_dcb4
                beq.s   d_dc2           ;Buffer voll
                move.b  D0,(A0)+
                bra.s   d_dcb2
d_dcb7:         moveq   #0,D0
                move.w  4(A5,D4.w),D0   ;High-Byte holen
                move.b  6(A5,D4.w),D0   ;Low-Byte
                lsl.l   #5,D0
                lea     -2(A2,D0.l),A5  ;Zeiger auf neuen Eintrag
                moveq   #0,D4
                move.b  #',',(A0)+
                bra     d_dcb
d_dcw:          move.l  #$FFFF,D6
d_dcw0:         move.w  2(A5,D4.w),D1
                bpl.s   d_dcw1
                btst    #14,D1          ;Vorzeichen
                beq.s   d_dcw4
                move.b  #'-',(A0)+
d_dcw4:         tst.w   buff_rest(A4)
                bmi     d_dc2
                addq.w  #2,A6
                andi.w  #$3FFF,D1
                bsr     labelout2
d_dcw2:         move.w  4(A5,D4.w),D0
                bmi.s   d_dcw8
                cmp.b   #$FF,D0         ;Fortsetzungskennung
                beq.s   d_dcw5
                cmp.w   #$FE,D0         ;Endekennung
                beq     d_dc2
d_dcw8:         addq.w  #2,D4
                move.b  #',',(A0)+
                bra.s   d_dcw0
d_dcw1:         lsr.w   #4,D1
                andi.w  #%1111111,D1
                move.w  D1,D0
d_dcw3:         tst.w   buff_rest(A4)
                bmi     d_dc2
                move.w  (A6)+,D1
                bsr     numout1
                move.b  #',',(A0)+
                dbra    D0,d_dcw3
                move.b  #' ',-(A0)
                bra.s   d_dcw2
d_dcw5:         moveq   #0,D0
                move.w  4(A5,D4.w),D0   ;High-Byte holen
                move.b  6(A5,D4.w),D0   ;Low-Byte
                lsl.l   #5,D0
                lea     -2(A2,D0.l),A5  ;Zeiger auf neuen Eintrag
                moveq   #0,D4
                move.b  #',',(A0)+
                bra.s   d_dcw0
d_dcl:          move.l  #-1,D6
d_dcl0:         move.w  2(A5,D4.w),D1
                bpl.s   d_dcl1
                btst    #14,D1          ;Vorzeichen
                beq.s   d_dcl4
                move.b  #'-',(A0)+
d_dcl4:         tst.w   buff_rest(A4)
                bmi     d_dc2
                addq.w  #4,A6
                andi.w  #$3FFF,D1
                bsr     labelout2
d_dcl2:         move.w  4(A5,D4.w),D0
                bmi.s   d_dcl8
                cmp.b   #$FF,D0         ;Fortsetzungskennung
                beq.s   d_dcl5
                cmp.w   #$FE,D0
                beq     d_dc2
d_dcl8:         addq.w  #2,D4
                move.b  #',',(A0)+
                bra.s   d_dcl0
d_dcl1:         lsr.w   #4,D1
                andi.w  #%1111111,D1
                move.w  D1,D0
d_dcl3:         tst.w   buff_rest(A4)
                bmi     d_dc2
                move.l  (A6)+,D1
                bsr     numout1
                move.b  #',',(A0)+
                dbra    D0,d_dcl3
                move.b  #' ',-(A0)
                bra.s   d_dcl2
d_dcl5:         moveq   #0,D0
                move.w  4(A5,D4.w),D0   ;High-Byte holen
                move.b  6(A5,D4.w),D0   ;Low-Byte
                lsl.l   #5,D0
                lea     -2(A2,D0.l),A5  ;Zeiger auf neuen Eintrag
                moveq   #0,D4
                move.b  #',',(A0)+
                bra.s   d_dcl0

d_ds:           lea     _breite(PC),A1
                move.b  3(A5),D0
                rol.b   #2,D0
                andi.w  #3,D0
                move.b  0(A1,D0.w),D0
                add.b   pcodesize_flag(A4),D0
                move.b  D0,(A0)+
                move.b  #' ',(A0)+
                moveq   #0,D1
                move.w  4(A5),D1
                move.l  #$FFFF,D6
                move.w  2(A5),D0        ;Flags für Anzahl
                lsr.w   #4,D0
                andi.w  #3,D0
                cmp.w   #3,D0           ;Konstante/Formel
                beq.s   d_ds4           ;ja !
                pea     d_ds3(PC)
                movem.l D0-D4/A6,-(SP)
                moveq   #0,D2
                bra     basoutx         ;Anzahl ausgeben
d_ds4:          bsr     labelout2
d_ds3:          move.l  (A6),D1
                beq.s   d_ds2
                move.b  #',',(A0)+
                moveq   #-1,D6
                move.w  2(A5),D0        ;Flags für Füllwert
                andi.w  #15,D0
                movem.l D0-D4/A6,-(SP)
                moveq   #0,D2
                bra     basoutx         ;Füllwert ausgeben
d_ds2:          rts
d_rs:           lea     _breite(PC),A1
                moveq   #0,D0
                move.b  3(A5),D0
                lsr.w   #4,D0           ;Bits für Breite
                move.b  0(A1,D0.w),D0
                add.b   pcodesize_flag(A4),D0
                move.b  D0,(A0)+
                move.b  #' ',(A0)+
                move.w  2(A5),D0
                andi.w  #5,D0           ;Symbolflag und Darstellungsflag
                cmp.w   #5,D0           ;Symbol ?
                beq.s   d_rs2           ;ja
d_rs3:          moveq   #0,D1
                move.w  4(A5),D1
                move.l  #$FFFF,D6
                moveq   #0,D2
                movem.l D0-D4/A6,-(SP)
                bra     basoutx         ;Anzahl ausgeben
d_rs2:          moveq   #0,D1
                move.w  4(A5),D1
                bra     labelout2
d_rept:         moveq   #0,D0
                move.w  2(A5),D0
                andi.w  #5,D0           ;Symbolflag und Darstellungsflag
                cmp.w   #5,D0           ;Symbol ?
                beq.s   d_rs2           ;ja
                bra.s   d_rs3
d_return:       rts
d_rsset:        move.l  2(A5),D1        ;Wert holen
                andi.l  #$0FFFFF,D1
                move.w  2(A5),D0
                btst    #6,D0           ;Symbol ?
                bne.s   d_rsset2
                lsr.w   #4,D0
                andi.w  #15,D0
                moveq   #0,D2
                moveq   #$FF,D6
                btst    #19,D1          ;Wert negativ ?
                beq.s   d_rsset1        ;nein
                or.l    #$FFF00000,D1   ;oberen Bits setzen
d_rsset1:       movem.l D0-D4/A6,-(SP)
                bra     basoutx         ;Wert ausgeben
d_rsset2:       tst.b   D0              ;Vorzeichen testen
                bpl     labelout2       ;plus
                move.b  #'-',(A0)+      ;minus
                bra     labelout2

d_equ:          moveq   #2,D4
                tst.w   4(A5)
                bmi     labqui3
                moveq   #0,D1
                move.w  6(A5),D1
                lsl.l   #5,D1
                move.l  0(A2,D1.l),D1
                moveq   #$FF,D6
                bra     numout
d_opt:          move.w  4(A5),D0
                moveq   #-1,D1
                bra.s   d_opt6
d_opt2:         lsr.w   #1,D0
d_opt6:         addq.w  #1,D1
                cmp.w   #7,D1
                beq.s   d_opt5
                lsr.w   #1,D0
                bcc.s   d_opt2
                move.b  d_opt4(PC,D1.w),(A0)+
                move.b  #'+',(A0)+
                lsr.w   #1,D0
                bcc.s   d_opt3
                move.b  #'-',-1(A0)
d_opt3:         move.b  #',',(A0)+
                bra.s   d_opt6
d_opt5:         move.b  #' ',-(A0)
                rts
d_opt4:         DC.B 'XDLFPOW'
                EVEN

d_org:          moveq   #2,D4
                move.l  (A6),D1
                moveq   #$FF,D6
                bsr     numout
                tst.b   3(A5)
                beq.s   d_org2
                move.b  #',',(A0)+
                move.b  #'^',(A0)+
d_org2:         rts
d_reg:          moveq   #0,D1
                move.w  6(A5),D1
                lsl.l   #5,D1
                move.l  0(A2,D1.l),D1   ;Registermaske holen
                bsr     _d1turn
                bra     mskout          ;und ausgeben
d_ibytes:       moveq   #12,D0
                bsr     d_text_out
                lea     0(A2,D1.l),A2   ;Zeiger auf Eintrag
                move.l  (A2),D1
                beq.s   d_ibytes2
                move.b  #',',(A0)+
                moveq   #$FF,D6
                pea     d_ibytes4(PC)
                moveq   #0,D0
                move.w  2(A5),D0
                lsr.w   #4,D0
                and.w   #3,D0           ;Flags für Anzahl
                movem.l D0-D4/A6,-(SP)
                moveq   #0,D2
                bra     basoutx         ;Anzahl ausgeben
d_ibytes4:      move.l  4(A2),D1
                beq     return
d_ibytes3:      move.b  #',',(A0)+
                move.w  2(A5),D0
                and.w   #3,D0           ;Flags für Position
                moveq   #$FF,D6
                movem.l D0-D4/A6,-(SP)
                moveq   #0,D2
                bra     basoutx         ;Position ausgeben
d_ibytes2:      move.l  4(A2),D1
                beq     return
                move.b  #',',(A0)+
                bra.s   d_ibytes3

d_base:         moveq   #0,D0
                move.b  3(A5),D0
                cmp.w   #7,D0
                bls.s   d_base2
                move.b  pcodesize_flag(A4),D1
                move.b  #'D',(A0)
                add.b   D1,(A0)+
                move.b  #'C',(A0)
                add.b   D1,(A0)+
                move.b  #'.',(A0)+
                move.b  #'W',(A0)
                add.b   D1,(A0)+
                btst    #0,D0
                beq.s   d_base3
                move.b  #'B',-1(A0)
                add.b   D1,-1(A0)
d_base3:        move.b  #',',(A0)+
                moveq   #0,D1
                move.w  4(A5),D1
                bpl     labelout2
                move.w  D1,D0
                andi.w  #$FF,D0
                beq.s   d_base4         ;PC
                cmp.w   #2,D0
                beq.s   d_base41        ;OFF
                bra     special_ops6    ;TEXT,DATA,BSS
d_base4:        move.b  #'*',(A0)+
                rts
d_base41:       move.b  #'O',(A0)+
                move.b  #'F',(A0)+
                move.b  #'F',(A0)+
                rts
d_base2:        move.b  #'A',(A0)+
                addi.b  #'0',D0
                move.b  D0,(A0)+
                bra.s   d_base3
d_if:           moveq   #0,D0
                move.b  3(A5),D0
                beq.s   d_if1
                move.b  pcodesize_flag(A4),D1
                move.b  d_if3-2(PC,D0.w),(A0)
                add.b   D1,(A0)+
                move.b  d_if3-1(PC,D0.w),(A0)
                add.b   D1,(A0)+
d_if1:          addq.l  #1,A0
                move.w  4(A5),D1
                andi.w  #$3FFF,D1
                bra     labelout2
d_if3:          DC.B 'EQNEGTGELTLED ND'
                EVEN
d_path:         moveq   #0,D0
                bsr     d_text_out
                rts
d_fail:         moveq   #0,D0
                tst.w   4(A5)
                bpl     d_text_out
                rts
d_cnop:         moveq   #0,D1
                move.w  4(A5),D1
                move.w  #$FFFF,D6
                pea     d_cnop2(PC)
                moveq   #0,D0
                movem.l D0-D4/A6,-(SP)
                moveq   #0,D2
                bra     basoutx         ;Offset ausgeben
d_cnop2:        move.b  #',',(A0)+
                moveq   #0,D1
                move.b  3(A5),D1
                move.w  #$FF,D6
                movem.l D0-D4/A6,-(SP)
                bra     basoutx
d_dxset:        move.w  2(A5),D0
                lsr.w   #4,D0
                andi.w  #3,D0
                moveq   #0,D1
                move.b  4(A5),D1        ;Anzahl
                move.w  #$FF,D6
                moveq   #0,D2
                pea     d_dxse1(PC)
                movem.l D0-D4/A6,-(SP)
                bra     basoutx
d_dxse1:        move.b  #',',(A0)+
                move.b  5(A5),D1
                move.w  2(A5),D0
                andi.w  #15,D0
                movem.l D0-D4/A6,-(SP)
                bra     basoutx
d_case:         tst.b   3(A5)           ;folgt Wert ?
                bmi.s   d_case2         ;nein
                move.w  4(A5),D1        ;Wert holen
                moveq   #0,D6
                move.w  #$FFFF,D6
                bra     numout1
d_case2:        rts
d_global:       moveq   #0,D1
                move.w  4(A5),D1
                lsl.l   #5,D1
                lea     0(A2,D1.l),A1   ;Zeiger auf Eintrag
                moveq   #0,D1
d_global2:      move.w  (A1)+,D1
                bmi.s   d_global3
                bsr     labelout2       ;Label ausgeben
                move.b  #',',(A0)+
                bra.s   d_global2
d_global3:      move.b  #' ',-(A0)      ;letztes Komma löschen
                rts
d_breakp:       tst.w   (A5)            ;folgt Text?
                beq.s   d_outp2         ;nein
                bra.s   d_breakp1       ;Text ausgeben
d_dx:           moveq   #0,D0
                bra.s   d_text_out
d_outp:         moveq   #0,D0
                bsr.s   d_text_out      ;Filename ausgeben
                tst.w   (A5)            ;folgt Commandline?
                beq.s   d_outp2         ;nein
                move.b  #',',(A0)+
d_breakp1:      move.b  #$27,(A0)+
                movea.l A6,A1           ;Zeiger auf Commandline
                bra.s   d_text_out2     ;ausgeben
d_outp2:        rts
d_text_out:     move.b  #$27,(A0)+
                moveq   #0,D1
                move.w  4(A5),D1
                lsl.l   #5,D1
                lea     0(A2,D1.l),A1
                adda.w  D0,A1
d_text_out2:    move.b  (A1)+,(A0)+
                bne.s   d_text_out2
                move.b  #$27,-1(A0)
                rts
d_part:         cmpi.w  #$52F0,2(A5)
                beq.s   d_part1         ;geschützter PART
                tst.b   3(A5)
                beq.s   d_part2         ;PART ausgeklappt
                move.b  #'>',(A0)+
d_part2:        lea     d_part4(PC),A1  ;Zeiger auf Text
d_part3:        move.b  (A1)+,(A0)+
                bne.s   d_part3
                move.b  #' ',-(A0)
                bra     d_fail
d_part1:        lea     d_part5(PC),A1
                bra.s   d_part3
d_part4:        DC.B 'PART ',0
d_part5:        DC.B 'LIBRARY ',0
                EVEN

* -------------------- Gruppe 0
                BASE DC.W,distab
distab:
distab0:        DC.W _andi,$023C,$161A
                DC.W _ori,$3C,$161A
                DC.W _eori,$0A3C,$161A
                DC.W _andi,$027C,$1719
                DC.W _ori,$7C,$1719
                DC.W _eori,$0A7C,$1719
                DC.W _btst,$0800,$1202
                DC.W _bclr,$0880,$0F02
                DC.W _bset,$08C0,$0F02
                DC.W _bchg,$0840,$0F02
                DC.W _addi,$0600,$8F1B
                DC.W _andi,$0200,$8F1B
                DC.W _cmpi,$0C00,$8F1B
                DC.W _eori,$0A00,$8F1B
                DC.W _ori,0,$8F1B
                DC.W _subi,$0400,$8F1B
                DC.W _movep_w,$0108,$0B1C
                DC.W _movep_l,$0148,$0B1C
                DC.W _movep_w,$0188,$1C0B
                DC.W _movep_l,$01C8,$1C0B
                DC.W _btst,$0100,$100B
                DC.W _bclr,$0180,$0F0B
                DC.W _bset,$01C0,$0F0B
                DC.W _bchg,$0140,$0F0B
* -------------------- Gruppe 1
distab1:        DC.W _move_b,$1000,$0C4D
* -------------------- Gruppe 2
distab2:        DC.W _movea_l,$2040,$4A4D
                DC.W _move_l,$2000,$4C4D
* -------------------- Gruppe 3
distab3:        DC.W _movea_w,$3040,$4A0D
                DC.W _move_w,$3000,$4C0D
* -------------------- Gruppe 4
distab4:        DC.W _bkpt,$4848,$1F
                DC.W _illegal,$4AFC,0
                DC.W _nop,$4E71,0
                DC.W _reset,$4E70,0
                DC.W _rte,$4E73,0
                DC.W _rtr,$4E77,0
                DC.W _rts,$4E75,0
                DC.W _trapv,$4E76,0
                DC.W _stop,$4E72,$19
                DC.W _ext_w,$4880,9
                DC.W _ext_l,$48C0,9
                DC.W _link,$4E50,$1908
                DC.W _move,$4E60,$1808
                DC.W _move,$4E68,$0818
                DC.W _swap,$4840,9
                DC.W _trap,$4E40,3
                DC.W _unlk,$4E58,8
                DC.W _chk,$4180,$4B10
                DC.W _move,$44C0,$1650
                DC.W _move,$46C0,$5710
                DC.W _jmp,$4EC0,$13
                DC.W _move,$40C0,$0F17
                DC.W _jsr,$4E80,$13
                DC.W _nbcd,$4800,$0F
                DC.W _pea,$4840,$13
                DC.W _lea,$41C0,$0A13
                DC.W _clr,$4200,$800F
                DC.W _neg,$4400,$800F
                DC.W _negx,$4000,$800F
                DC.W _not,$4600,$800F
                DC.W _tas,$4AC0,$0F
                DC.W _tst,$4A00,$800F
* -------------------- Gruppe 5
distab5:        DC.W _db,$50C8,$1E89
                DC.W _s,$50C0,$8F
                DC.W _addq,$5000,$8E04
                DC.W _subq,$5100,$8E04
* -------------------- Gruppe 6
distab6:        DC.W _bra,$6000,7
                DC.W _bsr,$6100,7
                DC.W _b,$6000,$87
* -------------------- Gruppe 7
distab7:        DC.W _moveq_l,$7000,$0B01
* -------------------- Guppe 8
distab8:        DC.W _divu,$80C0,$4B10
                DC.W _divs,$81C0,$4B10
                DC.W _sbcd,$8100,$0B09
                DC.W _sbcd,$8108,$1405
                DC.W _or,$8000,$8B10
                DC.W _or,$8100,$8E0B
* -------------------- Gruppe 9
distab9:        DC.W _suba_w,$90C0,$4A0D
                DC.W _suba_l,$91C0,$4A4D
                DC.W _subx,$9100,$8B09
                DC.W _subx,$9108,$9405
                DC.W _sub,$9000,$8B0D
                DC.W _sub,$9100,$8E0B
* -------------------- Gruppe a
distabA:        DC.W _linea,$A000,$20
* -------------------- Gruppe b
distabB:        DC.W _cmpa_w,$B0C0,$4A0D
                DC.W _cmpa_l,$B1C0,$4A4D
                DC.W _cmp,$B000,$8B0D
                DC.W _cmpm,$B108,$9506
                DC.W _eor,$B100,$8F0B
* -------------------- Gruppe c
distabC:        DC.W _mulu,$C0C0,$4B10
                DC.W _muls,$C1C0,$4B10
                DC.W _abcd,$C100,$0B09
                DC.W _abcd,$C108,$1405
                DC.W _exg,$C140,$090B
                DC.W _exg,$C148,$080A
                DC.W _exg,$C188,$0B08
                DC.W _and,$C000,$8B10
                DC.W _and,$C100,$8E0B
* -------------------- Gruppe d
distabD:        DC.W _adda_w,$D0C0,$4A0D
                DC.W _adda_l,$D1C0,$4A4D
                DC.W _addx,$D100,$8B09
                DC.W _addx,$D108,$9405
                DC.W _add,$D000,$8B0D
                DC.W _add,$D100,$8E0B
* -------------------- Gruppe e
distabE:        DC.W _asl_w,$E1C0,$11
                DC.W _asr_w,$E0C0,$11
                DC.W _asl,$E100,$8904
                DC.W _asr,$E000,$8904
                DC.W _asl,$E120,$890B
                DC.W _asr,$E020,$890B
                DC.W _lsl_w,$E3C0,$11
                DC.W _lsr_w,$E2C0,$11
                DC.W _lsl,$E108,$8904
                DC.W _lsr,$E008,$8904
                DC.W _lsl,$E128,$890B
                DC.W _lsr,$E028,$890B
                DC.W _rol_w,$E7C0,$11
                DC.W _ror_w,$E6C0,$11
                DC.W _rol,$E118,$8904
                DC.W _ror,$E018,$8904
                DC.W _rol,$E138,$890B
                DC.W _ror,$E038,$890B
                DC.W _roxl_w,$E5C0,$11
                DC.W _roxr_w,$E4C0,$11
                DC.W _roxl,$E110,$8904
                DC.W _roxr,$E010,$8904
                DC.W _roxl,$E130,$890B
                DC.W _roxr,$E030,$890B
disend:

_roxl_w:        DC.B "ROXL.W",0
_roxr_w:        DC.B "ROXR.W",0
_ror_w:         DC.B "ROR.W",0
_rol_w:         DC.B "ROL.W",0
_lsl_w:         DC.B "LSL.W",0
_lsr_w:         DC.B "LSR.W",0
_asl_w:         DC.B "ASL.W",0
_asr_w:         DC.B "ASR.W",0
_adda_l:        DC.B "ADDA.L",0
_adda_w:        DC.B "ADDA.W",0
_cmpa_w:        DC.B "CMPA.W",0
_cmpa_l:        DC.B "CMPA.L",0
_suba_w:        DC.B "SUBA.W",0
_suba_l:        DC.B "SUBA.L",0
_linea:         DC.B -1,"LINEA",0
_moveq_l:       DC.B "MOVEQ",0
_ext_w:         DC.B "EXT.W",0
_ext_l:         DC.B "EXT.L",0
_move_b:        DC.B "MOVE.B",0
_move_w:        DC.B "MOVE.W",0
_move_l:        DC.B "MOVE.L",0
_movea_w:       DC.B "MOVEA.W",0
_movea_l:       DC.B "MOVEA.L",0
_movep_w:       DC.B "MOVEP.W",0
_movep_l:       DC.B "MOVEP.L",0
_illegal:       DC.B "ILLEGAL",0
_db:            DC.B "DB",0
_s:             DC.B "S",0
_b:             DC.B "B",0

_add:           DC.B "ADD",0
_and:           DC.B "AND",0
_asl:           DC.B "ASL",0
_asr:           DC.B "ASR",0
_addq:          DC.B "ADDQ",0
_addx:          DC.B "ADDX",0
_abcd:          DC.B "ABCD",0
_addi:          DC.B "ADDI",0
_andi:          DC.B "ANDI",0
_bsr:           DC.B "BSR",0
_bra:           DC.B "BRA",0
_btst:          DC.B "BTST",0
_bclr:          DC.B "BCLR",0
_bset:          DC.B "BSET",0
_bchg:          DC.B "BCHG",0
_cmp:           DC.B "CMP",0
_clr:           DC.B "CLR",0
_cmpm:          DC.B "CMPM",0
_cmpi:          DC.B "CMPI",0
_chk:           DC.B "CHK",0
_divu:          DC.B "DIVU",0
_divs:          DC.B "DIVS",0
_eor:           DC.B "EOR",0
_exg:           DC.B "EXG",0
_eori:          DC.B "EORI",0
_jmp:           DC.B "JMP",0
_jsr:           DC.B "JSR",0
_lea:           DC.B "LEA",0
_lsr:           DC.B "LSR",0
_lsl:           DC.B "LSL",0
_link:          DC.B "LINK",0
_move:          DC.B "MOVE",0
_mulu:          DC.B "MULU",0
_muls:          DC.B "MULS",0
_nop:           DC.B "NOP",0
_neg:           DC.B "NEG",0
_not:           DC.B "NOT",0
_negx:          DC.B "NEGX",0
_nbcd:          DC.B "NBCD",0
_or:            DC.B "OR",0
_ori:           DC.B "ORI",0
_pea:           DC.B "PEA",0
_rts:           DC.B "RTS",0
_rol:           DC.B "ROL",0
_ror:           DC.B "ROR",0
_roxl:          DC.B "ROXL",0
_roxr:          DC.B "ROXR",0
_rte:           DC.B "RTE",0
_rtr:           DC.B "RTR",0
_reset:         DC.B "RESET",0
_sub:           DC.B "SUB",0
_subq:          DC.B "SUBQ",0
_swap:          DC.B "SWAP",0
_subx:          DC.B "SUBX",0
_subi:          DC.B "SUBI",0
_sbcd:          DC.B "SBCD",0
_stop:          DC.B "STOP",0
_tst:           DC.B "TST",0
_trap:          DC.B "TRAP",0
_trapv:         DC.B "TRAPV",0
_tas:           DC.B "TAS.B",0
_unlk:          DC.B "UNLK",0
_bkpt:          DC.B "BKPT",0
_breite:        DC.B "BWL",0
                EVEN
masktab:        DC.W $FFFF      ;00, nichts
                DC.W $FF00      ;01, unteres Byte=#-Daten (MOVEQ)
                DC.W $FFFF      ;02, #-Bitnr. im folgenden Wort
                DC.W $FFF0      ;03, reine #-Zahl für TRAP in Bits 0-3
                DC.W $F1FF      ;04, data-# für ADDQ etc Bits 9-11
                DC.W $FFF8      ;05, -(An) Bits 0-2
                DC.W $FFF8      ;06, (An)+ Bits 0-2
                DC.W $FF00      ;07, relative Adressdistanz folgt
                DC.W $FFF8      ;08, An Bits 0-2
                DC.W $FFF8      ;09, Dn Bits 0-2
                DC.W $F1FF      ;0A, An Bits 9-11
                DC.W $F1FF      ;0B, Dn Bits 9-11
                DC.W $F03F      ;0C, <ea> Bit 6-11
                DC.W $FFC0      ;0D, alle
                DC.W $FFC0      ;0E, änderbar
                DC.W $FFC0      ;0F, Daten änderbar
                DC.W $FFC0      ;10, Daten
                DC.W $FFC0      ;11, Speicher änderbar
                DC.W $FFC0      ;12, alles außer #
                DC.W $FFC0      ;13, Kontrolle
                DC.W $F1FF      ;14, -(An) Bits 9-11
                DC.W $F1FF      ;15, (An)+ Bits 9-11
                DC.W $FFFF      ;16, CCR
                DC.W $FFFF      ;17, SR
                DC.W $FFFF      ;18, USP
                DC.W $FFFF      ;19, #-Zahl mit 16 bit folg. Wort (to SR,STOP)
                DC.W $FFFF      ;1A, #-Zahl mit 8bit folg.Wort (to CCR)
                DC.W $FFFF      ;1B, #-Wort mit Länge x folgt
                DC.W $FFF8      ;1C, d(An) Bits 0-2
                DC.W $F1FF      ;1D, d(An) Bits 9-11
                DC.W $FFFF      ;1E, relative Adressdistanz im folgenden Wort (DBRA,..)
                DC.W $FFF8      ;1F, # 3-Bit
                DC.W $F000      ;20, für LineA

dis0:           move.w  (A6)+,D1        ;zu disassemblierender Wert in D1

dis1:           moveq   #$3F,D0         ;Quelladressierungsart
                and.w   4(A1),D0        ;Maske für Adressierarten aus Tabelle
                add.w   D0,D0           ;mal zwei als Index
                move.w  masktab(PC,D0.w),D3 ;Maske (Qperator) in D3
                move.w  4(A1),D0        ;Maske nocheinmal holen
                ror.w   #7,D0           ;Highbyte zum lowbyte machen
                and.w   #$7E,D0         ;mal zwei als Index
                and.w   masktab(PC,D0.w),D3 ;Operandenmaske einbringen
                move.w  4(A1),D0        ;Word für Adressierarten
                bpl.s   dis10
                and.w   #$FF3F,D3       ;Operand negativ
dis10:          tst.b   D0              ;Conditionfeld?
                bpl.s   dis11
                and.w   #$F0FF,D3       ;Operator negativ
dis11:          and.w   D1,D3           ;prüfen, ob d1 in die Maske passt
                cmp.w   2(A1),D3        ;Opcode aus Tabelle gleich?
                beq     dis_2           ;ja, könnte das Richtige sein
dis8:           addq.l  #6,A1           ;Zeiger erhöhen
                pea     disend(PC)
                cmpa.l  (SP)+,A1        ;Ende erreicht?
                bne.s   dis1            ;nein, weitersuchen

                move.w  D1,D0           ;Vergleich auf MOVEM
                andi.w  #$FB80,D0       ;maske für MOVEM
                cmp.w   #$4880,D0       ;Opcode für MOVEM
                bne     opcderr         ;nein, Opcode nicht gefunden

                lea     _movem(PC),A2   ;ASCII: MOVEM.W
mvm1:           move.b  (A2)+,D0        ;in Buffer
                beq.s   mvm12
                cmp.b   #'A',D0
                blo.s   mvm11
                cmp.b   #'Z',D0
                bhi.s   mvm11
                add.b   opcodesize_flag(A4),D0
mvm11:          move.b  D0,(A0)+
                bra.s   mvm1
mvm12:          moveq   #0,D4
                btst    #6,D1           ;Längenbit testen
                beq.s   mvm2
                move.b  opcodesize_flag(A4),-2(A0)
                addi.b  #"L",-2(A0)     ;war Langwort
mvm2:           movea.l 4(SP),A1        ;Bufferanfang
                adda.w  tabs+2(A4),A1   ;Operantentab
                cmpa.l  A1,A0
                bhi.s   mvm22
                movea.l A1,A0
mvm22:          btst    #$0A,D1         ;Richtung des MOVEM
                bne     mvm3            ;Speicher in Register!
                move.w  D1,-(SP)        ;Opcode merken
                moveq   #0,D1
                move.w  (A6)+,D1        ;Registermaske holen
                tst.b   2(A5)
                bmi.s   mvm_3           ;Registerliste
                move.w  (SP),D0         ;Opcode
                andi.w  #$38,D0
                cmp.w   #$20,D0
                beq.s   mvm_2           ;Zieladressierart -(An)
                bsr     _d1turn
mvm_2:          bsr     mskout
mvm_4:          move.w  (SP)+,D1        ;Opcode zurückholen
                move.b  #",",(A0)+      ;Komma zwischen Quelle und Ziel
                moveq   #2,D4
                jsr     mvm4(PC)        ;disassemblieren des Ziels
                tst.w   D7
                bne     opcderr
                move    #0,CCR          ;keine Fehler
                lea     tabs+4(A4),A2
                tst.b   9(A5)
                bne     rem_out
                rts
mvm_3:          bsr     labelout2
                bra.s   mvm_4

mvm4:           tst.b   4(A5)
                bne.s   mvm41
                move.b  5(A5),D0
                bmi.s   ma_par          ;Macroparameter
mvm41:          move.w  #$01F4,-(SP)    ;Ziel disassemblieren
                bra     disea
ma_par:         move.b  #'\',(A0)+      ;Macroparameter ausgeben
                and.w   #$1F,D0
                divu    #10,D0
                tst.w   D0
                beq.s   ma_par1         ;keiner 10
                or.w    #'0',D0
                move.b  D0,(A0)+        ;Zener ausgeben
ma_par1:        swap    D0
                or.w    #'0',D0
                move.b  D0,(A0)+        ;Einer ausgeben
                moveq   #0,D0
                moveq   #0,D7           ;keine Fehler
                rts

mvm_5:          bsr     labelout2
                bra.s   mvm_6
mvm3:           move.w  (A6)+,-(SP)
                move.w  D1,-(SP)
                jsr     mvm5(PC)        ;disassemblieren der Quelle
                move.b  #",",(A0)+
                moveq   #2,D4
                move.w  (SP)+,D0
                moveq   #0,D1
                move.w  (SP)+,D1        ;Registermaske
                tst.w   D7
                bne.s   opcderr
                tst.b   4(A5)
                bmi.s   mvm_5
                bsr.s   _d1turn
                bsr.s   mskout
mvm_6:          move    #0,CCR
                lea     tabs+4(A4),A2
                tst.b   9(A5)
                bne     rem_out
                rts
mvm5:           tst.b   2(A5)
                bne.s   mvm51
                move.b  3(A5),D0
                bmi.s   ma_par          ;Macroparameter
mvm51:          move.w  #$07EC,-(SP)
                bra     disea

_movem:         DC.B "MOVEM.W ",0
                EVEN
opcderr:        move.b  #'?',(A0)+
                move.b  #'?',(A0)+
                move.b  #'?',(A0)+
                clr.b   (A0)+
                lea     tabs+4(A4),A2
                tst.b   9(A5)
                bne     rem_out
                rts

_d1turn:        movem.w D0/D4,-(SP)
                moveq   #15,D0
_d1turn1:       add.w   D1,D1
                roxr.w  #1,D4
                dbra    D0,_d1turn1
                move.w  D4,D1
                movem.w (SP)+,D0/D4
                rts

mskout:         moveq   #15,D0
mskout2:        tst.w   D1
                beq.s   mskout1         ;Maske nun leer => Ende
                bclr    D0,D1
                dbne    D0,mskout2
                beq.s   mskout1         ;Nichts gefunden, Ende
                bsr.s   regout          ;Register ausgeben
                bmi.s   mskout1         ;letzes Register
                tst.w   D1              ;Maske leer?
                beq.s   mskout1         ;dann Ende
                btst    D0,D1
                beq.s   mskout3         ;Folgeregister vorhanden? Nein =>
                move.b  #"-",(A0)+      ;'-' ausgeben
mskout4:        bclr    D0,D1
                dbeq    D0,mskout4
                addq.w  #1,D0           ;1 aufaddieren:jetzt ist D0 richtiges Reg
                bsr.s   regout
                bmi.s   mskout1
                tst.w   D1
                bne.s   mskout3         ;ja, es kommen noch andere Register
mskout1:        rts
mskout3:        move.b  #"/",(A0)+      ;'/' ausgeben
                bra.s   mskout2

regout:         add.w   D0,D0
                add.b   reg_flag(A4),D0
                move.b  regtab(PC,D0.w),(A0)+
                move.b  regtab+1(PC,D0.w),(A0)+
                sub.b   reg_flag(A4),D0
                lsr.w   #1,D0
                subq.w  #1,D0
                rts

regtab:         DC.B "A7A6A5A4A3A2A1A0D7D6D5D4D3D2D1D0"
                DC.B "a7a6a5a4a3a2a1a0d7d6d5d4d3d2d1d0"
                EVEN

dis_2:          bsr.s   dis2
                bcs     dis8            ;nein, stimmte nicht
                lea     tabs+4(A4),A2
                tst.b   9(A5)
                bne     rem_out
                rts

dis2:           move.w  4(A1),D5        ;D5=Adressierungsarten-Wort
                move.w  (A1),D0         ;A1=Zeiger in die Mnemonic-Tabelle.
                lea     distab(PC),A2   ;Suchzeiger auf Tabellenanfang
                lea     0(A2,D0.w),A2
                move.l  A0,-(SP)
                tst.b   (A2)            ;ersten Buchstaben testen
                bmi.s   dis311          ;negativ->LINEA
dis3:           move.b  (A2)+,D0        ;A2=Zeiger aufs Mnemonic-Klartext
                beq.s   dis32           ;fertig
                cmp.b   #'A',D0
                blo.s   dis31           ;SPACE soll nicht gewandelt werden
                cmp.b   #'Z'+1,D0
                bhs.s   dis31
                add.b   opcodesize_flag(A4),D0 ;ev.in Kleinbuchstaben wandeln
dis31:          move.b  D0,(A0)+
                bra.s   dis3
dis311:         addq.l  #1,A2
                btst    #4,editor3_flag(A4) ;Mac-Traps an?
                beq.s   dis3            ;nein =>
                bsr     dis_mactrap     ;Mac Trap-Makro ausgeben
                movea.l (SP)+,A2        ;Anfang des Mnemonics
                bra     disok           ;es folgt keine EA

dis32:          movea.l (SP)+,A2        ;Anfang des Mnemonics
                tst.b   D5              ;Adressierungsarten-Word
                bpl     dis4            ;Bit für Condition nicht gesetzt
                move.w  D1,D0           ;zu disassemblierendes Datum
                bclr    #7,D5           ;Bit für Condition jetzt löschen
                andi.w  #$0F00,D0       ;die 4 Bit Condition isolieren
                lsr.w   #7,D0
                cmp.w   #2,D0
                bne.s   discond
                cmpi.b  #'d',-2(A0)
                beq.s   dis33           ;dbf wird zu dbra (wogegen sf nicht sra wird)
                cmpi.b  #'D',-2(A0)
                bne.s   discond
                cmpi.b  #'B',-1(A0)
                beq.s   dis33
                cmpi.b  #'b',-1(A0)
                bne.s   discond
dis33:          move.b  opcodesize_flag(A4),D0
                move.b  #"R",(A0)       ;dbra
                add.b   D0,(A0)+
                move.b  #"A",(A0)
                add.b   D0,(A0)+
                bra.s   dis4
discond:        cmpi.w  #1,4(A5)
                bne.s   discond1
                add.w   #32,D0          ;Zeiger auf andere Tabelle für BLO,etc.
discond1:       move.b  contab(PC,D0.w),(A0)+
                move.b  contab+1(PC,D0.w),(A0)
                move.b  opcodesize_flag(A4),D0
                add.b   D0,-1(A0)
                cmpi.b  #' ',(A0)+
                beq.s   dis4
                add.b   D0,-1(A0)
                bra.s   dis4

contab:         DC.B "T F HILSCCCSNEEQVCVSPLMIGELTGTLE"
                DC.B "T F HILSHSLONEEQVCVSPLMIGELTGTLE"
                EVEN

dis4:           tst.w   D5              ;Adressierungsarten-Word
                bpl.s   dis5            ;Bit für Längenangabe war gelöscht
                move.b  #".",(A0)+
                move.b  opcodesize_flag(A4),(A0)
                addi.b  #"B",(A0)+      ;.B als Vorbesetzung
                move.w  D1,D0           ;zu disass. Wert
                andi.w  #$C0,D0         ;Länge isolieren
                beq.s   dis7            ;.B,fertig
                cmp.w   #$C0,D0         ;beide Bits gesetzt?
                beq.s   diserr          ;ja, Abbruch
                move.b  opcodesize_flag(A4),-1(A0)
                cmp.w   #$40,D0         ;.W?
                beq.s   dis6
                addi.b  #"L",-1(A0)
                bra.s   dis7
dis6:           addi.b  #"W",-1(A0)
dis7:           bclr    #15,D5
dis5:           tst.w   D5
                beq.s   disok           ;Wenn kein Operator/Operand folgt => Ende
                move.b  #' ',(A0)+
                move.l  A2,-(SP)
                movea.l 12(SP),A2       ;Bufferanfang
                adda.w  tabs+2(A4),A2   ;Operantentab
                cmpa.l  A2,A0
                bhi.s   dis55
                movea.l A2,A0
dis55:          movea.l (SP)+,A2
                tst.w   D5
                beq.s   disok           ;fertig disassembliert, keine Parameter
                move.b  D5,D3           ;in D3 schieben
                moveq   #0,D4           ;Operator
                movem.l D1/D5/A2,-(SP)
                jsr     dout(PC)
                movem.l (SP)+,D1/D5/A2
                tst.w   D7
                bne.s   diserr
                move.w  D5,D3
                lsr.w   #8,D3
                tst.b   D3
                beq.s   disok           ;kein Operand
                movem.l D1/D5/A2,-(SP)
                move.b  #",",(A0)+
                moveq   #2,D4           ;Operand auswerten
                jsr     dout(PC)
                movem.l (SP)+,D1/D5/A2
                tst.w   D7
                bne.s   diserr
disok:          move    #0,CCR
                rts
diserr:         move    #$FF,CCR        ;Flags setzen als Zeichen für Fehler
                movea.l A2,A0           ;Zeiger zurück auf Anfang
                rts

dout2:          bra     ma_par
dout:           clr.w   D7              ;Fehlerflag löschen
                tst.b   2(A5,D4.w)
                bne.s   dout1
                move.b  3(A5,D4.w),D0
                bmi.s   dout2           ;Macroparameter
dout1:          moveq   #$3F,D0         ;evtl. Längenflag isolieren
                and.w   D3,D0           ;zu behandelndes Wort
                add.w   D0,D0           ;mal zwei als Index
                move.w  douttab(PC,D0.w),D0
                lea     distab(PC),A2   ;Suchzeiger auf Tabellenanfang
                jmp     0(A2,D0.w)

                BASE DC.W,distab
douttab:        DC.W 0,_dis1,_dis2,_dis3
                DC.W _dis4,_dis5,_dis6,_dis7
                DC.W _dis8,_dis9,_disa,_disb
                DC.W _disc,_disd,_dise,_disf
                DC.W _dis10,_dis11,_dis12,_dis13
                DC.W _dis14,_dis15,_dis16,_dis17
                DC.W _dis18,_dis19,_dis1a,_dis1b
                DC.W _dis1c,_dis1d,_dis1e,_dis1f
                DC.W _dislinea

_dis1:          move.l  #$FF,D6
labquik:        move.b  #"#",(A0)+
labqui2:        tst.b   2(A5,D4.w)      ;Label?
                beq     numout          ;Nein => Zahl ausgeben
labqui3:        moveq   #0,D1
                move.w  2(A5,D4.w),D1
                and.w   #$3FFF,D1
                bra     labelout2
_dis2:          move.w  (A6)+,D1
                moveq   #$3F,D6
                tst.b   2(A5)
                beq.s   labquik
                move.b  #'#',(A0)+
                andi.w  #$3FFF,D1
                bra     labelout2

_dis3:          moveq   #$0F,D6
                bra.s   labquik

_dislinea:      moveq   #$0F,D6
                bsr.s   labquik
                btst    #4,editor3_flag(A4) ;Mac-Traps an?
                bne.s   _dis31          ;ja, Code schon entschlüsselt=>
                addq.l  #1,A0
                move.w  -2(A6),D1
                andi.w  #$0F,D1
                lsl.w   #3,D1
                move.b  #'[',(A0)+
                move.b  #' ',(A0)+
                moveq   #7,D0
_dis3a:         addq.w  #1,D1
                move.b  _lineatab-1(PC,D1.w),(A0)+
                cmpi.b  #' ',-1(A0)
                dbeq    D0,_dis3a
                beq.s   _dis3b
                move.b  #' ',(A0)+
_dis3b:         move.b  #']',(A0)+
_dis31:         rts

                DXSET 8,' '
_lineatab:      DX.B 'Init'
                DX.B 'Putpix'
                DX.B 'Getpix'
                DX.B 'Line'
                DX.B 'Hline'
                DX.B 'Fillrec'
                DX.B 'Fillpoly'
                DX.B 'Bitblk'
                DX.B 'Textblk'
                DX.B 'Showm'
                DX.B 'Hidem'
                DX.B 'Transm'
                DX.B 'Undraw'
                DX.B 'Draw'
                DX.B 'Copy'
                DX.B 'Fill'
_dis1f:         and.w   #7,D1
                bra     _break
_dis4:          rol.w   #7,D1
                and.l   #7,D1
                bne     _dis1
                moveq   #8,D1
                bra     _dis1
_dis5:          move.b  #"-",(A0)+
_dis5_1:        move.b  #"(",(A0)+
                bsr.s   _dis8
                move.b  #")",(A0)+
                rts
_dis6:          move.b  #"(",(A0)+
                bsr.s   _dis8
                move.b  #")",(A0)+
                move.b  #"+",(A0)+
                rts
_dis7:          tst.b   D1              ;relative Adressdistanz folgt
                beq.s   _dis1e
_dis7b:         cmpi.b  #' ',-(A0)
                beq.s   _dis7b
                addq.l  #1,A0
                move.b  #".",(A0)+
                move.b  opcodesize_flag(A4),(A0)
                addi.b  #"S",(A0)+
                move.b  #' ',(A0)+
                movea.l 24(SP),A2       ;Bufferanfang
                adda.w  tabs+2(A4),A2   ;Operantentab
                cmpa.l  A2,A0
                bhi.s   _dis7a
                movea.l A2,A0
_dis7a:         move.l  #$FE,D6
                bra     labqui2
_dis1e:         move.w  (A6)+,D1
                move.l  #$FFFE,D6
                bra     numout
_dis8:          andi.w  #7,D1
                cmp.w   #7,D1
                bne.s   _dis8_1
                tst.b   sp_flag(A4)
                beq.s   _dis8_1
                move.b  reg_flag(A4),(A0)
                addi.b  #"S",(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #"P",(A0)+
                rts
_dis8_1:        move.b  reg_flag(A4),(A0)
                addi.b  #'A',(A0)+
                addi.w  #"0",D1
                move.b  D1,(A0)+
                rts
_dis9:          move.b  reg_flag(A4),(A0)
                addi.b  #"D",(A0)+
                andi.w  #7,D1
                addi.w  #"0",D1
                move.b  D1,(A0)+
                rts
_disa:          rol.w   #7,D1
                bra.s   _dis8
_disb:          rol.w   #7,D1
                bra.s   _dis9
_dis14:         rol.w   #7,D1
                bra     _dis5
_dis15:         rol.w   #7,D1
                bra     _dis6
_dis16:         move.b  reg_flag(A4),(A0)
                addi.b  #"C",(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #"C",(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #"R",(A0)+
                rts
_dis17:         move.b  reg_flag(A4),(A0)
                addi.b  #"S",(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #"R",(A0)+
                rts
_dis18:         move.b  reg_flag(A4),(A0)
                addi.b  #"U",(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #"S",(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #"P",(A0)+
                rts
_dis19:         move.b  #"#",(A0)+
_dis19_1:       move.w  (A6)+,D1
                move.l  #$FFFF,D6
                bra     numout
_dis1a:         moveq   #0,D1
                move.w  (A6)+,D1
                move.l  #$FF,D6
_break:         move.b  #"#",(A0)+
                tst.b   2(A5,D4.w)      ;Label?
                beq     numout          ;Nein => Zahl ausgeben
                bra     labelout2
_dis1b:         tst.w   4(A1)           ;adressierarten-Wort aus der Tabelle
                bmi.s   _dis1b_1        ;ist mit einem <ln>-Feld ausgestattet
                move.w  4(A1),D1
                btst    #14,D1          ;Bit = 0 heißt .B
                beq.s   _dis1a
                btst    #6,D1
                beq.s   _dis19          ;ist .W
                bne.s   _dis1b_2
_dis1b_1:       andi.w  #$C0,D1         ;<ln>-Feld isolieren
                beq.s   _dis1a
                cmp.w   #$40,D1
                beq.s   _dis19          ;ist .W
_dis1b_2:       move.b  #"#",(A0)+
                move.l  (A6)+,D1        ;ist .L
                moveq   #-1,D6
                bra     numout
_dis1c:         move.w  D1,-(SP)
                bsr.s   _dis19_1
                move.w  (SP)+,D1
                move.b  #"(",(A0)+
                bsr     _dis8
                move.b  #")",(A0)+
                rts
_dis1d:         rol.w   #7,D1
                bra.s   _dis1c
disea:          moveq   #0,D7           ;Fehlerflag löschen
                clr.w   D3              ;Maske löschen
                moveq   #%111000,D0
                and.w   D1,D0
                cmp.w   #%111000,D0
                beq.s   eafind1         ;ist eine 111xxx-Art
                lsr.w   #3,D0
                bra.s   eafind2
eafind1:        moveq   #7,D0
                and.w   D1,D0
                cmp.w   #5,D0
                bhs.s   eafind3
                addq.w  #7,D0
eafind2:        bset    D0,D3
eafind3:        and.w   (SP)+,D3        ;erlaubt-Maske mit Adressierart vergleichen
                beq.s   disea1
                cmp.w   #1,D3           ;Dn
                beq     _dis9
                cmp.w   #2,D3           ;An
                beq     _dis8
                cmp.w   #4,D3           ;(An)
                beq     _dis5_1
                cmp.w   #8,D3           ;(An)+
                beq     _dis6
                cmp.w   #$10,D3         ;-(An)
                beq     _dis5
                cmp.w   #$20,D3         ;d(An)
                beq.s   _dis1c
                cmp.w   #$40,D3         ;d(An,Rx)
                beq.s   _dis20
                cmp.w   #$80,D3         ;$xxxx
                beq.s   _dis21
                cmp.w   #$0100,D3       ;$xxxxxxxx
                beq.s   _dis22
                cmp.w   #$0200,D3       ;d(PC)
                beq.s   _dis23
                cmp.w   #$0400,D3       ;d(PC,Rx)
                beq     _dis24
                cmp.w   #$0800,D3       ;#
                beq     _dis1b
disea1:         st      D7              ;Fehler aufgetreten
                rts
_dis20:         move.w  D1,-(SP)        ;d(An,Rn.x)
                move.w  (A6)+,D1
                move.w  D1,-(SP)
                tst.b   2(A5,D4.w)
                bpl.s   _dis20a
                moveq   #0,D6
                move.w  2(A5,D4.w),D6
                btst    #6,D6           ;Vorzeichen
                beq.s   _dis20c
                move.b  #'-',(A0)+
_dis20c:        andi.w  #$3F00,D6
                move.b  D1,D6
                move.l  D6,D1
                bsr     labelout2
                bra.s   _dis20b
_dis20a:        move.l  #$FF,D6
                bsr     numout
_dis20b:        move.w  2(SP),D1        ;gemerktes D1(opcode) holen
                move.b  #"(",(A0)+
                bsr     _dis8           ;An ausgeben
                move.w  (SP)+,D1
                addq.l  #2,SP           ;Stack normalisieren
                bra     _dis24_1
_dis21:         move.w  (A6)+,D1        ;$xxxx
                ext.l   D1
                moveq   #-1,D6
                bsr     numout
                move.b  #'.',(A0)+
                move.b  #'w',(A0)+
                rts
_dis22:         move.l  (A6)+,D1        ;$xxxxxxxx
                moveq   #-1,D6
                bra     numout
_dis23:         move.w  (A6)+,D1        ;d(PC)
                move.l  #$FFFF,D6
                bsr     numout
                move.b  #'(',(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #'P',(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #'C',(A0)+
                move.b  #')',(A0)+
                rts
_dis24:         move.w  (A6)+,D1        ;d(PC,Rn.x)
                move.w  D1,-(SP)
                tst.b   2(A5,D4.w)
                bpl.s   _dis24a
                moveq   #0,D6
                move.w  2(A5,D4.w),D6
                btst    #6,D6           ;Vorzeichen
                beq.s   _dis24c
                move.b  #'-',(A0)+
_dis24c:        andi.w  #$3F00,D6
                move.b  D1,D6
                move.l  D6,D1
                bsr     labelout2
                bra.s   _dis24b
_dis24a:        move.l  #$FF,D6
                bsr     numout
_dis24b:        move.w  (SP)+,D1        ;gemerktes D1(opcode) holen
                move.b  #'(',(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #'P',(A0)+
                move.b  reg_flag(A4),(A0)
                addi.b  #'C',(A0)+
_dis24_1:       move.b  #",",(A0)+
                move.b  #"D",(A0)+
                tst.w   D1
                bpl.s   _dis24_2        ;ist Dn
                move.b  #"A",-1(A0)
_dis24_2:       move.b  reg_flag(A4),D0
                add.b   D0,-1(A0)
                move.w  D1,D0
                rol.w   #4,D0
                andi.w  #7,D0
                addi.w  #$30,D0
                move.b  D0,(A0)+
                move.b  #".",(A0)+
                move.b  #"w",(A0)+
                btst    #11,D1
                beq.s   _dis24_3
                move.b  #"l",-1(A0)
_dis24_3:       move.b  #")",(A0)+
                rts
_disd:          move.w  #$0FFF,-(SP)
                bra     disea
_dise:          move.w  #$01FF,-(SP)
                bra     disea
_disf:          move.w  #$01FD,-(SP)
                bra     disea
_dis10:         move.w  #$0FFD,-(SP)
                bra     disea
_dis11:         move.w  #$01FC,-(SP)
                bra     disea
_dis12:         move.w  #$07FF,-(SP)
                bra     disea
_dis13:         move.w  #$07E4,-(SP)
                bra     disea
_disc:          move.w  D1,D0
                lsr.w   #3,D0
                andi.w  #$38,D0         ;bits isolieren
                rol.w   #7,D1
                andi.w  #7,D1
                or.w    D0,D1
                andi.w  #$3F,D1         ;gültige Bits isolieren
                move.w  #$01FD,-(SP)
                bra     disea

************************************************************************
* Zahl in D1 ausgeben                                                  *
************************************************************************
numoutx:        btst    #6,3(A5,D4.w)   ;Vorzeichen
                beq.s   numoux1
                move.b  #'-',(A0)+
numoux1:        bra     labelout2
numout:         tst.b   2(A5,D4.w)
                bne.s   numoutx
                and.l   D6,D1
numout1:        movem.l D0-D4/A6,-(SP)
                moveq   #0,D2
                btst    #0,D6
                bne.s   basout0
                bset    #0,D6
                move.b  #'*',(A0)+
                move.b  #'+',(A0)
                moveq   #-1,D2
basout0:        and.l   D6,D1
                move.w  2(A5,D4.w),D0
basoutx:        btst    #3,D0           ;Vorzeichen
                beq.s   basout9
                move.b  #'-',(A0)+
                moveq   #0,D2
                neg.l   D1
                and.l   D6,D1
basout9:        andi.w  #1,D2
                adda.w  D2,A0
                move.w  D0,D2
                andi.w  #3,D2
                btst    #2,D0           ;Ascii
                bne.s   numout4         ;ja!
                cmp.w   #1,D2           ;Hex
                beq.s   numout8         ;ja!
                cmp.w   #2,D2           ;Bin
                beq     numout9         ;ja!
                move.b  tab(PC,D2.w),D0
                beq.s   basout2
                move.b  D0,(A0)+        ;und ausgeben
basout2:        move.b  tab1(PC,D2.w),D2 ;Zahlenbasis
                movea.l SP,A6           ;Zahlenbasiszeichen (z.b. $) vorangestellt
numout0:        bsr     div             ;durch Zahlenbasis teilen
                move.w  D3,-(SP)        ;BCD-Ziffer auf Stack
                tst.l   D1
                bne.s   numout0         ;Zahl komplett auf dem Stack?
numout3:        moveq   #'0',D0
                add.w   (SP)+,D0        ;BCD-Ziffer holen
                cmp.b   #$3A,D0
                blo.s   numout2
                addq.b  #7,D0           ;in ASC-Ziffer oder Buchstaben wandeln
numout2:        move.b  D0,(A0)+        ;Zeichen ausgeben
                subq.w  #1,buff_rest(A4)
                cmpa.l  SP,A6
                bne.s   numout3         ;schon alles?
                movem.l (SP)+,D0-D4/A6
                rts
numout4:        btst    #0,D2           ;Ascii
                sne     D2
                and.w   #7,D2
                or.w    #$22,D2         ;Art der Anführungszeichen
                move.b  D2,(A0)+
                moveq   #3,D0
numout6:        rol.l   #8,D1
                tst.b   D1
                beq.s   numout5
                move.b  D1,(A0)+
                cmp.b   D2,D1           ;gleich dem Endezeichen ?
                bne.s   numout5         ;nein
                move.b  D2,(A0)+        ;sonst doppelt ausgeben
numout5:        dbra    D0,numout6
                move.b  D2,(A0)+
numout7:        movem.l (SP)+,D0-D4/A6
                rts

tab:            DC.B 0,"$%&"
tab1:           DC.B 10,16,2,8
                EVEN
numout8:        move.b  #'$',(A0)+
                subq.w  #1,buff_rest(A4)
;                tst.l   D1
;                beq.s   numou81         ;Sonderbehandlung für Null
                lea     num_tab(PC),A6
                tst.b   hex_flag(A4)
                beq.s   numou82
                lea     16(A6),A6
numou82:        pea     numou81(PC)
                moveq   #0,D3           ;Erstes Byte noch nicht ausgegeben
                cmp.w   #$FF,D6
                bls.s   numou83         ;Byte
                tst.l   D6
                bpl.s   numou86         ;Word
                swap    D1              ;Longword in D1 ausgeben
                bsr.s   numou86
                swap    D1
numou86:        rol.w   #8,D1           ;Word in D1 ausgeben
                bsr.s   numou83
                rol.w   #8,D1
numou83:        tst.b   hexlen_flag(A4) ;Zahl kürzen?
                bne.s   numou85         ;Nein! =>
                tst.b   D1
                bne.s   numou85         ;kein Nullbyte => ausgeben
                tst.w   D3              ;das erste Byte?
                beq.s   numou84         ;Ja! => nicht ausgeben
numou85:        movem.l D0-D2,-(SP)     ;Byte in D1 ausgeben
                st      D3              ;erstes Byte ausgegeben
                moveq   #$0F,D2
                and.w   D1,D2
                rol.b   #4,D1
                and.w   #$0F,D1
                move.b  0(A6,D1.w),(A0)+
                move.b  0(A6,D2.w),(A0)+
                subq.w  #2,buff_rest(A4)
                movem.l (SP)+,D0-D2
numou84:        rts
numou81:        tst.b   D3              ;keine Ziffer ausgegeben?
                bne.s   numout82        ;Doch =>
                bsr.s   numou85         ;"00" ausgeben
numout82:       bra.s   numout7         ;raus =>
num_tab:        DC.B '0123456789ABCDEF'
                DC.B '0123456789abcdef'

numout9:        move.b  #'%',(A0)+
                subq.w  #1,buff_rest(A4)
                moveq   #31,D0          ;32 Ziffern
                tst.l   D6
                bmi.s   numou94         ;Long =>
                moveq   #15,D0          ;16 Ziffern
                swap    D1
                tst.w   D6
                bmi.s   numou94         ;Word =>
                moveq   #7,D0           ;8 Ziffern
                lsl.l   #8,D1
numou94:        moveq   #0,D2           ;noch keine Führungsnullen ausgeben
                tst.b   hexlen_flag(A4) ;Zahl kürzen?
                beq.s   numou91         ;Ja! =>
                moveq   #1,D2           ;Führungsnullen ausgeben
numou91:        move.b  #'0',(A0)+
                subq.w  #1,buff_rest(A4)
                add.l   D1,D1
                bcc.s   numou92
                moveq   #1,D2
                move.b  #'1',-1(A0)
numou93:        dbra    D0,numou91
                bra     numout7
numou92:        tst.b   D2              ;Nullen stets ausgeben?
                bne.s   numou93         ;Ja! =>
                subq.l  #1,A0
                tst.w   D0
                bne.s   numou93
                move.b  #'0',(A0)+
                bra     numout7

************************************************************************
* Labelausgabe                                                         *
************************************************************************
labelout:       move.b  #'\',(A0)+
                and.w   #$1F,D1
                ext.l   D1
                divu    #10,D1
                tst.w   D1
                beq.s   labelout1       ;keiner 10
                or.w    #'0',D1
                move.b  D1,(A0)+        ;Zener ausgeben
labelout1:      swap    D1
                or.w    #'0',D1
                move.b  D1,(A0)+        ;Einer ausgeben
                moveq   #0,D1
                movea.l (SP)+,A1
                rts
labelout2:      move.l  A1,-(SP)
                movea.l label_base(A4),A1
                ext.l   D1
                bmi.s   labelout4
                lsl.l   #5,D1
                lea     8(A1,D1.l),A1
                tst.b   31-8(A1)
                bmi     formelout
                tst.b   (A1)
                bne.s   labelout3       ;kein lokales Label
                move.b  local_char(A4),(A0)+
                addq.l  #1,A1
                subq.w  #1,buff_rest(A4)
labelout3:      subq.w  #1,buff_rest(A4)
                move.b  (A1)+,(A0)+     ;Label einsetzen
                bne.s   labelout3
                move.b  #' ',-(A0)
                movea.l (SP)+,A1
                rts
labelout4:      btst    #14,D1
                bne.s   labelout        ;Macroparameter
                andi.w  #$3FFF,D1
                beq.s   labelout5
                move.b  #'^',(A0)+
                move.b  #'^',(A0)+
                subq.w  #2,buff_rest(A4)
labelout5:      lea     va_tab(PC,D1.w),A1
labelout6:      subq.w  #1,buff_rest(A4)
                move.b  (A1)+,(A0)+     ;interne Variable einsetzen
                bne.s   labelout6
                move.b  #' ',-(A0)
                movea.l (SP)+,A1
                rts
                DXSET 8,0
va_tab:         DX.B '*'
                DX.B 'DATE'
                DX.B 'TIME'
                DX.B 'RSCOUNT'
                DX.B 'RANDOM'
                DX.B 'SYMTAB'
                DX.B 'RELOC'
                DC.B 0,0,0,0

************************************************************************
* Ausgabe der Formel                                                   *
************************************************************************
formelout:      subq.w  #2,A1
                move.b  (A1)+,D1
                btst    #0,D1
                beq.s   formel4
                btst    #1,D1
                bne.s   formel0
                move.b  #'-',(A0)+      ;Minus
                bra.s   formel4
formel0:        move.b  #'~',(A0)+      ;Not
                bra.s   formel4
f_loop:         move.b  (A1),D1
                and.w   #$C0,D1
                beq.s   formel1
formel3:        move.b  #')',(A0)+
                sub.w   #$40,D1
                bne.s   formel3
formel1:        cmpi.b  #$FF,1(A1)
                beq.s   formelend
                move.b  (A1)+,D1
                moveq   #$0F,D0
                and.w   D1,D0
                add.w   D0,D0
                move.b  f_zeichen(PC,D0.w),(A0)+
                move.b  f_zeichen+1(PC,D0.w),D0
                beq.s   formel4
                move.b  D0,(A0)+
formel4:        and.w   #$30,D1
                beq.s   formel5
formel6:        move.b  #'(',(A0)+
                sub.w   #$10,D1
                bne.s   formel6
formel5:        move.b  (A1)+,D0
                move.w  D0,D1
                and.w   #$30,D1         ;Flags für '!' und '~'
                beq.s   formel9
                move.b  #'~',(A0)+
                cmp.w   #$10,D1
                beq.s   formel9
                move.b  #'!',-1(A0)
formel9:        tst.b   D0
                bpl.s   formel7         ;kein Label
                btst    #3,D0           ;Vorzeichen
                beq.s   formela
                move.b  #'-',(A0)+
formela:        move.w  (A1)+,D1
                bsr     labelout2       ;Label ausgeben
                bra.s   f_loop
formel7:        pea     f_loop(PC)
                movem.l D0-D4/A6,-(SP)
                moveq   #0,D1
                moveq   #0,D2
                bclr    #6,D0
                beq.s   formel8
                move.l  (A1)+,D1
                moveq   #$FF,D6
                bra     basoutx
formel8:        move.w  (A1)+,D1
                move.l  #$FFFF,D6
                bra     basoutx
formelend:      movea.l (SP)+,A1
                rts

f_zeichen:      DC.B '+',0,'-',0,'|',0,'^',0,'<<','>>'
                DC.B '*',0,'/',0,'&',0,'%',0,'=',0
                DC.B '<',0,'>',0,'<=','>=','<>'
                EVEN

************************************************************************
* Ausgabe des Remarks                                                  *
************************************************************************
rem_out:        movea.l 4(SP),A1
                cmpa.l  A1,A0
                beq.s   rem_out2
                move.b  #' ',(A0)+
                adda.w  (A2),A1         ;Tab für Remark
                cmpa.l  A1,A0
                bhi.s   rem_out2        ;Tab bereits überschritten
                movea.l A1,A0
rem_out2:       move.l  4(SP),D2
                add.l   #255,D2         ;Bufferende
                sub.l   A0,D2           ;D2 = Anzahl verbleibender Zeichen
rem_out_loop:   subq.w  #1,D2
                beq.s   rem_ende
                move.b  (A3)+,(A0)+
                beq.s   rem_ende2
                cmpi.b  #1,-1(A0)
                bne.s   rem_out_loop
                moveq   #0,D1
                move.b  (A3)+,D1
                move.b  (A3)+,D0
                move.b  D0,-1(A0)
rem_out_loop2:  move.b  D0,(A0)+
                dbra    D1,rem_out_loop2
                subq.b  #1,D0
                bne.s   rem_out_loop
                subq.l  #1,A0           ;einer weniger als angegeben
                bra.s   rem_out_loop
rem_ende2:      subq.l  #1,A0
rem_ende:       rts
                ENDPART

                >PART 'Mac Trap-Makros ausgeben'
************************************************************************
* Mac Trap-Makros ausgeben (wird vom Dissassembler aufgerufen)         *
* ->A6 zeigt hinter den Opcode                                         *
* ->A0 zeigt in Ausgabebuffer                                          *
* <-A0 zeigt hinter Text                                               *
************************************************************************
dis_mactrap:    movem.l D0-D1/A1-A2/A6,-(SP)
                subq.l  #2,A6
                lea     mac_trap_tab,A2 ;Zeiger auf Tabellenstruktur
                move.w  (A6),D0         ;Opcode holen
                and.w   #$03FF,D0       ;Nummer ausmaskieren
                move.w  2(A2),D1        ;Offset auf Offsettabelle der Toolboxnamen
                btst    #3,(A6)         ;Typ testen
                bne.s   dis_mactrap1    ;Toolbox-Trap=>
                and.w   #$FF,D0         ;OS-Trapnummer
                move.w  (A2),D1         ;Offset auf Offsettabelle der OSnamen
dis_mactrap1:   lea     0(A2,D1.w),A1   ;Zeiger auf Offsettabelle
                cmp.w   (A1)+,D0        ;mit max. Nummer vergleichen
                ble.s   dis_mactrap2    ;kleiner gleich=>
                move.w  -2(A1),D0       ;sonst max. Nummer nehmen
dis_mactrap2:   add.w   D0,D0           ;mal 2
                move.w  0(A1,D0.w),D0   ;Offset holen
                move.w  4(A2),D1        ;Offset auf Letteroffsets
                add.w   D0,D1
                lea     0(A2,D1.w),A1   ;Zeiger auf Eintrag
                move.b  (A1),D0         ;Flagbyte merken
                addq.l  #2,A1           ;Flags überspringen
                move.b  #'_',(A0)+      ;Name beginnt mit Underline
dis_mactrap3:   move.b  (A1)+,(A0)+     ;Makronamen kopieren
                bpl.s   dis_mactrap3
                andi.b  #$7F,-1(A0)     ;negativ-Bit beim letzten Zeichen löschen
                and.w   #$F0,D0         ;Flag für spezielle Parameter
                beq.s   dis_mactrap4    ;keine Parameter=>
                lsr.w   #4,D0           ;durch 16
                lea     dis_ptraptab(PC),A2
                cmp.b   (A2)+,D0
                bhi.s   dis_mactrap4
dis_mactrap5:   subq.b  #1,D0           ;Parameter gefunden?
                beq.s   dis_mactrap7    ;Ja! =>
dis_mactrap6:   tst.b   (A2)+           ;einen Parameter überlesen
                bne.s   dis_mactrap6
                bra.s   dis_mactrap5    ;und weiter =>
dis_mactrap7:   moveq   #0,D0
                move.b  (A2)+,D0        ;Ende der Liste? (= Nulloffset)
                beq.s   dis_mactrap4    ;Ja! =>
                lea     -1(A2,D0.w),A1  ;Zeiger auf den String (+ Header)
                move.b  (A1),D0
                lsr.b   #4,D0           ;den Parameter
                moveq   #$0F,D1
                and.b   (A1)+,D1        ;Maske holen
                and.b   (A6),D1         ;und den Opcode dazu
                cmp.b   D1,D0           ;Parameter gesetzt?
                bne.s   dis_mactrap7    ;Nein =>
                move.b  #',',(A0)+
dis_mactrap8:   move.b  (A1)+,(A0)+     ;den Namen kopieren
                bpl.s   dis_mactrap8
                andi.b  #$7F,-1(A0)
                bra.s   dis_mactrap7
dis_mactrap4:   movem.l (SP)+,D0-D1/A1-A2/A6
                rts
                BASE DC.B,*
dis_ptraptab:   DC.B 7          ;Anzahl der Einträge in der Tabelle
                DC.B dis_mactrap_0,0 ;POP
                DC.B dis_mactrap_1,dis_mactrap_2,0 ;CLEAR,SYS
                DC.B dis_mactrap_2,0 ;SYS
                DC.B dis_mactrap_3,dis_mactrap_4,0 ;MARKS,CASE
                DC.B dis_mactrap_4,0 ;CASE
                DC.B dis_mactrap_5,dis_mactrap_6,0 ;IMMED,ASYNC
                DC.B dis_mactrap_7,dis_mactrap_8,0 ;NEWOS,NEWTOOL
                OPT W-
dis_mactrap_0:  DC.B $44        ;unteres Nibble: Maske, oberes: Wert
                DC.B 'PO','P'|$80
dis_mactrap_1:  DC.B $22
                DC.B 'CLEA','R'|$80
dis_mactrap_2:  DC.B $44
                DC.B 'SY','S'|$80
dis_mactrap_3:  DC.B $22
                DC.B 'MARK','S'|$80
dis_mactrap_4:  DC.B $44
                DC.B 'CAS','E'|$80
dis_mactrap_5:  DC.B $22
                DC.B 'IMME','D'|$80
dis_mactrap_6:  DC.B $44
                DC.B 'ASYN','C'|$80
dis_mactrap_7:  DC.B $26
                DC.B 'NEWO','S'|$80
dis_mactrap_8:  DC.B $66
                DC.B 'NEWTOO','L'|$80
                OPT W+
                EVEN
                ENDPART

                >PART 'ASCII-Suchen/Ersetzen'
************************************************************************
* ASCII-Suchen                                                         *
************************************************************************
s_jmp_main:     moveq   #0,D0
                bsr     _graf_mouse     ;Mauszeiger = Pfeil
                jmp     main_loop
s_such_alert:   sf      s_such_flag(A4)
                lea     suchena(PC),A0  ;Zeiger auf 'Anfang'-Button
                andi.w  #$FFFE,(A0)     ;Buttons deselekten
                andi.w  #$FFFE,10(A0)
                andi.w  #$FFEF,20(A0)   ;'Block'-Button enablen
                ori.w   #1,20(A0)       ;'Block'-Button selekten
                tst.b   block_fl(A4)    ;Block markiert?
                bne.s   s_such_alert01  ;ja
                andi.w  #$FFFE,20(A0)   ;'Block'-Button deselekten
                ori.w   #$10,20(A0)     ;'Block'-Button disablen
                ori.w   #1,10(A0)       ;'Cursor' selektieren
s_such_alert01: lea     suchen_rsc(PC),A0
                bsr     _form_do
                subq.w  #1,D0
                bne.s   s_jmp_main      ;Abbruch
                move.b  suchend+1(PC),replaced+1 ;groß/klein-Flag kopieren
                move.b  suchende+1(PC),replacede+1
                move.b  suchenc+1(PC),replacec+1
                lea     suchen_1+31(PC),A0
                moveq   #30,D0
s_such_alert3:  cmpi.b  #' ',-(A0)
                dbne    D0,s_such_alert3
                tst.w   D0              ;Patternstring=0
                bmi.s   s_jmp_main
                st      s_such_flag(A4) ;Suchbegriff vorhanden
                lea     suchen_1(PC),A0
                lea     such_puffer(A4),A1
                btst    #0,suchend+1(PC)
                beq.s   s_such_alert5   ;groß/klein Unterscheidung
                lea     upper_tab,A2
                moveq   #0,D1
s_such_alert4:  move.b  (A0)+,D1        ;Patternstring kopieren
                move.b  0(A2,D1.w),(A1)+ ;Zeichen in groß wandeln
                dbra    D0,s_such_alert4
                clr.b   (A1)
                bra     s_such_alert2
s_such_alert5:  move.b  (A0)+,(A1)+
                dbra    D0,s_such_alert5
                clr.b   (A1)
                bra     s_such_alert2

suchen_rsc:     DC.W 0,0,33,13,1
                DC.W 11,1
                DC.L suchen_0
                DC.W 8
                DC.W 1,3
                DC.L suchen_1
                DC.W $88
                DC.W 4,11
                DC.L ok_button
                DC.W $26
                DC.W 20,11
                DC.L abbruch_button
                DC.W $24
                DC.W 1,9
                DC.L suchen_4
suchena:        DC.W $44
                DC.W 12,9
                DC.L suchen_5
suchenb:        DC.W $45
                DC.W 23,9
                DC.L suchen_6
suchenc:        DC.W $44
                DC.W 1,5
                DC.L suchen_7
                DC.W 8
                DC.W 15,5
                DC.L suchen_8
                DC.W 8
                DC.W 12,5
                DC.L alquantor
                DC.W $88
                DC.W 31,5
                DC.L exquantor
                DC.W $88
                DC.W 1,7
                DC.L suchen_11
                DC.W 8
                DC.W 15,7
                DC.L ja_button
suchend:        DC.W $0144
                DC.W 23,7
                DC.L nein_button
suchende:       DC.W $0145
                DC.W -1
alquantor:      DC.B '*',0
exquantor:      DC.B '?',0
suchen_1:       DC.B $FF,'123456789012345678901234567890',0
                SWITCH sprache
                CASE 0
suchen_0:       DC.B 'Text suchen',0
suchen_4:       DC.B ' Anfang ',0
suchen_5:       DC.B ' Cursor ',0
suchen_6:       DC.B ' Block ',0
suchen_7:       DC.B 'Allquantor',0
suchen_8:       DC.B 'Existenzquantor',0
suchen_11:      DC.B 'Groß=klein',0
                CASE 1
suchen_0:       DC.B 'Search for text',0
suchen_4:       DC.B ' Begin ',0
suchen_5:       DC.B ' Cursor ',0
suchen_6:       DC.B ' Block ',0
suchen_7:       DC.B 'Allquantor',0
suchen_8:       DC.B 'Existenzquantor',0
suchen_11:      DC.B 'great=small',0
                ENDS
                EVEN

s_such_next:    tst.b   s_such_flag(A4)
                beq     s_jmp_main      ;kein Suchbegriff
                btst    #0,suchena+1(PC) ;'Anfang'?
                bne.s   s_such_alert2   ;ja
                move.w  D6,such_zeiger(A4)
                move.w  anz_zeilen(A4),such_zeiger+4(A4)
                move.w  cursor_spalte(A4),such_zeiger+2(A4)
                addq.w  #1,such_zeiger+2(A4)
                btst    #0,suchenb+1(PC) ;'Cursor'?
                bne.s   s_such_next2    ;ja
                tst.b   block_fl(A4)
                beq     s_jmp_main      ;kein Block definiert
                cmp.w   block_end(A4),D6
                bhs.s   s_such_next5    ;außerhalb des Blocks->Blockstart
                bra.s   s_such_next51   ;Blockende setzen
s_such_alert2:  tst.b   such_puffer(A4) ;kein Patternstring
                beq     s_jmp_main
                clr.l   such_zeiger(A4)
                move.w  anz_zeilen(A4),such_zeiger+4(A4)
                btst    #0,suchena+1(PC) ;'Anfang'
                bne.s   s_such_next2
                move.w  D6,such_zeiger(A4)
                move.w  cursor_spalte(A4),such_zeiger+2(A4)
                btst    #0,suchenb+1(PC) ;'Cursor'
                bne.s   s_such_next2
s_such_next5:   tst.b   block_fl(A4)
                beq     s_jmp_main      ;kein Block definiert
                move.w  block_anf(A4),such_zeiger(A4)
                clr.w   such_zeiger+2(A4)
s_such_next51:  move.w  block_end(A4),D0 ;Blockende
                cmp.w   anz_zeilen(A4),D0 ;mit max. Anzahl vergleichen
                bhs.s   s_such_next2    ;Blockende gleich Sourcetextende
                move.w  block_end(A4),such_zeiger+4(A4) ;Blockende eintragen
s_such_next2:   move.w  such_zeiger(A4),D2 ;Startzeile
                moveq   #2,D0
                bsr     _graf_mouse
                movem.l D3-D7/A3/A5-A6,-(SP)
                sf      repl_flag(A4)   ;Remarksuche erlaubt
                move.w  D2,D0
                bsr     calc_pointer
                move.b  exquantor(PC),D6 ;'?'-Joker
                move.b  alquantor(PC),D7 ;'*'-Joker
                move.w  such_zeiger+2(A4),D1 ;Position
                bsr.s   such_loop
                movem.l (SP)+,D3-D7/A3/A5-A6
                tst.w   D0
                bmi.s   s_such_next3    ;nichts gefunden
                move.w  D2,such_zeiger(A4)
                move.w  D1,such_zeiger+2(A4)
                move.w  D1,save_pos(A4)
                move.w  D6,letzte_zeile(A4)
                move.w  D2,D6           ;Zeilennummer
                bsr     jump_line
                moveq   #0,D0
                bsr     _graf_mouse
                bra     s_jmp_main
s_such_next3:   move.w  D2,D6
                bsr     jump_line
                moveq   #0,D0
                bsr     _graf_mouse
                bra     s_jmp_main

************************************************************************
* durchsucht Zeilen    (<-D2:Zeile,D1:Position)                        *
************************************************************************
such_loop01:    moveq   #0,D0
                move.b  9(A5),D0
                adda.w  D0,A3           ;eine Zeile weiter
                adda.w  (A5),A6
                lea     10(A5),A5
                addq.w  #1,D2
                cmpi.b  #$54,2(A5)      ;ENDPART
                bne.s   such_loop01     ;nein, nächste Zeile
                bra     such_loop02
such_loop6:     addq.l  #4,SP
                movem.l (SP)+,D1-A6
                bra     such_loop2
such_loop4:     tst.b   repl_flag(A4)   ;Remarksuche erlaubt?
                bmi.s   such_loop41     ;nein
                tst.b   9(A5)
                beq.s   such_loop6
                move.w  #255,D2
                lea     zreserve+2(A4),A0
                bsr     rem_out_loop    ;nur den Remark entkompressen
                clr.b   (A0)            ;Nullbyte als Abschluß
                bra.s   such_loop5
such_loop16:    moveq   #-2,D0          ;nichts gefunden
                rts
such_loop:      move.w  D2,D5
such_loop0:     btst    #0,maustast(A4) ;Klick rechts
                bne.s   such_loop16     ;abbrechen
                btst    #4,maustast(A4) ;Dauerklick rechts
                bne.s   such_loop16     ;abbrechen
                cmpi.w  #$52F0,2(A5)    ;geschützter PART
                beq.s   such_loop01
                cmpi.w  #$52FF,2(A5)    ;eingeklappter PART
                beq.s   such_loop01
                tst.w   (A5)            ;Sourcetextende?
                bmi     such_loop12     ;Ja! => raus
                movem.l A3/A5-A6,-(SP)
                movem.l D1-A6,-(SP)
                pea     zreserve+2(A4)
                cmpi.b  #';',such_puffer(A4) ;beginnt der Patternstring mit ';',
                beq.s   such_loop4      ;so werden nur die Remarks durchsucht
such_loop41:    bsr     disass          ;Zeile disassemblieren
                clr.b   (A0)            ;Nullbyte als Abschluß
such_loop5:     btst    #0,suchend+1(PC)
                beq.s   such_loop3      ;keine groß/klein Unterscheidung
                moveq   #0,D1
                lea     zreserve+2(A4),A0
                lea     upper_tab,A1
such_loop1:     move.b  (A0),D1         ;Zeile in groß wandeln
                move.b  0(A1,D1.w),(A0)+
                bne.s   such_loop1
such_loop3:     cmpi.b  #' ',-(A0)
                beq.s   such_loop3
                addq.l  #1,A0
                clr.b   (A0)+           ;Endekennung
                clr.b   1(A0)
                move.l  A0,D0
                addq.l  #4,SP
                movem.l (SP)+,D1-A6
                lea     such_puffer(A4),A5 ;A5 - Zeiger auf den Patternstring
                lea     zreserve+2(A4),A6 ;hier steht der disassemblierte Code
                lea     0(A6,D1.w),A6
                cmpa.l  D0,A6
                bgt     such_loop2      ;über das Ende der Zeile hinaus
                tst.b   (A6)
                beq     such_loop2      ;am Ende der Zeile
                bsr     match
                tst.w   D0
                beq     such_loop2      ;Nicht drin enthalten
                move.w  D2,such_zeiger(A4) ;Zeilenummer merken
                move.l  A3,D1
                sub.l   A4,D1
                subi.w  #zreserve+2,D1  ;Position berechnen
                movem.l (SP)+,A3/A5-A6
                move.b  such_puffer(A4),D0
                tst.b   repl_flag(A4)
                bmi.s   such_loop71     ;Remarksuche war nicht erlaubt
                cmp.b   #';',D0
                beq.s   such_loop7      ;war Remarksuche
such_loop71:    moveq   #0,D0
                rts
such_loop7:     tst.l   (A5)
                bne.s   such_loop8      ;Befehl in Zeile
                tst.w   6(A5)
                bpl.s   such_loop83     ;Symbol in Zeile
                addq.w  #1,D1
                moveq   #0,D0
                rts
such_loop8:     bsr.s   such_loop81
                cmpi.b  #2,2(A5)
                bge.s   such_loop82     ;Pseudoopcode
                adda.w  tabs+4(A4),A0   ;Remarktab
such_loop9:     move.b  (A0)+,D0
                cmp.b   #';',D0
                beq.s   such_loop10
                cmp.b   #'*',D0
                bne.s   such_loop9
such_loop10:    move.l  A0,D0
                sub.l   A4,D0
                subi.w  #zreserve+2,D0
                add.w   D0,D1
                moveq   #0,D0
                rts
such_loop82:    adda.w  tabs+8(A4),A0
                bra.s   such_loop9
such_loop83:    adda.w  tabs(A4),A0
                bra.s   such_loop9
such_loop81:    movem.l D1-A6,-(SP)
                pea     zreserve+2(A4)
                bsr     disass
                clr.b   (A0)
                addq.l  #4,SP
                movem.l (SP)+,D1-A6
                lea     zreserve+2(A4),A0
                rts
such_loop2:     movem.l (SP)+,A3/A5-A6
such_loop02:    moveq   #0,D1
                moveq   #0,D0
                move.b  9(A5),D0
                adda.w  D0,A3           ;Remarks eine Zeile weiter
                adda.w  (A5),A6         ;Codepnt eine Zeile weiter
                lea     10(A5),A5       ;Zeileninfopnt eine Zeile weiter
                addq.w  #1,D2
                cmp.w   D5,D2
                beq.s   such_loop12     ;einmal durch
                btst    #0,maustast(A4) ;rechte Maustaste
                bne.s   such_loop141    ;Abbruch
                btst    #4,maustast(A4) ;Dauerklick rechts
                bne.s   such_loop141    ;Abbruch
                cmp.w   such_zeiger+4(A4),D2 ;Ende erreicht?
                bne     such_loop0      ;nein, weiter suchen
                btst    #0,s_edt05+1(PC) ;'von vorne' ?
                beq.s   such_loop13     ;nein
                moveq   #0,D2
                btst    #0,suchenc+1(PC) ;'Block'
                bne.s   such_loop12     ;ja
                cmp.w   D5,D2
                beq.s   such_loop12     ;einmal durch
                move.w  D2,D0
                bsr     calc_pointer
                bra     such_loop0      ;weiter suchen
such_loop13:    move.w  D5,D2
                btst    #0,s_edt06+1(PC) ;'letzte Zeile' ?
                beq.s   such_loop12     ;nein
                move.w  anz_zeilen(A4),D2
                btst    #0,suchenc+1(PC) ;'Block'
                beq.s   such_loop12     ;nein
                move.w  block_end(A4),D2
such_loop12:    moveq   #-1,D0          ;nichts gefunden
                rts
such_loop141:   moveq   #-2,D0          ;Abbruch durch Maustaste
                rts

************************************************************************
* match(what,how,where,all,one) - Universelle Suchfunktion mit Jokern  *
* match(->A6,->A5,<-A3,D7,D6)                                          *
* D0=0, wenn nicht gefunden                                            *
************************************************************************
match:          movem.l D1-D2/A0/A5-A6,-(SP)
                movea.l A6,A3
match_loop1:    move.b  (A5)+,D2
                beq.s   match_yeah_l    ;Ende des how-Strings => nix gefunden
                cmp.b   D6,D2
                beq.s   match_loop1     ;Existenzquantoren und
                cmp.b   D7,D2           ;Allquantoren am Anfang überlesen
                beq.s   match_loop1
match_jump2:    movea.l A5,A0           ;Zeiger auf den Anfang zurück
                movea.l A3,A6
match_loop2:    move.b  (A6)+,D1        ;Ende des Strings erreicht?
                beq.s   match_not       ;dann nichts gefunden
                cmp.b   D2,D1           ;erstes gleiches Zeichen gefunden?
                bne.s   match_loop2     ;sonst weitersuchen ...
                movea.l A6,A3           ;akt.Position merken
match_loop3:    move.b  (A0)+,D0
                beq.s   match_yeah      ;Ende des how-Strings => gefunden !!
                move.b  (A6)+,D1
                beq.s   match_jump3     ;Ende des Strings
                cmp.b   D6,D0           ;Existenzquantor ignorieren
                beq.s   match_loop3
                cmp.b   D7,D0
                beq.s   match_jump1     ;Allquantorsuche
                cmp.b   D0,D1           ;Zeichen gleich?
                bne.s   match_jump2     ;Nochmal suchen, wenn nicht
                bra.s   match_loop3
match_jump3:    cmp.b   D7,D0           ;Kein Allquantor?
                bne.s   match_not       ;=> Nix gefunden
                tst.b   (A0)            ;Folgen noch Suchzeichen?
                bne.s   match_not       ;dann nicht gefunden
                bra.s   match_yeah      ;sonst doch gefunden
match_jump1:    move.b  (A0)+,D0        ;Allquantor-Suche
                beq.s   match_yeah      ;how-Stringende = gefunden
                cmp.b   D7,D0           ;mehrere Allquantoren ignorieren
                beq.s   match_jump1
                tst.b   (A6)            ;String zuende?
                beq.s   match_jump2     ;Stringende = nicht gefunden
match_loop4:    cmp.b   D0,D1           ;Zeichen gleich?
                beq.s   match_loop3     ;Ja, weiter suchen
                move.b  (A6)+,D1        ;nächstes Zeichen holen
                bne.s   match_loop4     ;String noch nicht zuende => weiter suchen
                bra.s   match_jump2     ;Stringende, weiter geht's

match_yeah_l:   moveq   #1,D0           ;Zeile gefunden!
                bra.s   match_end
match_yeah:     moveq   #-1,D0          ;Gefunden!
                subq.l  #1,A3           ;ab hier wurde der String gefunden
                bra.s   match_end
match_not:      moveq   #0,D0           ;Nicht gefunden
match_end:      movem.l (SP)+,D1-D2/A0/A5-A6
                rts

************************************************************************
* ASCII-Replace                                                        *
************************************************************************
s_replacea:     tst.b   s_left_right(A4)
                bne.s   s_replacea0     ;rechte Maustaste -> ASCII ersetzen
                jmp     s_replace3      ;Symbol ersetzen
s_replacea0:    lea     replacea(PC),A0 ;Flags des 'Anfang'-Buttons
                andi.w  #$FFFE,(A0)     ;Buttons deselekten
                andi.w  #$FFFE,10(A0)
                andi.w  #$FFEF,20(A0)   ;'Block'-Button enablen
                ori.w   #1,20(A0)       ;'Block'-Button selekten
                tst.b   block_fl(A4)    ;Block markiert?
                bne.s   s_replacea01    ;ja
                andi.w  #$FFFE,20(A0)   ;'Block'-Button deselekten
                ori.w   #$10,20(A0)     ;'Block'-Button disablen
                ori.w   #1,10(A0)       ;'Cursor' selektieren
s_replacea01:   lea     replacea_rsc(PC),A0
                bsr     _form_do
                subq.w  #1,D0
                bne     s_jmp_main      ;Abbruch
                move.b  replaced+1(PC),suchend+1 ;groß/klein-Flag kopieren
                move.b  replacede+1(PC),suchende+1
                move.b  replacec+1(PC),suchenc+1
                lea     replacea_1+31(PC),A0
                moveq   #30,D0
s_replacea1:    cmpi.b  #' ',-(A0)
                dbne    D0,s_replacea1
                tst.w   D0              ;Patternstring=0
                bmi     s_jmp_main
                move.b  alquantor(PC),D1
                cmp.b   (A0),D1         ;endet Suchstring mit '*'
                seq     al_flag(A4)     ;dann setzen
                lea     replacea_1(PC),A0
                lea     such_puffer(A4),A1
                btst    #0,replaced+1(PC)
                beq.s   s_replacea3     ;groß/klein Unterscheidung
                moveq   #0,D1
                lea     upper_tab,A2
s_replacea2:    move.b  (A0)+,D1        ;Patternstring kopieren
                move.b  0(A2,D1.w),(A1)+ ;Zeichen in groß wandeln
                dbra    D0,s_replacea2
                clr.b   (A1)
                bra.s   s_replacea41
s_replacea3:    move.b  (A0)+,(A1)+
                dbra    D0,s_replacea3
                clr.b   (A1)
s_replacea41:   lea     replacea_14+31(PC),A0
                lea     such_puffer2(A4),A1
                moveq   #30,D0
s_replacea11:   cmpi.b  #' ',-(A0)
                dbne    D0,s_replacea11
                tst.w   D0              ;Zielpatternstring=0
                bmi.s   s_replacea32    ;ja
                lea     replacea_14(PC),A0
s_replacea31:   move.b  (A0)+,(A1)+
                dbra    D0,s_replacea31
s_replacea32:   clr.b   (A1)
                tst.b   such_puffer(A4) ;kein Patternstring
                beq     s_jmp_main
                moveq   #2,D0
                bsr     _graf_mouse     ;Sanduhr...
                clr.l   such_zeiger(A4)
                clr.w   s_zeile(A4)
                move.w  anz_zeilen(A4),such_zeiger+4(A4)
                btst    #0,replacea+1(PC) ;'Anfang'
                bne.s   s_replacea6     ;ja
                move.w  D6,such_zeiger(A4)
                move.w  D6,such_zeiger+4(A4)
                move.w  D6,s_zeile(A4)
                move.w  save_pos(A4),such_zeiger+2(A4)
                btst    #0,replaceb+1(PC) ;'Cursor'
                bne.s   s_replacea6     ;ja
                tst.b   block_fl(A4)
                beq     s_jmp_main      ;kein Block definiert
                move.w  block_end(A4),such_zeiger+4(A4)
                move.w  block_anf(A4),such_zeiger(A4)
                move.w  block_anf(A4),s_zeile(A4)
                clr.w   such_zeiger+2(A4)
                bra.s   s_replacea6
s_replacea4:    move.w  save_pos(A4),such_zeiger+2(A4)
                move.w  D6,such_zeiger(A4)
s_replacea6:    move.w  such_zeiger(A4),D2 ;Startzeile
                movem.l D3-D7/A3/A5-A6,-(SP)
                st      repl_flag(A4)   ;Remarksuche nicht erlaubt
                move.w  D2,D0
                bsr     calc_pointer
                move.b  exquantor(PC),D6 ;'?'-Joker
                move.b  alquantor(PC),D7 ;'*'-Joker
                move.w  such_zeiger+2(A4),D1 ;Position
                bsr     such_loop       ;Zeilen durchsuchen
                movem.l (SP)+,D3-D7/A3/A5-A6
                tst.w   D0
                bmi     s_replacea7     ;nichts gefunden
                move.w  D2,such_zeiger(A4) ;Zeile
                move.w  D1,such_zeiger+2(A4)
                move.w  D1,save_pos(A4)
                move.w  D1,spalte(A4)
                moveq   #0,D0
                cmp.w   #5,D2
                bls.s   s_replacea8
                move.w  D2,D0
                subq.w  #5,D0
s_replacea8:    move.w  D0,top_line(A4)
                bsr     calc_pointerx   ;topline bestimmen
                movem.l A3/A5-A6,top_ptr(A4)
                btst    #0,replacee+1(PC) ;'alle'
                bne.s   s_replacea800   ;ja
                bsr     update_screenb  ;Bildschrim aufbauen
s_replacea800:  move.w  D6,letzte_zeile(A4)
                move.w  D2,D6           ;Zeilennummer
                move.w  D2,D0
                bsr     calc_pointer    ;Zeiger auf ak.Zeile berechnen
                movem.l D0-D7/A1-A6,-(SP)
                pea     zeingabe+2(A4)  ;Buffer setzen
                bsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP           ;Stack korregieren
                clr.b   (A0)
                movem.l (SP)+,D0-D7/A1-A6
                move.w  D2,D0
                sub.w   top_line(A4),D0
                move.w  D0,scr_z(A4)
                move.w  D0,zeile(A4)
                btst    #0,replacee+1(PC) ;'alle'
                bne.s   s_replace88     ;ja, kein Abfrage-Alert
                bsr     flash_cursor
                moveq   #0,D0
                bsr     _graf_mouse
                lea     rep_rsc(PC),A0
                bsr     _form_do        ;Abfrage-Alert ausgeben
                bmi     s_replacea71    ;UNDO = ABBRUCH
                cmp.w   #3,D0           ;ABBRUCH
                beq     s_replacea71
                cmp.w   #2,D0
                beq     s_replacea87    ;weiter
s_replace88:    moveq   #0,D1
                move.w  save_pos(A4),D2
                lea     such_puffer(A4),A0 ;Zeiger auf Suchstring
                bsr     s_replacea9     ;Anzahl der Zeichen bestimmen (D0)
                lea     zeingabe+2(A4),A1 ;disassemblierte Zeile
                lea     0(A1,D2.w),A1
                movea.l A1,A0           ;Zeiger auf gefundenen Begriff
s_replacea81:   move.b  0(A0,D0.w),(A0)+ ;gefundenes Wort herausschneiden
                bne.s   s_replacea81
                lea     such_puffer2(A4),A0 ;Zeiger auf Ersatzstring
                bsr     s_replacea9     ;Anzahl der Zeichen bestimmen (D0)
                tst.w   D0
                beq.s   s_replacea85
                lea     zeingabe+256(A4),A0
                move.w  #253,D1
                suba.w  D0,A0
                sub.w   D0,D1
                sub.w   D2,D1
s_replacea82:   move.b  -(A0),0(A0,D0.w) ;Zeichen aufschieben
                dbra    D1,s_replacea82
                lea     such_puffer2(A4),A0 ;Zeiger auf Ersatzstring
                move.b  alquantor(PC),D1
s_replacea83:   cmp.b   (A0)+,D1
                beq.s   s_replacea83    ;Sterne am Anfang entfernen
                subq.l  #1,A0
                subq.w  #1,D0
s_replacea84:   move.b  (A0)+,(A1)+     ;Ersatzstring kopieren
                dbra    D0,s_replacea84
s_replacea85:   tst.b   al_flag(A4)     ;endet Suchstring mit '*'
                beq.s   s_replacea86    ;ja
                clr.b   (A1)            ;nein dann Rest der Zeile löschen
s_replacea86:   move.b  #1,load_fl(A4)  ;kein Abfang von 'doppelter Deklaration'
                bsr     code_line       ;Zeile tokenisieren
                sf      load_fl(A4)     ;Flag auf normal
                tst.w   D0              ;Fehlernummer
                bne.s   s_replacea71    ;Fehler aufgetreten
                lea     zeingabe+2(A4),A0 ;Zeiger auf Zeile
                suba.l  A0,A1           ;Position hinter dem ersetzten Wort
                move.w  A1,save_pos(A4) ;als neue Suchposition
                lea     op_buffer(A4),A2 ;assemblierte Zeile
                jsr     change_line     ;ins Programm übernehmen
                bra     s_replacea4
s_replacea87:   moveq   #2,D0
                bsr     _graf_mouse
                addq.w  #1,save_pos(A4)
                bra     s_replacea4
s_replacea7:    move.w  D2,D6
s_replacea71:   bsr     jump_line       ;Zeile anspringen
                moveq   #0,D0
                bsr     _graf_mouse
                st      change_flag(A4) ;Sourcetext geändert
                bra     s_jmp_main
s_replacea9:    move.l  D1,-(SP)        ;Länge des Stings in A0 bestimmen
                moveq   #0,D0
                move.b  alquantor(PC),D1
s_replacea91:   cmp.b   (A0)+,D1        ;Sterne überlesen
                beq.s   s_replacea91
                subq.l  #1,A0
s_replacea93:   tst.b   (A0)
                beq.s   s_replacea92
                cmp.b   (A0),D1
                beq.s   s_replacea92
                addq.w  #1,D0
                addq.l  #1,A0
                bra.s   s_replacea93
s_replacea92:   move.l  (SP)+,D1
                rts

replacea_rsc:   DC.W 0,0,33,17,1
                DC.W 4,1
                DC.L replacea_0
                DC.W 8
                DC.W 1,3
                DC.L replacea_1
                DC.W $88
                DC.W 1,5
                DC.L replacea_14
                DC.W $88
                DC.W 4,15
                DC.L ok_button
                DC.W $26
                DC.W 20,15
                DC.L abbruch_button
                DC.W $24
                DC.W 1,11
                DC.L replacea_4
replacea:       DC.W $44
                DC.W 12,11
                DC.L replacea_5
replaceb:       DC.W $45
                DC.W 23,11
                DC.L replacea_6
replacec:       DC.W $44
                DC.W 1,7
                DC.L replacea_7
                DC.W 8
                DC.W 15,7
                DC.L replacea_8
                DC.W 8
                DC.W 12,7
                DC.L alquantor
                DC.W $88
                DC.W 31,7
                DC.L exquantor
                DC.W $88
                DC.W 1,9
                DC.L replacea_11
                DC.W 8
                DC.W 15,9
                DC.L ja_button
replaced:       DC.W $0144
                DC.W 23,9
                DC.L nein_button
replacede:      DC.W $0145
                DC.W 1,13
                DC.L replacea_15
                DC.W 8
                DC.W 10,13
                DC.L replacea_16
replacee:       DC.W $0245
                DC.W 19,13
                DC.L replacea_17
                DC.W $0244
                DC.W -1

rep_rsc:        DC.W 0,0,33,3,1
                DC.W 1,1
                DC.L rep_0
                DC.W $26
                DC.W 13,1
                DC.L rep_1
                DC.W $24
                DC.W 23,1
                DC.L rep_2
                DC.W $24
                DC.W -1

replacea_14:    DC.B $FF,'123456789012345678901234567890',0
replacea_1:     DC.B $FF,'123456789012345678901234567890',0
                SWITCH sprache
                CASE 0
replacea_0:     DC.B 'Text suchen und ersetzen',0
replacea_4:     DC.B ' Anfang ',0
replacea_5:     DC.B ' Cursor ',0
replacea_6:     DC.B ' Block ',0
replacea_7:     DC.B 'Allquantor',0
replacea_8:     DC.B 'Existenzquantor',0
replacea_11:    DC.B 'Groß=klein',0
replacea_15:    DC.B 'Anzahl',0
replacea_16:    DC.B ' alle ',0
replacea_17:    DC.B ' wahlweise ',0

rep_0:          DC.B ' Ersetzen ',0
rep_1:          DC.B ' Weiter ',0
rep_2:          DC.B ' Abbruch ',0
                CASE 1
replacea_0:     DC.B 'Search for text and replace',0
replacea_4:     DC.B ' Begin ',0
replacea_5:     DC.B ' Cursor ',0
replacea_6:     DC.B ' Block ',0
replacea_7:     DC.B 'Allquantor',0
replacea_8:     DC.B 'Existenzquantor',0
replacea_11:    DC.B 'great=small',0
replacea_15:    DC.B 'Replace',0
replacea_16:    DC.B ' all ',0
replacea_17:    DC.B ' choosing ',0

rep_0:          DC.B ' Replace ',0
rep_1:          DC.B ' Next ',0
rep_2:          DC.B ' Cancel ',0
                ENDS
                EVEN
                ENDPART
                >PART 'Menü: Einstellungen'
************************************************************************
* Menüpunkt 'Editor2'                                                  *
************************************************************************
s_editor201:    andi.w  #$FFFE,10(A0)
                ori.w   #1,(A0)
                tst.b   D0
                bne.s   s_editor202
                ori.w   #1,10(A0)
                andi.w  #$FFFE,(A0)
s_editor202:    rts

s_editor_2:     lea     spezial_re(PC),A0 ;Autokonfig
                move.b  autoconfig_flag(A4),D0
                bsr.s   s_editor201     ;Buttons setzen
                lea     spezial_rc(PC),A0
                andi.w  #$FFFE,(A0)
                ori.w   #1,10(A0)
                tst.b   bak_flag(A4)    ;BAK-Datei erzeugen
                bne.s   s_editor_22
                ori.w   #1,(A0)
                andi.w  #$FFFE,10(A0)
s_editor_22:    lea     spezial_ra(PC),A0
                andi.w  #$FFFE,(A0)
                ori.w   #1,10(A0)
                btst    #0,conterm+1(A4) ;Tastaturklick
                beq.s   s_editor_23
                andi.w  #$FFFE,10(A0)
                ori.w   #1,(A0)
s_editor_23:    lea     spezial_rd(PC),A0
                move.w  #$FFFE,D0
                and.w   D0,(A0)
                and.w   D0,10(A0)
                and.w   D0,20(A0)
                moveq   #3,D0
                and.b   start_flag(A4),D0
                cmp.w   #3,D0
                bne.s   s_editor_24
                subq.w  #1,D0
s_editor_24:    move.b  D0,spez_flag(A4)
                mulu    #10,D0
                ori.w   #1,0(A0,D0.w)
                lea     spezial_rb(PC),A0
                move.w  #$FFFE,D0
                and.w   D0,(A0)
                and.w   D0,10(A0)
                and.w   D0,20(A0)
                moveq   #0,D0
                move.b  upper_flag(A4),D0
                addq.b  #1,D0
                mulu    #10,D0
                ori.w   #1,0(A0,D0.w)
                lea     spezial_rsc(PC),A0
                move.l  spezial_11(PC),D1 ;Extension holen
                bsr     _form_do
                subq.w  #1,D0
                ble     s_editor_213    ;UNDO bzw. ABBRUCH
                lea     spezial_rb(PC),A0
                moveq   #0,D0
                btst    #0,11(A0)
                bne.s   s_editor_25
                moveq   #1,D0
                btst    #0,21(A0)
                bne.s   s_editor_25
                moveq   #-1,D0
s_editor_25:    cmp.b   upper_flag(A4),D0
                beq.s   s_editor_27
                tst.w   label_top_ind(A4)
                beq.s   s_editor_26
                move.w  D0,-(SP)
                lea     spezial2_rsc(PC),A0
                bsr     _form_do        ;Dialogbox ausführen
                move.w  (SP)+,D0
s_editor_26:    move.b  D0,upper_flag(A4)
s_editor_27:    btst    #0,spezial_rc+1(PC)
                seq     bak_flag(A4)
                andi.w  #$FFFE,conterm(A4)
                btst    #0,spezial_ra+1(PC)
                beq.s   s_editor_28
                ori.w   #1,conterm(A4)
s_editor_28:    btst    #0,spezial_re+1(PC)
                sne     D0
                move.b  D0,autoconfig_flag(A4)
                move.b  #$80,start_flag(A4)
                btst    #0,spezial_rd+1(PC)
                bne.s   s_editor_210
                ori.b   #1,start_flag(A4)
                btst    #0,spezial_rd+11(PC)
                bne.s   s_editor_29
                ori.b   #3,start_flag(A4)
s_editor_29:    move.b  start_flag(A4),D0
                cmp.b   spez_flag(A4),D0
                beq.s   s_editor_210
                move.w  #10,asm_default(A4) ;der Debugger ist Default
s_editor_210:   lea     spezial_11(PC),A1
                lea     upper_tab,A0
                moveq   #0,D0
                move.l  (A1),D1
                move.l  #$20202000,(A1)
s_editor_211:   rol.l   #8,D1
                move.b  D1,D0
                move.b  0(A0,D0.w),D0
                beq.s   s_editor_212
                cmp.b   #' ',D0
                beq.s   s_editor_211
                move.b  D0,(A1)+
                bra.s   s_editor_211
s_editor_212:   jmp     edit08

s_editor_213:   lea     spezial_11(PC),A1 ;bei ABBRUCH Extension
                move.l  D1,(A1)         ;rekonstruieren
                bra.s   s_editor_212

s_save_inf:     moveq   #1,D0           ;Einstellungen sichern
                bsr     _graf_mouse
                bsr     do_mediach      ;Media-Change wenn nötig
                lea     dbuffer(A4),A0
                move.l  #'∑ASM',(A0)
                addq.l  #6,A0
                moveq   #(s_suchzeichen+1-tabs)/2,D0
                move.w  D0,D1
                subq.w  #1,D0
                lea     tabs(A4),A1
s_save_inf1:    move.w  (A1)+,(A0)+
                dbra    D0,s_save_inf1
                moveq   #(screen_delay+4-bak_flag)/2,D0
                add.w   D0,D1
                subq.w  #1,D0
                lea     bak_flag(A4),A1
s_save_inf2:    move.w  (A1)+,(A0)+
                dbra    D0,s_save_inf2
                lea     spezial_11(PC),A1
                move.l  (A1)+,(A0)+     ;Default-Extension
                move.b  alquantor(PC),(A0)+ ;'*'-Joker
                move.b  exquantor(PC),(A0)+ ;'?'-Joker
                addq.w  #8,D1
                move.w  #(tmacro_tab_end-tmacro_tab)/4,D0
                add.w   D0,D1
                subq.w  #1,D0
                lea     tmacro_tab(A4),A1 ;Tastaturmakros speichern
s_save_inf3:    move.l  (A1)+,(A0)+
                dbra    D0,s_save_inf3
                move.b  start_flag(A4),(A0)+
                move.b  debugger_da(A4),(A0)+
                lea     fpath_src(A4),A1 ;Sourcepfad
s_save_inf4:    move.b  (A1)+,(A0)+     ;übertragen
                bne.s   s_save_inf4
                move.w  D1,dbuffer+4(A4) ;Länge merken
                clr.w   -(SP)
                pea     fpath_inf(A4)
                move.w  #$3C,-(SP)      ;Fcreate
                bsr     do_trap_1
                addq.l  #8,SP
                move.w  D0,fhandle(A4)
                bmi.s   s_save_inf6     ;=> Fehler beim Erstellen
                move.l  A0,D1
                lea     dbuffer(A4),A0
                sub.l   A0,D1
                move.l  A0,-(SP)
                move.l  D1,-(SP)
                move.w  fhandle(A4),-(SP)
                move.w  #$40,-(SP)      ;Fwrite
                bsr     do_trap_1
                lea     12(SP),SP
                cmp.l   D1,D0
                beq.s   s_save_inf5     ;alles ok =>
                bsr     fclose
                pea     fpath_inf(A4)
                move.w  #$41,-(SP)      ;Fdelete
                bsr     do_trap_1
                addq.l  #6,SP
                bra.s   s_save_inf6
s_save_inf5:    bsr     fclose
s_save_inf6:    moveq   #0,D0
                bsr     _graf_mouse
                jmp     main_loop

s_kill_file:    lea     fpath_temp(A4),A0 ;Datei löschen
                lea     fname_temp(A4),A1
                clr.b   (A1)            ;Namen löschen
                lea     s_del_txt(PC),A2 ;Header für Exfsel_input()
                move.l  A1,killa
                moveq   #0,D0           ;eine Extension vorgegeben
                bsr     _fsel_input
                bmi.s   s_kill_file1
                tst.w   D7              ;ABBRUCH
                beq.s   s_kill_file1
                lea     kill_rsc(PC),A0
                bsr     _form_do        ;Sicherheitsabfrage
                subq.w  #1,D0
                bne.s   s_kill_file1
                pea     fname_temp(A4)
                move.w  #$41,-(SP)
                bsr     do_trap_1       ;Fdelete
                addq.l  #6,SP
s_kill_file1:   jmp     main_loop

spezial_rsc:    DC.W 0,0,46,17,1
                DC.W 25,15
                DC.L abbruch_button
                DC.W $24
                DC.W 12,15
                DC.L ok_button
                DC.W $26
                DC.W 1,13
                DC.L spezial_12
                DC.W 8
                DC.W 1,1
                DC.L spezial_0
                DC.W 8
                DC.W 20,1
                DC.L ja_button
spezial_rc:     DC.W $44
                DC.W 29,1
                DC.L nein_button
                DC.W $45
                DC.W 1,3
                DC.L spezial_3
                DC.W 8
                DC.W 20,3
                DC.L ja_button
spezial_ra:     DC.W $0144
                DC.W 29,3
                DC.L nein_button
                DC.W $0145
                DC.W 1,5
                DC.L spezial_6
                DC.W 8
                DC.W 28,5
                DC.L spezial_8
spezial_rb:     DC.W $0244
                DC.W 37,5
                DC.L spezial_9
                DC.W $0245
                DC.W 20,5
                DC.L spezial_7
                DC.W $0244
                DC.W 1,11
                DC.L spezial_10
                DC.W 8
                DC.W 30,11
                DC.L spezial_11
                DC.W $88
                DC.W 1,7
                DC.L spezial_4
                DC.W 8
                DC.W 2,9
                DC.L spezial_5
spezial_rd:     DC.W $0345
                DC.W 13,9
                DC.L spezial_51
                DC.W $0344
                DC.W 25,9
                DC.L spezial_52
                DC.W $0344
                DC.W 26,13
                DC.L ja_button
spezial_re:     DC.W $0445
                DC.W 35,13
                DC.L nein_button
                DC.W $0444
                DC.W -1

spezial_11:     DC.B 'S  ',0
                SWITCH sprache
                CASE 0
spezial_0:      DC.B 'Sicherheitskopie',0
spezial_3:      DC.B 'Tastaturklick',0
spezial_4:      DC.B 'Sprung in den Debugger',0
spezial_5:      DC.B ' nichts ',0
spezial_51:     DC.B ' starten ',0
spezial_52:     DC.B ' starten & zurück ',0
spezial_6:      DC.B 'Symbolnamen',0
spezial_7:      DC.B ' groß ',0
spezial_8:      DC.B ' klein ',0
spezial_9:      DC.B ' beides ',0
spezial_10:     DC.B 'Extension für ASCII-Sourcen',0
spezial_12:     DC.B 'Autokonfig. beim Laden',0
s_del_txt:      DC.B 'DATEI LÖSCHEN',0
                CASE 1
spezial_0:      DC.B 'Backup',0
spezial_3:      DC.B 'Keyclick',0
spezial_4:      DC.B 'Jump into debugger',0
spezial_5:      DC.B ' nothing ',0
spezial_51:     DC.B ' start ',0
spezial_52:     DC.B ' start & return ',0
spezial_6:      DC.B 'Symbolnames',0
spezial_7:      DC.B ' caps ',0
spezial_8:      DC.B ' small ',0
spezial_9:      DC.B ' both ',0
spezial_10:     DC.B 'Extension for ASCII-Sources',0
spezial_12:     DC.B 'Autoconfig by loading',0
s_del_txt:      DC.B 'ERASE FILE',0
                ENDS
                EVEN
                SWITCH sprache
                CASE 0
spezial2_rsc:   DC.W 0,0,41,8,1
                DC.W 16,1
                DC.L spezial2_0
                DC.W 8
                DC.W 1,3
                DC.L spezial2_1
                DC.W 8
                DC.W 1,4
                DC.L spezial2_2
                DC.W 8
                DC.W 18,6
                DC.L ok_button
                DC.W $26
                DC.W -1
                CASE 1
spezial2_rsc:   DC.W 0,0,27,8,1
                DC.W 8,1
                DC.L spezial2_0
                DC.W 8
                DC.W 1,3
                DC.L spezial2_1
                DC.W 8
                DC.W 1,4
                DC.L spezial2_2
                DC.W 8
                DC.W 9,6
                DC.L ok_button
                DC.W $26
                DC.W -1
                ENDS
kill_rsc:       DC.W 0,0,27,6,1
                DC.W 7,1
                DC.L kill_0
                DC.W 8
                SWITCH sprache
                CASE 0
                DC.W 14,1
                CASE 1
                DC.W 14,2
                ENDS
killa:          DC.L 0
                DC.W 8
                DC.W 7,2
                DC.L kill_2
                DC.W 8
                DC.W 3,4
                DC.L ok_button
                DC.W $26
                DC.W 15,4
                DC.L abbruch_button
                DC.W $24
                DC.W 2,1
                DC.L ask_icn
                DC.W $3303
                DC.W -1

                SWITCH sprache
                CASE 0
kill_0:         DC.B 'Datei',0
kill_2:         DC.B 'wirklich löschen?',0

spezial2_0:     DC.B 'Achtung!',0
spezial2_1:     DC.B 'Es werden nur die ab jetzt eingebenen',0
spezial2_2:     DC.B 'oder hinzugeladenen Zeilen konvertiert.',0
                CASE 1
kill_0:         DC.B 'Sure to kill the',0
kill_2:         DC.B 'file:',0

spezial2_0:     DC.B 'Attention!',0
spezial2_1:     DC.B 'Only lines that added now',0
spezial2_2:     DC.B 'are converted.',0
                ENDS
                EVEN

************************************************************************
* Editor 3 Menü                                                        *
************************************************************************
s_editor_3:     movem.l D0-D1/A1,-(SP)
                lea     editor3_but(PC),A0
                moveq   #0,D1
                move.b  editor3_flag(A4),D1
                moveq   #4,D0           ;Anzahl der Bits
s_editor_31:    bsr.s   s_editor_37     ;Radio-Buttonpaar setzen
                lea     20(A0),A0
                lsr.w   #1,D1           ;nächstes Bit
                dbra    D0,s_editor_31
                move.w  #$FFFE,D0
                and.w   D0,(A0)
                and.w   D0,10(A0)       ;alle drei Buttons deselekten
                and.w   D0,20(A0)
                mulu    #10,D1
                ori.w   #1,0(A0,D1.w)   ;Button setzen
                lea     editor3_rsc(PC),A0
                bsr     _form_do
                subq.w  #1,D0
                ble.s   s_editor_36     ;ABBRUCH
                lea     editor3_but+1(PC),A0
                moveq   #0,D1
                moveq   #0,D0           ;Bitnummer
s_editor_33:    btst    #0,(A0)         ;Button testen
                beq.s   s_editor_34     ;JA nicht selektiert
                bset    D0,D1
s_editor_34:    lea     20(A0),A0       ;zwei Buttons weiter
                addq.w  #1,D0
                cmp.w   #5,D0
                blt.s   s_editor_33
                btst    #0,(A0)
                bne.s   s_editor_35     ;Ziffern
                bset    #5,D1
                btst    #0,10(A0)
                bne.s   s_editor_35     ;Cursor
                bclr    #5,D1
                bset    #6,D1
s_editor_35:    move.b  D1,editor3_flag(A4)
s_editor_36:    movem.l (SP)+,D0-D1/A1
                bra     s_jmp_main

s_editor_37:    ori.w   #1,(A0)
                andi.w  #$FFFE,10(A0)
                btst    #0,D1
                bne.s   s_editor_38
                andi.w  #$FFFE,(A0)
                ori.w   #1,10(A0)
s_editor_38:    rts

editor3_rsc:    DC.W 0,0,46,15,1
                DC.W 2,5
                DC.L editor3_0
                DC.W $08
                DC.W 2,11
                DC.L editor3_1
                DC.W $08
                DC.W 2,1
                DC.L editor3_2
                DC.W $08
                DC.W 2,3
                DC.L editor3_3
                DC.W $08
                DC.W 2,7
                DC.L editor3_4
                DC.W $08
                DC.W 2,9
                DC.L editor3_5
                DC.W $08
                DC.W 13,13
                DC.L abbruch_button
                DC.W $24
                DC.W 3,13
                DC.L ok_button
                DC.W $26
                DC.W 27,1
                DC.L ja_button
editor3_but:    DC.W $44
                DC.W 34,1
                DC.L nein_button
                DC.W $44
                DC.W 27,3
                DC.L ja_button
                DC.W $0144
                DC.W 34,3
                DC.L nein_button
                DC.W $0144
                DC.W 27,5
                DC.L ja_button
                DC.W $0244
                DC.W 34,5
                DC.L nein_button
                DC.W $0244
                DC.W 27,7
                DC.L ja_button
                DC.W $0344
                DC.W 34,7
                DC.L nein_button
                DC.W $0344
                DC.W 27,9       ;Mac Trap-Makros
                DC.L ja_button
                DC.W $0444
                DC.W 34,9
                DC.L nein_button
                DC.W $0444
                DC.W 27,11
                DC.L editor3_22
                DC.W $0644
                DC.W 37,11
                DC.L editor3_21
                DC.W $0644
                DC.W 31,13
                DC.L editor3_23
                DC.W $0644
                DC.W -1

                SWITCH sprache
                CASE 0
editor3_0:      DC.B 'ASCII-Tabs expandieren',0
editor3_1:      DC.B 'Zehnerblockbelegung',0
editor3_2:      DC.B 'MIDI-Tastaturabfrage',0
editor3_3:      DC.B 'Debugger nachladen',0
editor3_4:      DC.B 'Überschreiben-Alert',0
editor3_5:      DC.B 'Macintosh Trap-Makros',0
editor3_21:     DC.B ' Cursor ',0
editor3_22:     DC.B ' Ziffern ',0
editor3_23:     DC.B ' Hexzahlen ',0
                CASE 1
editor3_0:      DC.B 'Expand ASCII-Tabs',0
editor3_1:      DC.B 'Numberblock',0
editor3_2:      DC.B 'MIDI-Keyboard',0
editor3_3:      DC.B 'Load debugger',0
editor3_4:      DC.B 'Overwrite-Alert',0
editor3_5:      DC.B 'Macintosh trap macros',0
editor3_21:     DC.B ' Cursor ',0
editor3_22:     DC.B ' Numbers ',0
editor3_23:     DC.B ' Hexnumbers ',0
                ENDS
                EVEN
                ENDPART
                >PART 'Optimierungs-Dialog'
************************************************************************
* Optimierungs-Dialog                                                  *
************************************************************************
s_optim:        movem.l D0-D1/A0,-(SP)
                lea     optim_rsc1+1(PC),A0 ;Zeiger auf Resource
                move.w  optim_flag(A4),D1
                moveq   #0,D0
s_optim2:       bclr    #0,(A0)         ;Button deselekten
                btst    D0,D1           ;Bit testen
                beq.s   s_optim3        ;nicht gesetzt
                bset    #0,(A0)         ;Button selekten
s_optim3:       lea     10(A0),A0       ;nächster Button
                addq.w  #1,D0
                cmp.w   #5,D0
                bne.s   s_optim2
                lea     optim_rsc(PC),A0
                bsr     _form_do        ;Dialog ausgeben
                tst.w   D0
                bmi.s   s_optim7        ;UNDO
                subq.w  #1,D0
                beq.s   s_optim4        ;OK wurde gedrückt
                bsr     s_spez_optimize ;Direkte Optimierungen
s_optim4:       lea     optim_rsc1+1(PC),A0 ;Zeiger auf Resource
                moveq   #0,D1
                moveq   #0,D0
s_optim5:       btst    #0,(A0)         ;Button testen
                beq.s   s_optim6        ;nicht selektiert
                bset    D0,D1           ;Bit setzen
s_optim6:       lea     10(A0),A0       ;nächster Button
                addq.w  #1,D0
                cmp.w   #5,D0
                bne.s   s_optim5
                move.w  D1,optim_flag(A4)
s_optim7:       movem.l (SP)+,D0-D1/A0
                jmp     main_loop

optim_rsc:      DC.W 0,0,46,15,1
                DC.W 3,1
                DC.L optim_0
                DC.W $08
                DC.W 7,3
                DC.L optim_1
                DC.W $08
                DC.W 7,5
                DC.L optim_2
                DC.W $08
                DC.W 7,7
                DC.L optim_3
                DC.W $08
                DC.W 7,9
                DC.L optim_4
                DC.W $08
                DC.W 7,11
                DC.L optim_5
                DC.W $08
                DC.W 9,13
                DC.L ok_button
                DC.W $26
                DC.W 26,13
                DC.L doit_button
                DC.W $24
                DC.W 3,3
                DC.L optim_6
optim_rsc1:     DC.W $84
                DC.W 3,5
                DC.L optim_6
                DC.W $84
                DC.W 3,7
                DC.L optim_6
                DC.W $84
                DC.W 3,9
                DC.L optim_6
                DC.W $84
                DC.W 3,11
                DC.L optim_6
                DC.W $84
                DC.W -1

                SWITCH sprache
                CASE 0
optim_0:        DC.B 'Optimierungen während der Assemblierung',0
optim_1:        DC.B 'Sprungoptimierungen',0
optim_2:        DC.B 'PC-relativ Optimierungen',0
optim_3:        DC.B 'PC-relativ nicht über Segmentgrenzen',0
optim_4:        DC.B 'absolut-short Warnungen',0
optim_5:        DC.B 'Wandlung nach PEA bzw. LEA',0
optim_6:        DC.B '  ',0
doit_button:    DC.B ' OPTIMIERE ',0
                CASE 1
optim_0:        DC.B 'Optimizing during assembling',0
optim_1:        DC.B 'jump-optimizing',0
optim_2:        DC.B 'PC-relative',0
optim_3:        DC.B 'no PC-relative outside segments',0
optim_4:        DC.B 'absolute-short warnings',0
optim_5:        DC.B 'convert to PEA or LEA',0
optim_6:        DC.B '  ',0
doit_button:    DC.B ' OPTIMIZE ',0
                ENDS
                EVEN

************************************************************************
* direkte Optimierungen durchführen                                    *
************************************************************************
s_spez_optimize:movem.l D1-D2/A0-A2,-(SP)
                moveq   #0,D1           ;Anzahl der ausgeführten Optimierungen
                movea.l z_info_base(A4),A0 ;Zeiger auf Zeileninfo
                movea.l program_base(A4),A1 ;Opcode ab hier
s_spez_optloop: move.w  (A0)+,D2        ;Befehlslänge holen
                bmi.s   s_spez_optend   ;Ende des Sourcetextes
                beq.s   s_spez_noopt    ;Leerzeile => überspringen
                move.b  (A0),D0
                subq.b  #2,D0           ;ein Pseudo-Opcode?
                bge.s   s_spez_noopt    ;Ja! =>
                lea     s_spez_opttab(PC),A2
s_spez_optl1:   move.w  (A2)+,D0
                beq.s   s_spez_noopt    ;Ende der Tabelle, nix gefunden =>
                cmp.w   (A1),D0         ;Opcode gefunden?
                bhi.s   s_spez_noopt    ;Opcode nicht gefunden
                beq.s   s_spez_optl2    ;Ja! =>
                addq.l  #2,A2           ;Patch-Opcode überspringen
                bra.s   s_spez_optl1
s_spez_optl2:   move.w  (A2),(A1)       ;Opcode ersetzen
                move.b  #57,6(A0)       ;Warnungs-Message eintragen
                st      change_flag(A4) ;Änderungen am Sourcetext!
                addq.l  #1,D1           ;Anzahl der Optimierungen+1
s_spez_noopt:   adda.w  D2,A1           ;Opcodepointer hochsetzen
                addq.l  #8,A0           ;Zeiger auf nächste Zeile
                bra.s   s_spez_optloop  ;nächste Zeile
s_spez_optend:  st      testwrd(A4)
                moveq   #5,D4           ;max.6 Stellen
                lea     s_optspz_0(PC),A0
                bsr     dezw_out        ;Anzahl der Optimierungen ausgeben
                sf      testwrd(A4)
                lea     s_optspz(PC),A0
                bsr     _form_do        ;Dialog ausgeben
                movem.l (SP)+,D1-D2/A0-A2
                rts

;Diese Tabelle mu· aufsteigend sortiert sein:
s_spez_opttab:  DC.W $4280,$7000 ;CLR.L Dx nach MOVEQ #0,Dx
                DC.W $4281,$7200
                DC.W $4282,$7400
                DC.W $4283,$7600
                DC.W $4284,$7800
                DC.W $4285,$7A00
                DC.W $4286,$7C00
                DC.W $4287,$7E00
                DC.W $D0FC,$41E8 ;ADDA.W #xx,Ax nach LEA xx(Ax),Ax wandeln
                DC.W $D2FC,$43E9
                DC.W $D4FC,$45EA
                DC.W $D6FC,$47EB
                DC.W $D8FC,$49EC
                DC.W $DAFC,$4BED
                DC.W $DCFC,$4DEE
                DC.W $DEFC,$4FEF
                DC.W $E300,$D000 ;ASL.B #1,Dx nach ADD.B Dx,Dx wandeln
                DC.W $E301,$D201
                DC.W $E302,$D402
                DC.W $E303,$D603
                DC.W $E304,$D804
                DC.W $E305,$DA05
                DC.W $E306,$DC06
                DC.W $E307,$DE07
                DC.W $E308,$D000 ;LSL.B #1,Dx nach ADD.B Dx,Dx wandeln
                DC.W $E309,$D201
                DC.W $E30A,$D402
                DC.W $E30B,$D603
                DC.W $E30C,$D804
                DC.W $E30D,$DA05
                DC.W $E30E,$DC06
                DC.W $E30F,$DE07
                DC.W $E310,$D100 ;ROXL.B #1,Dx nach ADDX.B Dx,Dx wandeln
                DC.W $E311,$D301
                DC.W $E312,$D502
                DC.W $E313,$D703
                DC.W $E314,$D904
                DC.W $E315,$DB05
                DC.W $E316,$DD06
                DC.W $E317,$DF07
                DC.W $E340,$D040 ;ASL.W #1,Dx durch ADD.W Dx,Dx ersetzen
                DC.W $E341,$D241
                DC.W $E342,$D442
                DC.W $E343,$D643
                DC.W $E344,$D844
                DC.W $E345,$DA45
                DC.W $E346,$DC46
                DC.W $E347,$DE47
                DC.W $E348,$D040 ;LSL.W #1,Dx durch ADD.W Dx,Dx ersetzen
                DC.W $E349,$D241
                DC.W $E34A,$D442
                DC.W $E34B,$D643
                DC.W $E34C,$D844
                DC.W $E34D,$DA45
                DC.W $E34E,$DC46
                DC.W $E34F,$DE47
                DC.W $E350,$D140 ;ROXL.W #1,Dx nach ADDX.W Dx,Dx wandeln
                DC.W $E351,$D341
                DC.W $E352,$D542
                DC.W $E353,$D743
                DC.W $E354,$D944
                DC.W $E355,$DB45
                DC.W $E356,$DD46
                DC.W $E357,$DF47
                DC.W $E380,$D080 ;ASL.L #1,Dx nach ADD.L Dx,Dx wandeln
                DC.W $E381,$D281
                DC.W $E382,$D482
                DC.W $E383,$D683
                DC.W $E384,$D884
                DC.W $E385,$DA85
                DC.W $E386,$DC86
                DC.W $E387,$DE87
                DC.W $E388,$D080 ;LSL.L #1,Dx nach ADD.L Dx,Dx wandeln
                DC.W $E389,$D281
                DC.W $E38A,$D482
                DC.W $E38B,$D683
                DC.W $E38C,$D884
                DC.W $E38D,$DA85
                DC.W $E38E,$DC86
                DC.W $E38F,$DE87
                DC.W $E390,$D180 ;ROXL.L #1,Dx nach ADDX.L Dx,Dx wandeln
                DC.W $E391,$D381
                DC.W $E392,$D582
                DC.W $E393,$D783
                DC.W $E394,$D984
                DC.W $E395,$DB85
                DC.W $E396,$DD86
                DC.W $E397,$DF87
                DC.W $00        ;Ende der Tabelle

s_optspz:       DC.W 0,0,33,5,1
                DC.W 2,1
                DC.L s_optspz_0
                DC.W $08
                DC.W 13,3
                DC.L ok_button
                DC.W $26
                DC.W -1

s_optspz_0:     SWITCH sprache
                CASE 0
                DC.B '       Optimierungen gefunden',0
                CASE 1
                DC.B '       optimizings found',0
                ENDS
                EVEN
                ENDPART
                >PART '9.99-Tools'
************************************************************************
*  Scanner-Routine (zeigt die Zeileninfo und Labeltabelle an)          *
************************************************************************
scanner:        movem.l D0-A6,-(SP)
                move.l  zeile(A4),-(SP)
                move.w  top_line(A4),D0
                bsr     calc_pointer
                clr.w   zeile(A4)
                move.w  #34,spalte(A4)
scanner1:       move.l  (A5),D1
                bsr     hexlout
                move.l  4(A5),D1
                bsr     hexlout
                move.w  8(A5),D1
                bsr     hexwout
                addq.w  #1,spalte(A4)
                moveq   #0,D0
scanner2:       move.w  0(A6,D0.w),D1
                bsr     hexwout
                addq.w  #1,spalte(A4)
                addq.w  #2,D0
                cmp.w   #8,D0
                ble.s   scanner2
                addq.w  #1,zeile(A4)
                move.w  #34,spalte(A4)
                move.w  sdrv_zanz(A4),D0
                cmp.w   zeile(A4),D0
                bls.s   scanner7
                tst.w   (A5)
                bmi.s   scanner3
                adda.w  (A5),A6
                lea     10(A5),A5
                bra.s   scanner1
scanner3:       cmpi.w  #20,zeile(A4)
                beq.s   scanner7
                clr.w   spalte(A4)
                movea.l label_base(A4),A0
scanner4:       moveq   #15,D0
scanner5:       move.w  (A0)+,D1
                bsr     hexwout
                dbra    D0,scanner5
                clr.w   spalte(A4)
                addq.w  #1,zeile(A4)
                move.w  sdrv_zanz(A4),D0
                cmp.w   zeile(A4),D0
                bhi.s   scanner4
                clr.w   spalte(A4)
                lea     marker(A4),A0
                moveq   #12,D2
scanner6:       move.w  (A0)+,D1
                bsr     hexwout
                moveq   #' ',D0
                bsr     chrout
                dbra    D2,scanner6
scanner7:       bsr     tastchk
                bpl.s   scanner7
                move.l  (SP)+,zeile(A4)
                movem.l (SP)+,D0-A6
                jmp     main_loop

************************************************************************
* Scancodes etc. abtesten                                              *
************************************************************************
keycode:        movem.l D0-A6,-(SP)
                lea     keycode_box(PC),A6
                move.w  #1,8(A6)        ;komplette Box zeichnen
                move.l  #$DEADFACE,D0   ;Zahl bevor eine Taste gedrückt wird
                bra.s   keycode1
keycode_loop:   bsr     conin           ;auf Tastencode warten
                tst.l   D0
                beq.s   keycode_loop
                cmp.b   #27,D0          ;ESC?
                beq.s   keycode_exit    ;Dann raus =>
keycode1:       st      testwrd(A4)
                move.l  D0,D1
                lea     keycode_2(PC),A0
                bsr     hexlout         ;Scancode nach Hex wandeln
                sf      testwrd(A4)
                movea.l A6,A0
                bsr     _objc_draw      ;und Box zeichnen
                move.w  #2,8(A6)        ;Rahmen und Hintergrund nicht mehr zeichnen
                bra.s   keycode_loop
keycode_exit:   bsr     redraw_all      ;Bildschirm neu aufbauen
                movem.l (SP)+,D0-A6
                jmp     main_loop
keycode_box:    DC.W 0,0,22,3,1
                DC.W 1,1
                DC.L keycode_1
                DC.W 8
                DC.W -1

keycode_1:      SWITCH sprache
                CASE 0
                DC.B 'Tastencode $'
                CASE 1
                DC.B 'Keycode  $'
                ENDS
keycode_2:      DC.B '        ',0
                EVEN
                ENDPART

************************************************************************
* holt Index des aktuellen Operanden                                   *
************************************************************************
                >PART 'get_index'
get_index:      moveq   #0,D0
                tst.b   2(A5,D5.w)
                beq.s   get_index_f     ;kein Index
                move.w  2(A5,D5.w),D0
                bmi.s   get_index2      ;Quickoperant
                cmp.w   #$0200,D0
                bge.s   get_index_f2    ;Spezialbefehle
                moveq   #$0F,D1
                and.w   D0,D1           ;EOffset
                btst    #5,D0
                beq.s   get_index3      ;Word
                move.l  0(A6,D1.w),D0   ;Labelindex nach D0
get_index_t:    move    #0,CCR
                rts
get_index3:     move.w  0(A6,D1.w),D0   ;Labelindex nach D0
                move    #0,CCR
                rts
get_index_f2:   move    #1,CCR          ;C-Flag
                rts
get_index_f:    move    #2,CCR          ;V-Flag setzen = kein Index
                rts
get_index2:     btst    #14,D0
                beq.s   get_index4      ;$xx(An,Rx)
                andi.w  #$3FFF,D0
                bra.s   get_index_t
get_index4:     moveq   #$0F,D1
                and.w   D0,D1           ;EOffset
                btst    #4,D0
                bne.s   get_index5      ;Registerliste
                move.b  0(A6,D1.w),D0   ;Low-Byte nach D0
                and.w   #$3FFF,D0
                bra.s   get_index_t
get_index5:     move.w  2(A6),D0        ;Index der Registerliste holen
                and.w   #$3FFF,D0
                bra.s   get_index_t
                ENDPART

************************************************************************
* setzt Index des ak. Operanden auf D0                                 *
************************************************************************
                >PART 'set_index'
set_index:      move.w  D0,-(SP)        ;Index retten
                moveq   #0,D0
                tst.b   2(A2,D5.w)
                beq.s   set_index_f     ;kein Index
                move.w  2(A2,D5.w),D0
                bmi.s   set_index2      ;Quickoperant
                cmp.w   #$0200,D0
                bge.s   set_index_f     ;Spezialbefehle
                moveq   #$0F,D1
                and.w   D0,D1           ;EOffset
                btst    #5,D0
                beq.s   set_index3      ;Word
                move.w  (SP)+,16(A2,D1.w) ;Labelindex setzen
set_index_t:    move    #0,CCR
                rts
set_index3:     move.w  (SP)+,14(A2,D1.w) ;Labelindex setzen
                move    #0,CCR
                rts
set_index_f:    addq.l  #2,SP
                move    #2,CCR          ;V-Flag setzen = kein Index
                rts
set_index2:     btst    #14,D0
                beq.s   set_index4      ;$xx(An,Rx)
                move.w  (SP)+,D0
                or.w    #$C000,D0
                move.w  D0,2(A2,D5.w)
                bra.s   set_index_t
set_index4:     moveq   #$0F,D1
                and.w   D0,D1           ;EOffset
                btst    #4,D0
                bne.s   set_index5      ;Registerliste
                move.w  (SP)+,D0
                move.b  D0,14(A2,D1.w)  ;Low-Byte einsetzen
                andi.w  #$C0FF,2(A2,D5.w)
                and.w   #$3F00,D0
                or.w    D0,2(A2,D5.w)   ;Highbyte einsetzen
                bra.s   set_index_t
set_index5:     move.w  (SP)+,D0
                and.w   #$3FFF,D0
                move.w  D0,16(A2)       ;Index der Registerliste einsetzen
                bra.s   set_index_t
                ENDPART
                >PART 'label_abmelden'
label_abmelden: jsr     del_entryc      ;Einträge der alten Zeile löschen
                movea.l label_base(A4),A0
                moveq   #0,D0
                move.w  6(A2),D0        ;Index des neuen Labels
                bmi     return
                lsl.l   #5,D0
                ori.b   #$80,4(A0,D0.l) ;Definitionsflag setzen
                moveq   #0,D0
                rts
                ENDPART
                >PART 'print_top'
print_top:      clr.w   spalte(A4)
                move.w  #-1,zeile(A4)
                pea     top_text(PC)
                bsr     print_line
                jsr     zswitch1
                bra     draw_lines
                ENDPART

************************************************************************
* durchsucht den Sourcetext nach PART-Befehlen und legt eine Tabelle   *
* mit Start- und Endzeilennummern der einzelnen Blöcke an              *
************************************************************************
                >PART 'search_part'
search_part:    movem.l D0-D3/A0-A2,-(SP)
                movea.l z_info_base(A4),A0
                subq.l  #8,A0
                moveq   #-1,D0
                lea     partbuffer(A4),A1 ;Zeiger auf Buffer
                move.w  #part_anz,D3    ;maximale Anzahl von PARTs
                moveq   #$52,D1         ;Kennung für PART
                moveq   #$54,D2         ;Kennung für ENDPART
search_part1:   addq.w  #1,D0           ;Anzahl erhöhen
                addq.l  #8,A0           ;Zeiger auf nächste Zeile
                tst.w   (A0)+
                bmi.s   search_part6    ;Ende des Sourcetexts
                cmp.b   (A0),D1         ;PART?
                bne.s   search_part1    ;nein
search_part2:   tst.b   1(A0)           ;Hide-Flag gesetzt?
                beq.s   search_part1    ;nein
                move.w  D0,(A1)+        ;Startzeile merken
                movea.l A0,A2           ;Zeiger auf PART-Zeile
search_part3:   addq.w  #1,D0           ;Anzahl erhöhen
                addq.l  #8,A0           ;Zeiger auf nächste Zeile
                tst.w   (A0)+
                bmi.s   search_part5    ;Ende des Sourcetexts
                cmp.b   (A0),D1         ;noch ein PART?
                beq.s   search_part4    ;ja
                cmp.b   (A0),D2         ;ENDPART?
                bne.s   search_part3    ;nein
                move.w  D0,(A1)+        ;Endzeile merken
                subq.w  #1,D3           ;Anzahl erniedrigen
                bhi.s   search_part1    ;wieder nach PART suchen
                bra.s   search_part7    ;mehr geht nicht!
search_part4:   subq.l  #2,A1           ;Startzeile wieder löschen
                clr.b   1(A2)           ;Hide-Flag beim PART davor löschen
                bra.s   search_part2    ;neuen PART merken
search_part5:   subq.l  #2,A1           ;Startzeile wieder löschen
                clr.b   1(A2)           ;Hide-Flag beim PART löschen
search_part6:   clr.l   (A0)+           ;den Rest des Zeileninfos löschen
                clr.l   (A0)            ;insbesondere die Fehlernummer!
search_part7:   clr.l   (A1)            ;Endekennung für Tabelle
                movem.l (SP)+,D0-D3/A0-A2
                rts
                ENDPART

************************************************************************
* sucht Symbolnamen in Tabelle                                         *
* ->A0 zeigt auf Namen                                                 *
* <-A0 zeigt hinter den Namen, wenn gefunden                           *
* <-A1 zeigt auf Tabelleneintrag                                       *
* <-D0 ist Index, -1 (wenn nicht gefunden) oder -2 (falsche Eingabe)   *
************************************************************************
                >PART 'search_label'
search_label:   movem.l D1-D4/A2-A3,-(SP)
                movea.l label_base(A4),A1
                lea     allowed_chars(PC),A2
                move.l  A0,D4           ;Zeiger merken
                moveq   #0,D0
                moveq   #0,D1
                move.b  (A0),D1         ;erstes Zeichen
                cmp.b   local_char(A4),D1
                beq.s   slab_loop1      ;erlaubt
                tst.b   0(A2,D1.w)      ;erlaubt?
                ble.s   slab_not_found2 ;nein
                move.b  D1,D0
slab_loop1:     lea     spaced(A4),A3
                clr.l   (A3)+
                clr.l   (A3)+
                clr.l   (A3)+           ;Buffer löschen
                clr.l   (A3)+
                clr.l   (A3)+
                clr.l   (A3)
                lea     spaced(A4),A3
                move.b  D0,(A3)+        ;erstes Zeichen
                addq.l  #1,A0
                moveq   #24,D1          ;max. Länge
slab_loop01:    subq.w  #1,D1
                beq.s   slab_not_found  ;Name zu lang
                move.b  (A0)+,D0        ;Zeichen kopieren
                move.b  D0,(A3)+
                tst.b   0(A2,D0.w)      ;Zeichen erlaubt
                bne.s   slab_loop01     ;ja
                clr.b   -(A3)           ;letztes Zeichen wieder löschen
                subq.l  #1,A0
                move.w  label_top_ind(A4),D2
                moveq   #0,D0
slab_loop2:     cmp.w   D2,D0           ;Ende der Tabelle erreicht?
                beq.s   slab_not_found  ;ja
                tst.b   31(A1)
                bmi.s   slab_ungleich   ;spezieller Eintrag (Formel,dc)
                bne.s   slab_ungleich   ;gelöschter Eintrag
                lea     spaced(A4),A3   ;Zeiger auf Namen
                move.l  A1,D1           ;Register retten
                addq.l  #8,A1           ;zeigt auf Namen
                moveq   #5,D3           ;6*4=24 Zeichen
slab_loop:      cmpm.l  (A1)+,(A3)+     ;4 Zeichen vergleichen
                dbne    D3,slab_loop
                movea.l D1,A1           ;Register zurück
                bne.s   slab_ungleich
                tst.b   4(A1)           ;defined-flag testen
                bpl.s   slab_ungleich
                movem.l (SP)+,D1-D4/A2-A3
                rts
slab_ungleich:  lea     32(A1),A1
                addq.w  #1,D0
                bra.s   slab_loop2
slab_not_found: movea.l D4,A0
                movem.l (SP)+,D1-D4/A2-A3
                moveq   #-1,D0
                rts
slab_not_found2:movem.l (SP)+,D1-D4/A2-A3
                moveq   #-2,D0
                rts
                ENDPART

************************************************************************
* legt im Zielcodespeicher eine Tabelle von Indexnummern an            *
* ->A0 zeigt auf Symbolnamen(mit Jokern)                               *
* <-D0 Anzahl der Symbole in der Tabelle oder -1 bei Fehleingabe       *
************************************************************************
                >PART 'search_symbols'
search_sym2:    moveq   #-1,D0
                movem.l (SP)+,D1-D4/A0-A3
                rts
search_symbols: movem.l D1-D4/A0-A3,-(SP)
                lea     allowed_chars(PC),A2
                lea     spaced(A4),A1   ;Buffer für Name
                lea     spaced+30(A4),A3 ;Buffer für Maske
                moveq   #0,D0
                move.b  (A0),D0
                cmp.b   #'*',D0
                beq.s   search_sym0     ;Allquantor
                cmp.b   local_char(A4),D0
                beq.s   search_sym0     ;lokales Symbol
                tst.b   0(A2,D0.w)
                ble.s   search_sym2     ;falsche Eingabe
search_sym0:    moveq   #$FF,D0
                move.l  D0,(A3)
                move.l  D0,4(A3)
                move.l  D0,8(A3)        ;Buffer löschen
                move.l  D0,12(A3)
                move.l  D0,16(A3)
                move.l  D0,20(A3)
                moveq   #0,D0
                move.l  D0,(A1)+
                move.l  D0,(A1)+
                move.l  D0,(A1)+        ;Buffer löschen
                move.l  D0,(A1)+
                move.l  D0,(A1)+
                move.l  D0,(A1)
                lea     -20(A1),A1
                move.b  local_char(A4),D0
                moveq   #-1,D1
                cmp.b   (A0),D0
                bne.s   search_sym1     ;kein lokales Symbol
                addq.w  #1,D1
                addq.l  #1,A0           ;Zeichen überlesen
                clr.b   (A1)+           ;und als Kennung $00 eintragen
                addq.l  #1,A3
search_sym1:    addq.w  #1,D1
                move.b  (A0)+,D0
                move.b  D0,(A1)+
                addq.l  #1,A3
                tst.b   0(A2,D0.w)      ;Symbolname kopieren
                bne.s   search_sym1
                cmp.b   #'?',D0
                bne.s   search_sym3
                clr.b   -1(A3)
                clr.b   -1(A1)
                bra.s   search_sym1
search_sym3:    cmp.b   #'*',D0
                bne.s   search_sym4
                clr.b   -1(A3)
search_sym5:    clr.b   (A3)+
                addq.w  #1,D1           ;Rest der Maske löschen
                cmp.w   #23,D1
                bne.s   search_sym5
search_sym4:    clr.b   -(A1)
                lea     spaced(A4),A0   ;Name
                lea     spaced+30(A4),A1 ;Maske
                movea.l label_base(A4),A2
                movea.l ass_adr(A4),A3  ;Buffer für Indizes
                lea     -24(A2),A2
                moveq   #-1,D4
                moveq   #0,D0
                move.w  label_top_ind(A4),D1
search_sym6:    lea     32(A2),A2
                addq.w  #1,D4
                cmp.w   D1,D4
                beq.s   search_sym7     ;Ende der Tabelle
                tst.b   23(A2)
                bne.s   search_sym6     ;kein Symbol
                moveq   #0,D3
search_sym8:    move.l  0(A2,D3.w),D2
                and.l   0(A1,D3.w),D2
                cmp.l   0(A0,D3.w),D2
                bne.s   search_sym6     ;ungleich
                addq.w  #4,D3
                cmp.w   #24,D3
                bne.s   search_sym8
                move.w  D4,(A3)+        ;Index in Buffer
                addq.w  #1,D0
                bra.s   search_sym6
search_sym7:    move.w  #-1,(A3)
                movem.l (SP)+,D1-D4/A0-A3
gar_c1:         rts
                ENDPART

************************************************************************
* Garbage collection für Symboltabelle                                 *
************************************************************************
                >PART 'garbage_collection'
garbage_collection:
                tst.w   label_top_ind(A4)
                beq.s   gar_c1          ;keine Einträge
                movem.l D1-D5/A2-A6,-(SP)
                moveq   #2,D0
                bsr     _graf_mouse
                bclr    #7,sym_flag(A4)
                moveq   #0,D0
                movea.l ass_adr(A4),A0  ;Buffer für Flagtabelle
                move.w  #1024,D1        ;1024*16=16384 Bytes
gar_c0:         move.l  D0,(A0)+
                move.l  D0,(A0)+        ;Buffer löschen
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                dbra    D1,gar_c0
                movea.l label_base(A4),A3
                move.w  label_top_ind(A4),D1
                movea.l ass_adr(A4),A0  ;Buffer für Flags
                lea     -32+4(A3),A3
                subq.l  #1,A0
                moveq   #0,D2           ;Flag löschen
gar_c2:         addq.l  #1,A0           ;Zeiger auf Flags erhöhen
                subq.w  #1,D1           ;Anzahl erniedrigen
                bmi.s   gar_c3          ;Ende der Tabelle
                lea     32(A3),A3
                tst.b   31-4(A3)        ;Eintragsstatus
                bne.s   gar_c2          ;kein Symbol
                tst.b   (A3)            ;defined_flag testen
                bmi.s   gar_c2          ;definiert
                st      (A0)            ;Flag des Index setzen
                moveq   #1,D2           ;Flag setzen
                bra.s   gar_c2
gar_c3:         tst.w   D2
                beq.s   gar_c4          ;keine passenden Einträge gefunden
                movea.l ass_adr(A4),A2
                movea.l z_info_base(A4),A5
                tst.w   (A5)
                bmi.s   gar_c4          ;keine Zeilen vorhanden
                bsr.s   gar_search      ;Sourcetext durchsuchen
                move.w  label_top_ind(A4),D1
                movea.l label_base(A4),A3
                lea     -32(A3),A3      ;minus 32
                moveq   #0,D0
gar_c8:         lea     32(A3),A3       ;Zeiger auf nächsten Eintrag
gar_c81:        subq.w  #1,D1           ;Anzahl erniedrigen
                bmi.s   gar_c9          ;Ende der Tabelle
                tst.b   (A2)+
                beq.s   gar_c8          ;gelöschter Eintrag
                move.l  D0,(A3)+
                move.l  D0,(A3)+
                move.l  D0,(A3)+
                move.l  D0,(A3)+
                move.l  D0,(A3)+        ;Eintrag löschen
                move.l  D0,(A3)+
                move.l  D0,(A3)+
                move.l  D0,(A3)+
                move.b  #1,-1(A3)       ;Eintrag als frei deklarieren
                bra.s   gar_c81
gar_c9:         movea.l label_top(A4),A2 ;Ende der Tabelle
                moveq   #32,D0
gar_c10:        tst.b   -1(A2)          ;Eintragstyp
                ble.s   gar_c4          ;belegt
                subq.w  #1,label_top_ind(A4)
                sub.l   D0,label_top(A4) ;Zeiger erniedrigen
                suba.l  D0,A2
                bra.s   gar_c10
gar_c4:         moveq   #0,D0
                bsr     _graf_mouse
                movem.l (SP)+,D1-D5/A2-A6
                rts
gar_search:     movea.l program_base(A4),A6
                movea.l label_base(A4),A3
gar_c5:         moveq   #0,D0
                move.b  2(A5),D0
                cmp.b   #2,D0
                bge.s   gar_c6          ;Spezialbefehle
                moveq   #0,D5           ;1.Operand
                bsr     get_index       ;Index holen
                bvs.s   gar_c7          ;kein Index
                bsr     gar_c20         ;Index in Tabelle suchen
gar_c7:         moveq   #2,D5           ;2.Operand
                bsr     get_index       ;Index holen
                bvs.s   gar_c71         ;kein Index
                bsr     gar_c20         ;Index in Tabelle suchen
gar_c71:        adda.w  (A5),A6         ;eine Zeile weiter
                lea     10(A5),A5
                tst.w   (A5)            ;Ende erreicht ?
                bpl.s   gar_c5          ;nein
                rts
gar_c6:         move.w  gar_jmp-2(PC,D0.w),D0
                beq.s   gar_c71         ;kein Indizes
                jmp     gar_jmp(PC,D0.w) ;Sprung zum Spezialbefehl
                BASE DC.W,gar_jmp
gar_jmp:        DC.W gar_cdc,gar_cds,0,0,0,0,gar_cequ
                DC.W 0,0,0,0,gar_crs,gar_crsset,0,0
                DC.W gar_cbase,0,0,0,gar_cif,0,0,0
                DC.W 0,0,gar_cds,0,0,gar_cif,gar_crs,0 ;bis $3E
                DC.W gar_cif,0,0,gar_cglob,gar_cif,0,0,0
                DC.W 0,0,0,0,gar_cequ,0

gar_cdc:        move.w  4(A5),D0
                and.w   #$3FFF,D0
gar_cdc4:       lsl.l   #5,D0
                lea     0(A3,D0.l),A0   ;Zeiger auf DC-Eintrag
                moveq   #0,D0
gar_cdc1:       move.w  (A0)+,D0
                bmi.s   gar_cdc2        ;Index
                cmp.b   #$FE,D0         ;Endekennung
                beq.s   gar_cdc3
                cmp.b   #$FF,D0         ;Fortsetzungskennung
                bne.s   gar_cdc1        ;nein
                ext.l   D0
                move.b  (A0)+,D0
                bra.s   gar_cdc4
gar_cdc2:       andi.w  #$3FFF,D0
                move.l  A0,-(SP)
                bsr.s   gar_c20         ;Index testen
                movea.l (SP)+,A0
                moveq   #0,D0
                bra.s   gar_cdc1
gar_cdc3:       bra     gar_c71         ;nächste Zeile

gar_cds:        move.w  2(A5),D0
                andi.w  #$30,D0
                cmp.w   #$30,D0
                bne.s   gar_cdc3        ;kein Index
                move.w  4(A5),D0
gar_cds2:       andi.w  #$3FFF,D0
                bsr.s   gar_c20         ;Index testen
                bra     gar_c71
gar_crs:        move.w  2(A5),D0
                andi.w  #5,D0
                cmp.w   #5,D0
                bne.s   gar_cdc3        ;kein Index
                move.w  4(A5),D0        ;Index holen
                bra.s   gar_cds2        ;testen
gar_cequ:       tst.b   3(A5)           ;EQU
                beq.s   gar_cdc3        ;kein Index
                move.w  4(A5),D0        ;Index holen
                bra.s   gar_cds2        ;testen
gar_crsset:     btst    #6,3(A5)        ;RSSET
                beq.s   gar_cdc3        ;kein Index
                move.w  4(A5),D0        ;Index holen
                bra.s   gar_cds2        ;testen
gar_cbase:      move.w  4(A5),D0        ;BASE
                bmi.s   gar_cdc3        ;kein Index
                moveq   #1,D3           ;2. Operand
                bra.s   gar_cds2        ;Index testen
gar_cif:        move.w  4(A5),D0        ;IF
                bra.s   gar_cds2        ;testen
gar_cglob:      moveq   #0,D0
                move.w  4(A5),D0        ;Index holen
                lsl.l   #5,D0
                lea     0(A3,D0.l),A1   ;Zeiger auf Global-Eintrag
gar_cglob1:     moveq   #0,D0
                move.w  (A1)+,D0        ;Symbolindex holen
                bmi.s   gar_cdc3        ;Ende des Eintrags
                and.w   #$3FFF,D0
                bsr.s   gar_c20         ;Index testen
                bra.s   gar_cglob1

gar_c20:        move.w  D0,D1           ;Index retten
                lsl.l   #5,D0
                cmpi.b  #$FF,31(A3,D0.l) ;Formel?
                beq.s   gar_c23         ;ja
                sf      0(A2,D1.w)      ;Index aus Flagtabelle streichen
gar_c22:        rts
gar_c23:        lea     6(A3,D0.l),A1   ;Zeiger auf Formel
gar_c24:        addq.l  #1,A1           ;Operation überlesen
                move.b  (A1)+,D0
                bmi.s   gar_c25         ;Index
                addq.l  #2,A1
                btst    #6,D0           ;Long-flag
                beq.s   gar_c24
                addq.l  #2,A1
                bra.s   gar_c24
gar_c25:        cmp.b   #$FF,D0         ;Endekennung ?
                beq.s   gar_c22         ;ja
                move.w  (A1)+,D0        ;Index holen
                bmi.s   gar_c24         ;interne Variable
                sf      0(A2,D0.w)      ;Index aus Flagtabelle streichen
                bra.s   gar_c24         ;weiter in der Formel
                ENDPART

************************************************************************
* durchsucht den Sourcetext nach unbenutzten Symbolen                  *
************************************************************************
                >PART 's_search_unused'
s_search_unused:tst.w   label_top_ind(A4)
                beq     s_jmp_main      ;keine Einträge in Tabelle
                movem.l D1-D5/A2-A6,-(SP)
                moveq   #2,D0
                bsr     _graf_mouse     ;Hour glass
                bclr    #7,sym_flag(A4) ;Buffer dirty
                moveq   #0,D0
                movea.l ass_adr(A4),A0  ;Buffer für Flagtabelle
                move.w  #1024,D1
s_un0:          move.l  D0,(A0)+
                move.l  D0,(A0)+        ;Buffer löschen
                move.l  D0,(A0)+
                move.l  D0,(A0)+
                dbra    D1,s_un0
                movea.l label_base(A4),A3
                move.w  label_top_ind(A4),D1
                movea.l ass_adr(A4),A0  ;Buffer für Flags
                lea     -32+4(A3),A3
                subq.l  #1,A0
s_un1:          addq.l  #1,A0           ;Zeiger auf Flags erhöhen
                subq.w  #1,D1           ;Anzahl erniedrigen
                bmi.s   s_un2           ;Ende der Tabelle
                lea     32(A3),A3
                tst.b   31-4(A3)        ;Eintragsstatus
                bne.s   s_un1           ;kein Symbol
                tst.b   (A3)            ;defined_flag testen
                bpl.s   s_un1           ;nicht definiert
                st      (A0)            ;Flag für Index setzen
                bra.s   s_un1           ;nächster Eintrag
s_un2:          movea.l ass_adr(A4),A2
                movea.l z_info_base(A4),A5
                tst.w   (A5)
                bmi.s   s_un3           ;keine Zeilen vorhanden
                bsr     gar_search      ;Sourcetext durchsuchen
                movea.l z_info_base(A4),A5
                subq.l  #4,A5           ;zeigt auf das 6. Word
                moveq   #0,D0
                move.w  anz_zeilen(A4),D2
s_un4:          subq.w  #1,D2           ;Anzahl minus 1
                bcs.s   s_un3           ;Ende des Sourcetexts
                lea     10(A5),A5       ;Zeiger erhöhen
                tst.w   (A5)            ;Symbol in der Zeile definiert?
                bmi.s   s_un4           ;nein
                move.w  (A5),D0         ;Index holen
                tst.b   0(A2,D0.w)      ;Flag zum Index testen
                beq.s   s_un4           ;gelöscht (wurde gefunden)
                move.b  #21,2(A5)       ;Warning eintragen(Symbol nicht benutzt)
                bra.s   s_un4           ;nächste Zeile
s_un3:          moveq   #0,D0
                bsr     _graf_mouse     ;Pfeil
                movem.l (SP)+,D1-D5/A2-A6
                bra     s_jmp_main
                ENDPART

************************************************************************
* paßt Sprungweiten im Sourcetext anhand der Fehlernummern an          *
************************************************************************
                >PART 's_corr'
s_corr21:       move.w  (A1),D1         ;Befehl holen
                cmp.w   #$083A,D1       ;btst #x,xx(pc)?
                beq.s   s_corr221       ;ja
                and.w   #$F1C0,D1
                cmp.w   #$0100,D1       ;btst dn,xx(pc)?
                beq.s   s_corr221       ;ja
                move.w  (A1),D1
                and.w   #$F0FF,D1
                cmp.w   #$6000,D1       ;B??.W ?
                beq     s_corr6         ;ja
                andi.w  #$FFC0,(A1)     ;EA-Bits löschen
                ori.w   #$39,(A1)       ;EA auf Long
                addq.w  #2,-2(A0)       ;Befehlslänge plus 2
                andi.w  #$FF0F,(A0)
                ori.w   #$20,(A0)
                moveq   #15,D0
                and.w   (A0),D0         ;Einsetzoffset
                moveq   #0,D1
                move.w  0(A1,D0.w),D1   ;Symbolindex holen
                bsr     s_corr91        ;Programmcode um 2 Bytes verlängern
                move.l  D1,0(A1,D0.w)   ;Symbolindex wieder schreiben
                cmpi.b  #1,2(A0)        ;2. Operand da?
                bne.s   s_corr22        ;nein
                addq.b  #2,3(A0)        ;Offset anpassen
s_corr22:       move.w  -2(A0),D0       ;Befehlslänge
                clr.b   6(A0)
                bra.s   s_corr2
s_corr221:      andi.w  #$FFC0,(A1)     ;EA-Bits löschen
                ori.w   #$39,(A1)       ;EA auf Long
                addq.w  #2,-2(A0)       ;Befehlslänge plus 2
                andi.w  #$FF0F,2(A0)    ;2. Operand auf Long
                ori.w   #$20,2(A0)
                moveq   #15,D0
                and.w   2(A0),D0        ;Einsetzoffset
                moveq   #0,D1
                move.w  0(A1,D0.w),D1   ;Symbolindex
                bsr     s_corr91        ;Programmcode um 2 Bytes verlängern
                move.l  D1,0(A1,D0.w)
                bra.s   s_corr22
s_correct_jumps:tst.l   err_count(A4)   ;Fehler aufgetreten
                beq     s_corr1         ;nein
                movem.l D1-D4/A1-A3,-(SP)
                movea.l z_info_base(A4),A0
                movea.l program_base(A4),A1
                moveq   #0,D0
                subq.l  #8,A0
s_corr2:        addq.l  #8,A0           ;nächste Zeile
                adda.w  D0,A1
                move.w  (A0)+,D0        ;Befehlslänge holen
                bmi     s_corr3         ;Textende
                move.b  6(A0),D1        ;Fehlernummer holen
                beq.s   s_corr2         ;kein Fehler
                cmp.b   #41,D1          ;kann zu B??.S optimiert werden
                beq     s_corr4
                cmp.b   #42,D1          ;kann zu rel. Sprung optimiert werden
                beq     s_corr5
                cmp.b   #53,D1          ;PC -> Long
                beq     s_corr21
                cmp.b   #18,D1          ;Offset zu groß
                bne.s   s_corr7         ;nein
                move.w  (A1),D1         ;Befehl holen
                and.w   #$F0FF,D1
                cmp.w   #$6002,D1       ;B??.S ?
                bne.s   s_corr2         ;nein, nächste Zeile
                move.w  (A0),D1         ;Index aus Zeileninfo holen
                and.w   #$3FFF,D1       ;Index ausmaskieren
                bsr     s_corr9         ;Programmcode um 2 Byte verlängern
                bmi.s   s_corr2         ;Speicher reicht nicht
                move.w  #$0192,(A0)     ;Zeileninfokennung für B??.W
                clr.b   1(A1)           ;Befehl zu Word
                move.w  D1,2(A1)        ;Index eintragen
                moveq   #4,D0
                move.w  D0,-2(A0)       ;neue Befehlslänge
                clr.b   6(A0)           ;Fehlernummer löschen
                bra.s   s_corr2
s_corr7:        cmp.b   #50,D1          ;PC-relative Adressierung möglich
                beq.s   s_corr10
                cmp.b   #55,D1          ;PC-relative Adressierung (über Segment)
                beq.s   s_corr10
                cmp.b   #51,D1          ;Wandlung nach PEA
                beq.s   s_corr71
                cmp.b   #52,D1          ;Wandlung nach LEA
                bne.s   s_corr2         ;nein -> nächste Zeile
                move.w  (A1),D1         ;Befehl holen (LEA)
                and.w   #$F1FF,D1
                cmp.w   #$207C,D1       ;wirklich ein MOVE.L #,An?
                bne     s_corr2         ;Nein! => (sollte NIE auftreten!)
                move.w  #$0E00,D1
                and.w   D1,(A1)         ;nur die Register-Bits belassen
                move.w  #$41F9,D1       ;ein LEA adr.l,A0
                or.w    D1,(A1)         ;und den neuen Opcode rein
                clr.b   6(A0)
                bra     s_corr2
s_corr71:       move.w  (A1),D1         ;Befehl holen
                cmp.w   #$2F3C,D1       ;wirklick ein MOVE.L #,-(SP)?
                bne     s_corr2         ;Nein! => (sollte NIE auftreten!)
                move.w  #$4879,(A1)     ;PEA adr.l einsetzen
                clr.b   6(A0)           ;Fehlernummer löschen
                bra     s_corr2
s_corr3:        movem.l (SP)+,D1-D4/A1-A3
s_corr1:        rts
s_corr10:       andi.w  #$FFC0,(A1)     ;EA-Bits löschen
                ori.w   #$3A,(A1)       ;EA PC-relativ
                subq.w  #2,-2(A0)       ;Befehlslänge minus 2
                andi.w  #$FF0F,(A0)
                ori.w   #$90,(A0)       ;PC-relativ Kennung ins Zeileninfo
                moveq   #15,D0
                and.w   (A0),D0         ;Einsetzoffset
                move.w  2(A1,D0.w),D1   ;Symbolindex holen
                bsr     s_corr81        ;Programmcode um 2 Byte kürzer
                move.w  D1,0(A1,D0.w)   ;Symbolindex wieder einsetzen
                cmpi.b  #1,2(A0)        ;2. Operand vorhanden?
                bne.s   s_corr11        ;nein
                subq.b  #2,3(A0)        ;Offset anpassen
s_corr11:       move.w  -2(A0),D0       ;Befehlslänge
                clr.b   6(A0)           ;Fehlernummer löschen
                bra     s_corr2
s_corr4:        move.w  2(A1),D1        ;Symbolindex holen
                bsr     s_corr8         ;Programmcode um 2 Byte kürzen
                or.w    #$C000,D1       ;Flag für Quickoperanden setzen
                move.w  D1,(A0)         ;und ins Zeileninfo schreiben
                move.b  #2,1(A1)        ;Kennung für B??.S setzen
                moveq   #2,D0
                move.w  D0,-2(A0)       ;neue Befehlslänge
                clr.b   6(A0)           ;Fehlernummer löschen
                bra     s_corr2
s_corr5:        move.w  4(A1),D1        ;Symbolindex holen
                bsr.s   s_corr81        ;Programmcode um 2 Byte kürzen
                move.w  D1,2(A1)        ;Index zurückschreiben
                move.w  (A1),D1         ;alten Befehl retten
                move.w  #$6000,(A1)     ;BRA
                cmp.w   #$4EF9,D1       ;JMP ?
                beq.s   s_corr51        ;ja
                move.w  #$6100,(A1)     ;BSR
s_corr51:       andi.w  #$FFCF,(A0)
                ori.w   #$90,(A0)       ;PC-relativ setzen
                moveq   #4,D0
                move.w  D0,-2(A0)       ;neue Befehlslänge
                clr.b   6(A0)           ;Fehlernummer löschen
                bra     s_corr2
s_corr6:        move.w  (A1),D1         ;Befehlscode holen
                cmp.w   #$6000,D1       ;BRA ?
                beq.s   s_corr61        ;ja
                cmp.w   #$6100,D1       ;BSR ?
                bne     s_corr2         ;nein, dann keine Wandlung möglich
                move.w  #$4EB9,D1       ;JSR eintragen
s_corr62:       bsr.s   s_corr91        ;Programmcode um 2 Bytes verlängern
                bmi     s_corr2         ;Speicher reicht nicht
                move.w  D1,(A1)         ;Befehl eintragen
                moveq   #0,D1
                move.w  2(A1),D1        ;Index holen
                move.l  D1,2(A1)        ;auf Long reinschreiben
                andi.w  #$FF4F,(A0)
                ori.w   #$20,(A0)       ;Zeileninfo auf Longindex anpassen
                moveq   #6,D0
                move.w  D0,-2(A0)       ;neue Befehlslänge
                clr.b   6(A0)           ;Fehlernummer löschen
                bra     s_corr2
s_corr61:       move.w  #$4EF9,D1       ;JMP eintragen
                bra.s   s_corr62

s_corr81:       lea     4(A1),A2        ;Zieladresse A1 plus 4
                bra.s   s_corr80
s_corr8:        lea     2(A1),A2        ;Zieladresse A1 plus 2
s_corr80:       lea     2(A2),A3        ;Quelladresse
                move.l  program_top(A4),D2
                sub.l   A2,D2           ;Länge des Bereichs
                lsr.l   #1,D2
                bra.s   s_corr82
s_corr83:       swap    D2
s_corr82:       move.w  (A3)+,(A2)+
                dbra    D2,s_corr82     ;Code hochkopieren
                swap    D2
                dbra    D2,s_corr83
                subq.l  #2,program_top(A4) ;Topzeiger korregieren
                rts

s_corr91:       lea     4(A1),A2        ;Quelladresse A1 plus 4
                bra.s   s_corr90
s_corr9:        lea     2(A1),A2        ;Quelladress A1 plus 2
s_corr90:       movea.l program_top(A4),A3
                move.l  program_max(A4),D2
                sub.l   A3,D2           ;verbleibener Platz
                subq.l  #4,D2           ;min. 4 Bytes
                bmi.s   s_corr94        ;reicht nicht
                move.l  A3,D2
                sub.l   A2,D2           ;Länge des Blocks
                lsr.l   #1,D2
                movea.l A3,A2
                addq.l  #2,A3
                bra.s   s_corr92
s_corr93:       swap    D2
s_corr92:       move.w  -(A2),-(A3)
                dbra    D2,s_corr92
                swap    D2
                dbra    D2,s_corr93
                addq.l  #2,program_top(A4) ;Topzeiger korregieren
                moveq   #0,D2
s_corr94:       rts
                ENDPART

************************************************************************
* gibt Fehler in D0 aus                                                *
************************************************************************
                >PART 'error_out'
error_out:      move.l  zeile(A4),-(SP)
                move.l  #$FFFF0010,zeile(A4)
                movem.l D0-D1/A0-A1,-(SP)
                add.w   D0,D0
                lea     err_adr(PC),A1
                adda.w  0(A1,D0.w),A1
                move.w  sdrv_maxcur_x(A4),D1
                sub.w   #16+16,D1
error_out1:     move.b  (A1)+,D0
                beq.s   error_out3
                bsr     chrout
                subq.w  #1,D1
                bra.s   error_out1
error_out2:     move.b  #' ',D0
                bsr     chrout
error_out3:     dbra    D1,error_out2
                sf      block_fl(A4)
                lea     block_entry(PC),A0
error_out4:     ori.b   #2,(A0)+        ;Menüpunkt disablen
error_out5:     tst.b   (A0)+
                bne.s   error_out5
                move.b  (A0),D0         ;Ende des Menüpunktes
                addq.b  #1,D0
                bne.s   error_out4
                moveq   #' ',D0
                moveq   #$FF,D1
                cmp.l   block_anf(A4),D1 ;Block definiert?
                beq.s   error_out8      ;Nein! =>
                move.w  block_anf(A4),D1
                cmp.w   block_end(A4),D1
                bhs.s   error_out8
                st      block_fl(A4)
                lea     block_entry(PC),A0
error_out6:     cmpi.b  #'-',1(A0)      ;'-------' nicht enablen
                beq.s   error_out7
                andi.b  #$FD,(A0)+      ;Menüpunkt enablen
error_out7:     tst.b   (A0)+
                bne.s   error_out7
                move.b  (A0),D0         ;Ende des Menüpunktes
                addq.b  #1,D0
                bne.s   error_out6
                moveq   #'B',D0         ;'B' ausgeben, wenn Block definiert
                bra.s   error_out9
error_out8:     clr.l   menü_save_a0(A4) ;gemerkten Menüeintrag löschen
error_out9:     bsr     chrout
                bsr     draw_lines
                movem.l (SP)+,D0-D1/A0-A1
                move.l  (SP)+,zeile(A4)
                rts
                ENDPART

************************************************************************
* gesamten Screen updaten (wobei neu disassembliert wird)              *
************************************************************************
                >PART 'update_screenb'
update_screenb: movem.l D2-D4,-(SP)
                move.w  D2,D4
                move.w  sdrv_zanz(A4),D2
                moveq   #0,D0
                move.w  top_line(A4),D1
update_s2:      cmp.w   anz_zeilen(A4),D1
                bhs.s   update_s3
                movem.l D0-D7/A1-A6,-(SP)
                pea     dbuffer+2(A4)   ;Buffer setzen
                bsr     disass          ;Zeile disassemblieren
                addq.l  #4,SP           ;Stack korregieren
                movem.l (SP)+,D0-D7/A1-A6
                clr.b   (A0)
                lea     dbuffer+2(A4),A0
                cmp.w   block_end(A4),D1
                bhs.s   update_s1
                cmp.w   block_anf(A4),D1
                blo.s   update_s1
                bsr     write_mline     ;markierte Zeile ausgeben
                bra.s   update_s4
update_s3:      lea     dbuffer+2(A4),A0 ;Zeile löschen
                clr.b   (A0)
update_s1:      bsr     write_line
update_s4:      moveq   #0,D3
                move.b  9(A5),D3
                adda.w  D3,A3
                adda.w  (A5),A6         ;eine Zeile weiter
                lea     10(A5),A5
                addq.w  #1,D1
                addq.w  #1,D0
                dbra    D2,update_s2
                move.l  zeile(A4),-(SP) ;Zeile und Spalte merken
                moveq   #0,D1           ;ak. Zeile
                move.w  D4,D1
                move.w  #-1,zeile(A4)
                move.w  #2,spalte(A4)
                moveq   #4,D4
                bsr.s   dezw_out        ;ausgeben
                moveq   #0,D1
                move.w  save_pos(A4),D1
                move.w  #-1,zeile(A4)
                move.w  #11,spalte(A4)
                moveq   #2,D4
                bsr.s   dezw_out        ;ak. Spalte ausgeben
                bsr     draw_lines
                move.l  (SP)+,zeile(A4) ;Zeile und Spalte zurück
                movem.l (SP)+,D2-D4
                rts
                ENDPART

************************************************************************
* gesamten Screen aus Hintergrundram updaten                           *
************************************************************************
                >PART 'update_screen'
update_screen:  movem.l D0-D2/A0,-(SP)
                lea     lin_tab2(A4),A0
                move.w  sdrv_zanz(A4),D1
                add.w   D1,D1
                adda.w  D1,A0
                move.w  block_anf(A4),D1
                move.w  block_end(A4),D2
                move.w  sdrv_zanz(A4),D0
update_screen2: cmp.w   (A0),D1
                bhi.s   update_screen4
                cmp.w   (A0),D2
                bls.s   update_screen4
                bsr     update_mline
update_screen3: subq.w  #2,A0           ;nächste Zeile
                dbra    D0,update_screen2
                movem.l (SP)+,D0-D2/A0
                rts
update_screen4: bsr     update_line
                bra.s   update_screen3
                ENDPART

************************************************************************
* Div-Long D1.L/D2.B -> D1.L  Rest nach D3.W                           *
************************************************************************
                >PART 'div'
div:            move.l  D1,D3           ;div dividiert d1.l durch d2.b nach d1.l
                ext.w   D2              ;rest in d3.w, d2 unverändert
                clr.w   D3
                swap    D3
                divu    D2,D3
                move.l  D4,-(SP)
                move.w  D3,D4
                move.w  D1,D3
                divu    D2,D3
                swap    D4
                move.w  D3,D4
                swap    D3
                move.l  D4,D1
                move.l  (SP)+,D4
                rts
                ENDPART

************************************************************************
* Dezimal-Zahl in D1 ausgeben                                          *
* Anzahl der Stellen in D4                                             *
************************************************************************
                >PART 'dezw_out'
dezw_out:       movem.l D0-D5/A3,-(SP)
                lea     dez_tab(PC),A3
                move.w  D4,D5
                lsl.w   #2,D5
                lea     4(A3,D5.w),A3
                moveq   #' ',D5
dez_loop:       move.l  -(A3),D3
                moveq   #$D0,D2
subtr:          sub.l   D3,D1
                dbcs    D2,subtr
                neg.b   D2
                move.b  D2,D0
                cmp.b   #'0',D0
                beq.s   dez_zero
                moveq   #'0',D5
dez_zero2:      bsr     chrout
                add.l   D3,D1
                dbra    D4,dez_loop
                movem.l (SP)+,D0-D5/A3
                rts
dez_zero:       move.w  D5,D0
                tst.w   D4
                bne.s   dez_zero2
                moveq   #'0',D0
                bra.s   dez_zero2

dez_tab:        DC.L 1,10,100,1000,10000,100000
                DC.L 1000000,10000000,100000000,1000000000
                ENDPART

************************************************************************
* aktuelle Datei schließen                                             *
************************************************************************
                >PART 'fclose'
fclose:         move.w  fhandle(A4),-(SP)
                move.w  #$3E,-(SP)
                bsr.s   do_trap_1
                addq.l  #4,SP
                rts
                ENDPART

************************************************************************
* Allgemeiner Gemdos-Einsprung                                         *
************************************************************************
                >PART 'do_trap_1'
do_trap_1:      move.l  A0,D0
                lea     _regsav(A4),A0
                movem.l D0-D7/A1-A7,(A0)
                move.l  (SP)+,-(A0)     ;Rücksprungadr retten
                andi    #$FB00,SR       ;IRQs freigeben
                trap    #1
                lea     varbase,A4
                movea.l D0,A0
                movem.l _regsav(A4),D0-D7/A1-A7
                exg     A0,D0
                move.l  _regsav2(A4),(SP)
                rts
                ENDPART

************************************************************************
* TURBOASS.CFG einlesen (bzw. es versuchen)                            *
* D0=-1, wenn nicht gefunden                                           *
************************************************************************
                >PART 'read_cfg'
read_cfg:       lea     cfg_filename(PC),A3
                lea     dbuffer(A4),A0
                bsr     hunt_environment ;Environment-String vorhanden?
                beq.s   do_read_cfg     ;gefunden
                lea     cfg_filename(PC),A3
                bsr.s   do_read_cfg     ;im aktuellen Verzeichnis suchen
                beq.s   read_cfg40
                move.b  #'\',-(A3)
                bsr.s   do_read_cfg     ;in Hauptinhaltsverzeichnis
                beq.s   read_cfg40
                move.w  $0446.w,D0
                add.w   #'A',D0
                move.b  #':',-(A3)
                move.b  D0,-(A3)        ;ab dem Bootlaufwerk
read_cfg3:      bsr.s   do_read_cfg
                beq.s   read_cfg40
read_cfg5:      addq.b  #1,(A3)         ;nicht auf B suchen
                cmpi.b  #'B',(A3)
                beq.s   read_cfg5
                cmpi.b  #'Q',(A3)       ;bis zum Laufwerk 'P:' suchen
                bne.s   read_cfg3
                move.w  #'..',(A3)
                bsr.s   do_read_cfg     ;eine Ordnerebene hochgehen und testen
                beq.s   read_cfg40
read_cfg4:      moveq   #-1,D0          ;Fehler aufgetreten (z.B. nicht gefunden)
read_cfg40:     rts

do_read_cfg:    move.w  #7,-(SP)        ;auch als "hidden" suchen
                move.l  A3,-(SP)
                move.w  #$4E,-(SP)
                trap    #1              ;Fsfirst("PRINTER.CFG",7)
                addq.l  #8,SP
                tst.w   D0
                bpl.s   read_cfg6
                rts                     ;nicht gefunden
read_cfg6:      move.w  #$2F,-(SP)
                trap    #1              ;Fgetdta()
                addq.l  #2,SP
                movea.l D0,A0
                move.l  26(A0),D7       ;Länge der Datei ermitteln

                bsr     free_cfg_mem    ;Speicher bei evtl. 2.Aufruf freigeben

                move.l  D7,-(SP)
                move.w  #$48,-(SP)
                trap    #1              ;Speicher für die Datei reservieren
                addq.l  #6,SP
                tst.l   D0
                beq.s   read_cfg4       ;Speicher reicht nicht
                movea.l D0,A6
                move.l  A6,prt_mem(A4)

                clr.w   -(SP)           ;auch als "hidden" suchen
                move.l  A3,-(SP)
                move.w  #$3D,-(SP)
                trap    #1              ;Fopen("PRINTER.CFG")
                addq.l  #8,SP
                move.w  D0,D6           ;Handle merken
                bmi.s   read_cfg4       ;Fehler beim Öffnen

                move.l  A6,-(SP)
                move.l  D7,-(SP)
                move.w  D6,-(SP)
                move.w  #$3F,-(SP)
                trap    #1              ;Fread()
                lea     12(SP),SP
                move.l  D0,D5           ;Länge der gelesenen Daten merken

                move.w  D6,-(SP)
                move.w  #$3E,-(SP)
                trap    #1              ;Fclose()
                addq.l  #4,SP
                tst.l   D0
                bmi.s   read_cfg4       ;Fehler beim Schließen

                cmp.l   D5,D7           ;ganze Datei auch gelesen?
                bne.s   read_cfg4       ;Fehler, wenn nicht

                cmpi.l  #'GST-',(A6)+   ;Stimmt der Header?
                bne.s   free_cfg_mem
                cmpi.l  #'CFG:',(A6)+
                bne.s   free_cfg_mem    ;falsches Dateiformat!

                lea     prt_type(PC),A0
                moveq   #11,D0          ;max 12 Zeichen kopieren
read_cfg7:      tst.b   (A6)
                beq.s   read_cfg71
                move.b  (A6)+,(A0)+     ;Namen kopieren
                dbra    D0,read_cfg7
read_cfg71:     tst.b   (A6)+           ;den Rest überlösen
                bne.s   read_cfg71
                addq.l  #6,A6           ;allg.Daten überlesen
                move.l  A6,prt_tab1(A4) ;Anfangsadr der Steuerzeichen
                moveq   #0,D0
read_cfg8:      move.b  (A6),D0
                beq.s   read_cfg9       ;Tabellenende suchen
                adda.w  D0,A6
                bra.s   read_cfg8
read_cfg9:      addq.l  #1,A6
                move.l  A6,prt_tab2(A4) ;Anfangsadr der Zeichenkonvertierung
                moveq   #0,D0           ;alles OK!
                rts
                DC.B '   '      ;Buffer für z.B.: 'C:\'
cfg_filename:   DC.B 'TURBOASS.CFG',0
                EVEN

free_cfg_mem:   move.l  prt_mem(A4),D0  ;2.Aufruf?
                beq.s   free_cfg_mem1
                move.l  D0,-(SP)
                move.w  #$49,-(SP)      ;Druckerspeicher freigeben
                trap    #1              ;Mfree()
                addq.l  #6,SP
free_cfg_mem1:  moveq   #-1,D0
                rts
                ENDPART
                >PART 'Tokenizer'
************************************************************************
* Zeile in A0 in Puffer codieren                                       *
* A5 ist Adresse der Zeileninfo                                        *
* A6 zeigt auf Programmcode                                            *
************************************************************************
code_line6:     movem.l D0-D1/A0-A1,-(SP)
                lea     upper_tab(PC),A1
                moveq   #0,D1
                moveq   #0,D0
                tst.b   upper_flag(A4)
                bpl.s   code_line61
                lea     lower_tab(PC),A1
code_line61:    move.b  (A0)+,D0
                beq.s   code_line62
                cmp.b   #';',D0
                beq.s   code_line62
                cmp.b   D1,D0           ;Ende des Strings ?
                bne.s   code_line63     ;nein
                moveq   #0,D1
                bra.s   code_line61
code_line63:    tst.b   D1
                bne.s   code_line61
                cmp.b   #$22,D0         ;"
                beq.s   code_line64
                cmp.b   #$27,D0         ;'
                beq.s   code_line64
                move.b  0(A1,D0.w),-1(A0) ;Zeichen konvertieren
                bra.s   code_line61
code_line64:    move.b  D0,D1           ;als Endekennung merken
                bra.s   code_line61
code_line62:    movem.l (SP)+,D0-D1/A0-A1
                bra.s   code_line5

code_line:      movem.l D1-A6,-(SP)
                sf      part_flag(A4)
                lea     zeingabe(A4),A0
                lea     zreserve(A4),A1
                moveq   #63,D0
code_line0:     move.l  (A0)+,(A1)+
                dbra    D0,code_line0
                clr.b   (A1)
                lea     entry_buffer(A4),A0 ;Buffer für Adressen der Einträge
                move.l  A0,entry_pointer(A4) ;Zeiger auf Anfang setzen
                lea     zreserve(A4),A0
                moveq   #0,D5           ;Nummer des Operanten
                lea     op_buffer(A4),A3 ;A3 zeigt auf Zeilen-Info
                lea     16(A3),A2       ;A2 zeigt auf Operanten des Opcodes
                moveq   #0,D0
                move.l  D0,(A3)         ;Puffer löschen
                move.l  D0,14(A3)
                move.l  D0,18(A3)
                move.l  D0,22(A3)
                move.l  D0,10(A3)       ;Zeiger auf Remark löschen
                clr.w   8(A3)           ;Länge des Remarks
                move.w  D0,4(A3)
                move.w  #-1,6(A3)
                addq.w  #2,A0           ;Zeiger auf Eingabe
                bsr     cut_space
                move.b  (A0),D0
                beq     code_rts3
                cmp.b   #';',D0
                beq     _remark
                cmp.b   #'*',D0
                beq     _remark
                tst.b   upper_flag(A4)
                bne     code_line6
code_line5:     move.l  A0,D7           ;Zeiger retten
                bsr     search          ;Befehl suchen
                cmpa.l  #0,A1
                bne     code_line2      ;Befehl gefunden
                movea.l D7,A0           ;Zeiger rekonstruieren
                bsr     search_mactrap  ;Trap-Makro suchen
                cmpa.l  #0,A1
                bne     code_line21     ;Macro gefunden
                movea.l D7,A0           ;Zeiger rekonstruieren
                move.l  SP,D7
                bsr     t_search_label  ;Labelnamen in der Labeltabelle suchen
                move.w  D0,D1           ;Indexnummer retten
                tst.b   4(A1)           ;wurde Label schon definiert ?
                bpl.s   code_line4      ;nein
                cmp.w   6(A5),D0        ;Definition in derselben Zeile
                beq.s   code_line4      ;ja, keine doppelte Deklaration
                tst.b   8(A1)           ;lokales Symbol?
                beq.s   code_line42     ;ja, keine doppelte Deklaration
                tst.b   load_fl(A4)
                bne.s   code_line42     ;es wird geladen
                moveq   #4,D0           ;Redefinitions Fehler ausgeben
                bsr     error_out
                movem.l D0-A6,-(SP)
                suba.l  A4,A0
                suba.w  #zreserve+2,A0
                move.w  A0,spalte(A4)
                move.l  zeile(A4),D2    ;Position retten
                moveq   #0,D1           ;Spalte ausgeben
                move.w  A0,D1
                move.l  #$FFFF000B,zeile(A4)
                moveq   #2,D4
                bsr     dezw_out
                move.l  D2,zeile(A4)
                bsr     draw_lines
                movem.l (SP)+,D0-A6
                bsr     cursor_on
code_line7:     bsr     tastchk         ;wartet auf Taste
                bpl.s   code_line7      ;keine gedrückt
                bsr     cursor_off
                move.l  D0,save_redef_key(A4)
                cmp.w   #13,D0          ;Return ?
                bne     redef_error     ;nein, dann doppelte Deklaration
                clr.l   save_redef_key(A4)
code_line42:    ori.b   #$80,6(A1)      ;Flag für doppelte Deklaration
                bra.s   code_line41
code_line4:     sf      5(A1)           ;not-reloc-Flag löschen
code_line41:    move.w  D1,6(A3)        ;Labelnummer
                bsr     cut_space
                tst.b   (A0)
                beq     code_rts3       ;Zeilenende
                cmpi.b  #';',(A0)
                beq     _remark
                cmpi.b  #'*',(A0)
                beq     _remark
                move.l  A0,D7
                bsr     search          ;Befehl in der Tabelle suchen
                move.l  A1,D0
                bne.s   code_line2      ;Befehl gefunden
                movea.l D7,A0
                bsr     search_mactrap  ;Trap-Makro suchen
                move.l  A1,D0
                beq     unknow_error    ;gleich null, Unbekannter Befehl
code_line21:    moveq   #$0F,D0
                and.b   (A1),D0         ;1.Byte des Opcodes
                or.b    #$A0,D0         ;zum LineA-Opcode machen
                move.b  D0,14(A3)       ;und in Puffer schreiben
                move.b  1(A1),15(A3)    ;2.Byte des Opcodes
                move.w  #2,(A3)         ;Länge der Zeile auf 2
                bsr     get_trap_par    ;Parameter auswerten
                bne     syntax_error    ;Fehler bei Parametern
                bra.s   _special1       ;Remark holen
code_line2:     tst.b   12(A1)
                bne.s   _special        ;Spezialmnemonics
                move.w  14(A1),14(A3)   ;Befehlsbits in Puffer schreiben
                move.w  #2,(A3)         ;Länge der Zeile auf 2 setzen
_special:       bsr     cut_space
                moveq   #0,D2
                moveq   #0,D0
                move.b  (A0),D0         ;nächste Zeichen
                move.l  SP,D7           ;Rücksprungadresse sichern
                move.w  12(A1),D4       ;Daten für unmittelbaren Operanten
                movea.l 8(A1),A1        ;Adresse der Routine holen
                jsr     (A1)            ;Sprung zur Operantenauswertung
_special1:      moveq   #0,D0
                bsr     cut_space
                move.b  (A0),D0
                cmp.b   #';',D0
                beq     _remark
                cmp.b   #'*',D0
                beq     _remark
                tst.b   D0
                bne     syntax_error
code_rts3:      move.b  2(A5),D1
                cmp.b   #6,D1
                blo.s   code_rts4
                cmp.b   #10,D1
                bhi.s   code_rts4       ;wurde eine Zeile mit TEXT, DATA oder
                cmp.b   2(A3),D1        ;BSS überschrieben, dann Pointer löschen
                beq.s   code_rts4
                btst    #0,D1           ;gar kein Opcode?
                bne.s   code_rts4       ;genau!
                and.w   #$FF,D1
                move.w  #$FFFF,text_pointer-6(A4,D1.w)
code_rts4:      moveq   #0,D0
                clr.w   error_pos(A4)
                movem.l (SP)+,D1-A6
                rts
code_rts2:      sf      macro_flag(A4)  ;Flag löschen
                suba.l  A4,A0
                suba.w  #zreserve+2,A0
                move.w  A0,error_pos(A4)
                lea     entry_buffer(A4),A0 ;Anfang des Puffer
                movea.l entry_pointer(A4),A1 ;Zeiger in Puffer
                movea.l label_top(A4),A3
                moveq   #0,D1
                bra.s   code_rts23
code_rts22:     movea.l (A1),A2         ;Adresse des Eintrags
                move.l  D1,(A2)+
                move.l  D1,(A2)+
                move.l  D1,(A2)+
                move.l  D1,(A2)+        ;Eintrag löschen
                move.l  D1,(A2)+
                move.l  D1,(A2)+
                move.l  D1,(A2)+
                move.l  D1,(A2)+
                move.b  #1,-1(A2)       ;Eintrag als frei erklären
                cmpa.l  A3,A2           ;letzter Eintrag
                blo.s   code_rts23      ;nein
                lea     -32(A3),A3      ;label_top erniedrigen
                subq.w  #1,label_top_ind(A4)
code_rts23:     subq.l  #4,A1           ;nächste Adresse
                cmpa.l  A0,A1           ;mit Startadresse vergleichen
                bhs.s   code_rts22      ;weiter
                move.l  A3,label_top(A4) ;label_top auf neuen Wert setzen
                movem.l (SP)+,D1-A6
                rts
_remark:        bsr     compress_remark ;Remark ab A0 kompressen
                bra     code_rts3
syntax_error:   moveq   #1,D0           ;falsches Zeichen
                moveq   #0,D1
                move.b  2(A3),D1        ;Pseudoopcode holen
                subq.w  #6,D1
                bmi.s   code_rts2
                cmp.w   #4,D1           ;TEXT,DATA oder BSS
                bhi.s   code_rts2
                move.w  #$FFFF,text_pointer(A4,D1.w) ;Fehler beim Befehl->Pointer
                bra.s   code_rts2       ;zurücksetzen
dekl_error:     moveq   #2,D0           ;Fehler bei Labeldeklaration
                bra.s   code_rts2
operand_err:    neg.w   D0              ;Fehler bei Operantenauswertung
                bra.s   code_rts2
unknow_error:   move.b  -(A0),D0
                beq.s   unknow_err3
                cmp.b   #'.',D0
                beq.s   unknow_err2
                cmp.b   #' ',D0
                bne.s   unknow_error
unknow_err3:    moveq   #3,D0           ;unbekannter Befehl
                bra     code_rts2
unknow_err2:    move.b  #' ',(A0)       ;Extension löschen
                move.l  A0,D0
                sub.l   A4,D0
                subi.w  #zreserve+2,D0
unknow_err4:    cmpi.b  #' ',-(A0)
                dbeq    D0,unknow_err4  ;Anfang des Befehls suchen
                addq.l  #1,A0
                bsr     search
                move.l  A1,D0
                beq.s   unknow_err3
                moveq   #10,D0          ;'Unerlaubte Extension'
                bra     code_rts2
redef_error:    moveq   #4,D0           ;doppelte Deklaration
                bra     code_rts2

************************************************************************
* wertet Parameter für Macintosh Trapmakros aus                        *
* ->A1 zeigt auf den Eintrag                                           *
* ->14(A3) zeigt auf den Opcode                                        *
* <-D0: Fehlercode (0=kein Fehler)                                     *
************************************************************************
get_trap_par:   movem.l D1-D4/A2/A5-A6,-(SP)
                move.b  (A1),D0
                and.w   #$F0,D0         ;Flags für Parameter
                beq.s   get_trap_par8   ;keine Parameter=>
                lea     search_tab(PC),A2
                lsr.w   #4,D0           ;durch 16
                lea     dis_ptraptab(PC),A6
                cmp.b   (A6)+,D0        ;zu großer Wert?
                bhi.s   get_trap_par8   ;Ja! => keine Parameter
get_trap_par1:  subq.b  #1,D0           ;Parameter gefunden?
                beq.s   get_trap_par3   ;Ja! =>
get_trap_par2:  tst.b   (A6)+           ;einen Parameter überlesen
                bne.s   get_trap_par2
                bra.s   get_trap_par1   ;und weiter =>
get_trap_par3:  move.l  A6,D4           ;Pointer auf die erlaubten Strings
get_trap_par4:  movea.l D4,A6
                bsr     cut_space       ;Spaces überlesen
                cmpi.b  #',',(A0)       ;folgt ein Komma?
                bne.s   get_trap_par8   ;keine (weiteren) Parameter=> fertig
                addq.l  #1,A0           ;das Komma ignorieren
                move.l  A0,D2           ;Pointer auf den Eingabestring retten
get_trap_par5:  movea.l D2,A0
                moveq   #0,D0
                move.b  (A6)+,D0        ;Ende der Liste? (= Nulloffset)
                beq.s   get_trap_par7   ;Ja! => String nicht gefunden => Fehler
                lea     -1(A6,D0.w),A5  ;Zeiger auf den String (+ Header)
                move.b  (A5)+,D1        ;die Flags retten
get_trap_par6:  move.b  (A0),D0         ;Zeichen aus dem Eingabestring holen
                move.b  0(A2,D0.w),D0   ;in einen Großbuchstaben wandeln
                beq.s   get_trap_par5   ;Ende der Eingabe? Ja! => nächster String
                addq.l  #1,A0
                moveq   #$7F,D3
                and.b   (A5)+,D3        ;und aus dem Vergleichsstring ein Zeichen
                cmp.b   D0,D3           ;sind die Buchstaben gleich?
                bne.s   get_trap_par5   ;Nein! => zum nächsten String
                tst.b   -1(A5)          ;Wortende?
                bpl.s   get_trap_par6   ;Nein! => weiter vergleichen
                moveq   #$0F,D0
                and.w   D1,D0           ;die Maske
                not.b   D0              ;zum Löschen invertieren
                and.b   D0,14(A3)       ;die entsprechenden Bits löschen
                lsr.b   #4,D1
                or.b    D1,14(A3)       ;und die neuen einsetzen
                bra.s   get_trap_par4   ;zum nächsten Parameter
get_trap_par7:  moveq   #1,D0           ;Syntax Error
                bra.s   get_trap_par9
get_trap_par8:  moveq   #0,D0           ;kein Fehler
get_trap_par9:  movem.l (SP)+,D1-D4/A2/A5-A6
                rts

************************************************************************
*  wandelt Zeichen im Eingabepuffer in Großbuchstaben                  *
************************************************************************
zupper:         movem.l D1/A0-A1,-(SP)
                lea     upper_tab(PC),A1
                moveq   #0,D1
zupper_loop:    move.b  (A0)+,D1
                beq.s   zupper2
                cmp.b   #' ',D1
                beq.s   zupper_end
                cmp.b   #',',D1
                beq.s   zupper_end
                cmp.b   #';',D1
                beq.s   zupper_end
                cmp.b   #'(',D1
                beq.s   zupper_end
                move.b  0(A1,D1.w),-1(A0)
                bra.s   zupper_loop
zupper2:        move.b  #' ',-1(A0)
zupper_end:     movem.l (SP)+,D1/A0-A1
                rts

************************************************************************
*  Sonderbefehle                                                       *
************************************************************************
t_switch:       move.w  #$4000,2(A3)
                moveq   #0,D0
                bra     t_if2           ;Ausdruck holen
t_case:         move.b  (A0),D0         ;Zeichen holen
                beq.s   t_case2         ;Ende der Zeile
                cmp.b   #';',D0
                beq.s   t_case2         ;Remark
                cmp.b   #'*',D0
                beq.s   t_case2         ;Remark
                bsr     get_wert        ;Zahl holen
                tst.b   2(A3)           ;Symbol oder Formel ?
                bne     synt_error      ;nicht erlaubt
                move.b  #$42,2(A3)
                move.l  D3,D0
                ext.l   D0
                cmp.l   D3,D0
                bne     val_error
                move.w  D3,4(A3)        ;Wert ins Zeileninfo
                rts
t_case2:        move.w  #$4280,2(A3)    ;Kennung für kein Parameter
                rts
t_ends:         move.w  #$4400,2(A3)
                rts
t_global:       bsr     next_free_entry ;Eintrag anfordern
                move.b  #$FA,31(A1)     ;Kennung für GLOBAL
                move.w  D0,4(A3)        ;Index eintragen
                move.w  #$4600,2(A3)
                movea.l A1,A2
                moveq   #0,D2
t_global3:      bsr     t_search_label  ;holt Symbolnamen
                move.w  D0,(A2)+        ;Index in Eintrag
                bsr     cut_space
                cmpi.b  #',',(A0)+
                bne.s   t_global2
                bsr     cut_space
                addq.w  #1,D2           ;Zähler erhöhen
                cmp.w   #15,D2          ;max. Anzahl
                blt.s   t_global3
                movea.l D7,SP
                moveq   #-16,D0         ;Zu viele Parameter
                bra     operand_err
t_global2:      move.b  #$80,(A2)       ;Endmarkierung in Eintrag setzen
                subq.l  #1,A0
                rts
t_common:       move.w  #$4800,2(A3)
                moveq   #0,D0
                move.w  6(A3),D0        ;Index der Labeldefinition
                bpl.s   t_common2       ;Symbol am Anfang der Zeile
                bsr     t_search_label  ;holt Symbolnamen (Index in D0)
                bsr     chk_com         ;prüft auf Komma
                move.w  D0,6(A3)        ;Index sichern
t_common2:      bra     t_if2           ;Ausdruck holen

t_default:      bsr     get_wert
                tst.w   2(A3)
                bne     synt_error      ;nur Dez erlaubt
                move.b  #$4A,2(A3)
                cmp.w   #12,D3
                bhi     val_error
                move.w  D3,4(A3)        ;Wert eintragen
                rts
t_part:         cmpi.w  #$52F0,2(A5)    ;geschützter PART ?
                beq.s   t_part2         ;ja
                move.w  #$52FF,D0
                move.w  #$5200,2(A3)
                cmp.w   2(A5),D0        ;wird ein PART-Befehl nur geändert ?
                beq.s   t_part1         ;ja
                st      part_flag(A4)   ;Flag für Aktualisierung setzen
                bra     t_fail3         ;String holen
t_part1:        move.w  D0,2(A3)        ;PART eingeklappt lassen
                bra     t_fail3
t_part2:        move.w  #-47,D0         ;Änderung nicht erlaubt
                movea.l D7,SP
                bra     operand_err
t_endpart:      move.w  #$5400,2(A3)
                st      part_flag(A4)   ;Flag für Aktualisierung setzen
                rts
t_isymbol:      bsr     next_free_entry ;freien Eintrag suchen
                move.b  #$FC,31(A1)
                movea.l A1,A2
                move.w  D0,4(A3)
                moveq   #31,D1
                bsr.s   t_get_name
                move.w  #$5600,2(A3)
                rts
t_get_name:     bsr     cut_space
                move.b  (A0)+,D2
                cmp.b   #$22,D2
                beq.s   t_get_nam5
                cmp.b   #$27,D2
                beq.s   t_get_nam5
                subq.l  #1,A0
                moveq   #0,D2
t_get_nam5:     bsr     zupper          ;Filenamen in Großbuchstaben
                moveq   #0,D0
t_get_nam2:     cmp.b   (A0),D2
                beq.s   t_get_nam4
                cmpi.b  #'*',(A0)
                beq.s   t_get_nam21     ;* und ? erlaubt
                cmpi.b  #'?',(A0)
                beq.s   t_get_nam21
                cmpi.b  #'-',(A0)
                blo.s   t_get_nam4
t_get_nam21:    move.b  (A0)+,(A2)+
                addq.w  #1,D0
                cmp.w   D1,D0           ;maximale Länge
                blo.s   t_get_nam2
                movea.l D7,SP
                moveq   #-27,D0         ;Filename zu lang
                bra     operand_err
t_get_nam4:     tst.b   D0              ;0 Zeichen
                beq.s   t_get_nam3
                tst.w   D2
                beq     return
                cmp.b   (A0),D2
                bne.s   t_get_nam3
                addq.l  #1,A0
                clr.b   (A2)            ;Nullbyte ans Ende
                bra     cut_space
t_get_nam3:     movea.l D7,SP
                moveq   #-28,D0         ;illegaler Filename
                bra     operand_err

t_ibytes:       bsr     next_free_entry
                move.b  #$FB,31(A1)     ;Markierung für IBYTES
                clr.l   (A1)
                clr.l   4(A1)
                lea     12(A1),A2       ;Beginn des Filenamen
                move.w  D0,4(A3)        ;Index
                moveq   #19,D1
                bsr.s   t_get_name      ;Filenamen holen
                cmpi.b  #',',(A0)
                bne.s   t_ibytes3
                addq.w  #1,A0
                bsr     cut_space
                moveq   #0,D1
                cmpi.b  #',',(A0)
                beq.s   t_ibytes2       ;kein Parameter für Anzahl
                bsr     get_wert
                move.w  2(A3),D1
                cmpi.w  #1,D1
                bhi     synt_error      ;nur Zahlen sind zugelassen
                move.l  D3,(A1)         ;Anzahl eintragen
                bsr     cut_space
                cmpi.b  #',',(A0)
                bne.s   t_ibytes5
t_ibytes2:      addq.l  #1,A0
                bsr     get_wert
                cmpi.w  #1,2(A3)        ;Zahlflag für Position
                bhi     synt_error
                move.l  D3,4(A1)        ;Position eintragen
t_ibytes5:      lsl.w   #4,D1
                or.w    D1,2(A3)        ;Zahlflag für Anzahl
t_ibytes3:      ori.w   #$1E00,2(A3)
                rts
t_path:         bsr     next_free_entry
                move.b  #$FC,31(A1)
                movea.l A1,A2
                move.w  D0,4(A3)
                moveq   #31,D1
                bsr     t_get_name
                move.w  #$2200,2(A3)
                rts
t_outp:         bsr     next_free_entry
                move.b  #$FC,31(A1)
                movea.l A1,A2
                move.w  D0,4(A3)
                moveq   #31,D1
                bsr     t_get_name
                move.w  #$2600,2(A3)
                bsr     cut_space
                cmpi.b  #',',(A0)       ;folgt Komma
                bne.s   t_outp2         ;nein
                addq.l  #1,A0
t_breakp1:      bsr     cut_space
                lea     14(A3),A1       ;Zeiger auf Programmcode
                move.b  (A0)+,D2        ;Zeichen holen
                cmp.b   #$27,D2
                beq.s   t_outp6
                cmp.b   #$22,D2
                bne     synt_error      ;keine Anführungszeichen -> Fehler
t_outp6:        moveq   #-1,D1
t_outp3:        addq.w  #1,D1
                move.b  (A0)+,D0        ;Zeichen holen
                move.b  D0,(A1)+        ;Zeichen kopieren
                beq.s   t_outp4         ;Ende der Zeile
                cmp.b   D2,D0           ;Endezeichen ?
                bne.s   t_outp3         ;nein
t_outp4:        clr.b   -(A1)           ;letztes Zeichen löschen
                clr.b   1(A1)
                tst.w   D1              ;Länge des String
                beq.s   t_outp2         ;null
                addq.w  #2,D1
                and.w   #$FFFE,D1       ;begradigen
                move.w  D1,(A3)         ;Länge eintragen
t_outp2:        rts
t_breakp:       move.w  #$5A00,2(A3)
                bsr.s   t_breakp1       ;String holen
                tst.w   D1
                beq     synt_error      ;Länge null nicht erlaubt
                rts

t_if:           lsr.w   #8,D4
                subq.w  #2,D4
                ori.w   #$2800,D4
                move.w  D4,2(A3)
                cmp.b   #$0E,D4
                blo.s   t_if2
                bsr     cut_space       ;IFD und IFND
                bsr     t_search_label
                move.w  D0,4(A3)
                rts
t_if2:          moveq   #2,D5
                movem.l D0-D1/D4/A1,-(SP)
                bsr     cut_space
                bsr     get_formel
                move.w  D3,4(A3)
                movem.l (SP)+,D0-D1/D4/A1
                rts
t_set:          move.w  #$3A00,2(A3)
                moveq   #0,D1
                move.w  6(A3),D1
                bmi     synt_error
                movea.l label_base(A4),A1
                moveq   #0,D0
                move.w  D1,D0
                lsl.l   #5,D0
                cmpi.b  #$FE,5(A1,D0.l) ;EQU-Eintrag ?
                beq.s   t_set2          ;nicht möglich !
                moveq   #0,D0
                bra.s   t_if2
t_set2:         andi.b  #$7F,6(A1,D0.l) ;Bit für doppelte Definition löschen
                movea.l D7,SP
                moveq   #-4,D0
                bra     operand_err     ;'doppelte Deklaration'
t_else:         move.w  #$2A00,2(A3)
                rts
t_endc:         move.w  #$2C00,2(A3)
                rts
t_endr:         move.w  #$3E00,2(A3)
                rts
t_fail:         move.w  #$3600,2(A3)
t_fail3:        move.b  (A0),D0
                beq.s   t_fail2
                cmp.b   #';',D0
                bne.s   t_dxb0
t_fail2:        move.w  #-1,4(A3)
                rts
t_dxb:          move.w  #$3000,2(A3)
t_dxb0:         move.b  (A0)+,D2        ;Endekennung
                cmp.b   #$27,D2
                beq.s   t_dxb1
                cmp.b   #$22,D2
                bne     synt_error
t_dxb1:         bsr     next_free_entry
                move.b  #$FC,31(A1)
                movea.l A1,A2
                move.w  D0,4(A3)
                moveq   #29,D1
t_dxb2:         move.b  (A0)+,D0
                beq.s   t_dxb3
                cmp.b   D2,D0
                beq.s   t_dxb3
                move.b  D0,(A2)+
                dbra    D1,t_dxb2
                cmp.b   (A0)+,D2
                beq.s   t_dxb3
                moveq   #-30,D0         ;'String zu lang'
                movea.l D7,SP
                bra     operand_err
t_dxb3:         clr.b   (A2)            ;Nullbyte als Abschluß
                rts
t_dxset:        bsr     get_wert        ;Breite holen
                move.w  2(A3),D0
                cmp.w   #1,D0           ;nur Zahlen zulassen
                bhi     synt_error
                lsl.b   #4,D0
                ori.w   #$3200,D0       ;Code einsetzen
                tst.l   D3              ;Null nicht erlaubt
                beq     val_error
                cmp.l   #$FF,D3
                bhi     val_error
                move.b  D3,4(A3)        ;Anzahl eintragen
                bsr     cut_space
                cmpi.b  #',',(A0)
                bne.s   t_dxse1         ;kein Füllwert
                addq.w  #1,A0
                bsr     get_wert        ;Füllwert holen
                tst.b   2(A3)           ;Konstanten verboten
                bne     synt_error
                cmp.l   #$FF,D3
                bhi     val_error
                move.b  D3,5(A3)        ;Füllwert eintragen
t_dxse1:        or.w    D0,2(A3)        ;Flags eintragen
                rts
t_base:         move.w  #$2000,2(A3)
                bsr     get_adrreg
                bmi     t_base2
                move.b  D0,3(A3)
t_base9:        bsr     chk_com
                lea     allowed_chars(PC),A1
                move.b  (A0),D0
                cmp.b   #'*',D0
                beq.s   t_base3
                rol.w   #8,D0
                move.b  1(A0),D0        ;ersten beiden Zeichen in D0
                andi.w  #$DFDF,D0       ;Großbuchstaben
                cmp.w   #'TE',D0
                beq.s   t_base4
                cmp.w   #'DA',D0
                beq.s   t_base5
                cmp.w   #'BS',D0
                beq.s   t_base6
                cmp.w   #'OF',D0
                beq     t_base61
t_base8:        move.l  A0,D1           ;Zeiger retten
                bsr     t_search_label
                move.w  D0,4(A3)        ;Index eintragen
                cmpi.b  #' ',(A0)
                beq.s   t_base81        ;keine Formel
                cmpi.b  #';',(A0)
                beq.s   t_base81        ;keine Formel
                movea.l D1,A0           ;Zeiger zurücksetzen
                bra     t_if2           ;Formel holen
t_base81:       rts
t_base3:        addq.w  #2,A0
                move.w  #$8000,4(A3)
                rts
t_base4:        bsr     t_base7
                cmp.w   #'XT',D0
                bne.s   t_base8
                moveq   #0,D0
                move.b  4(A0),D0
                tst.b   0(A1,D0.w)      ;Folgezeichen im Label erlaubt
                bne.s   t_base8         ;ja
                addq.l  #4,A0
                move.w  #$8006,4(A3)
                rts
t_base5:        bsr.s   t_base7
                cmp.w   #'TA',D0
                bne.s   t_base8
                moveq   #0,D0
                move.b  4(A0),D0
                tst.b   0(A1,D0.w)      ;Folgezeichen im Label erlaubt
                bne.s   t_base8         ;ja
                addq.l  #4,A0
                move.w  #$8008,4(A3)
                rts
t_base6:        move.b  2(A0),D0
                and.b   #$DF,D0
                cmp.b   #'S',D0
                bne.s   t_base8
                moveq   #0,D0
                move.b  3(A0),D0
                tst.b   0(A1,D0.w)      ;Folgezeichen im Label erlaubt
                bne.s   t_base8         ;ja
                addq.l  #3,A0
                move.w  #$800A,4(A3)
                rts
t_base61:       move.b  2(A0),D0
                and.b   #$DF,D0
                cmp.b   #'F',D0
                bne     t_base8
                moveq   #0,D0
                move.b  3(A0),D0
                tst.b   0(A1,D0.w)      ;Folgezeichen im Label erlaubt
                bne     t_base8
                addq.l  #3,A0
                move.w  #$8002,4(A3)
                rts
t_base7:        move.b  2(A0),D0
                rol.w   #8,D0
                move.b  3(A0),D0
                and.w   #$DFDF,D0
                rts
t_base2:        move.b  (A0),D0
                rol.w   #8,D0
                move.b  1(A0),D0        ;ersten beiden Zeichen in D0
                and.w   #$DFDF,D0       ;Großbuchstaben
                cmp.w   #'DC',D0
                bne     synt_error
                bsr.s   t_base7
                cmp.w   #$0E57,D0
                beq.s   t_basea
                cmp.w   #$0E42,D0
                bne     synt_error
                move.b  #9,3(A3)        ;DC.B
                addq.l  #4,A0
                bra     t_base9
t_basea:        move.b  #8,3(A3)        ;DC.W
                addq.l  #4,A0
                bra     t_base9

t_section:      bsr     search          ;nächstes Wort holen
                cmpa.l  #0,A1
                beq     synt_error
                tst.b   13(A1)          ;TEXT,DATA oder BSS
                beq     synt_error      ;nein
                cmpi.b  #3,13(A1)
                bhi     synt_error
                movea.l 8(A1),A1        ;Sprungadresse holen
                jmp     (A1)            ;Sprung in Routine

t_reg:          move.w  #$1C00,2(A3)
                moveq   #0,D1
                move.w  6(A3),D1
                bmi     synt_error
                bsr     cut_space
                moveq   #0,D3
                bsr     t_movem3        ;Registerliste holen
                move.w  6(A3),D1
                movea.l label_base(A4),A1
                lsl.l   #5,D1
                move.l  D3,0(A1,D1.l)   ;und speichern
                move.b  #1,5(A1,D1.l)   ;Reglist-Flag
                rts
t_equg:         move.w  #$5800,2(A3)
                moveq   #0,D1
                move.w  6(A3),D1
                bmi.s   synt_error
                moveq   #2,D5
                bsr     get_wert
                movea.l label_base(A4),A1
                lsl.l   #5,D1
                ori.b   #$60,4(A1,D1.l) ;Konstantenbit und Global setzen
                tst.b   4(A3)
                bne.s   t_equ2          ;Label oder Formel
                move.l  D3,0(A1,D1.l)
                move.b  #$FE,5(A1,D1.l) ;Konstanten-Flag setzen
                rts
t_equ:          move.w  #$0E00,2(A3)
                moveq   #0,D1
                move.w  6(A3),D1
                bmi.s   synt_error      ;keine Symboldef
                lsl.l   #5,D1           ;mal 32
                movea.l label_base(A4),A1
                tst.b   8(A1,D1.l)      ;lokales Symbol
                beq     t_set           ;ja, dann in SET wandeln
                moveq   #2,D5
                bsr     get_wert
                ori.b   #$40,4(A1,D1.l) ;Konstantenbit für Symboltabelle setzen
                tst.b   4(A3)
                bne.s   t_equ2          ;Label oder Formel
                move.l  D3,0(A1,D1.l)
                move.b  #$FE,5(A1,D1.l) ;Konstanten-Flag setzen
                rts
t_equ2:         bsr     get_quick
                move.w  #$0E01,2(A3)
                rts

synt_error:     movea.l D7,SP
                moveq   #-1,D0
                bra     operand_err

t_rsset:        bsr     get_wert
                tst.b   2(A3)
                bne.s   t_rsset2        ;Symbol oder Formel
                move.w  2(A3),D0
                andi.w  #$06,D0
                bne.s   synt_error      ;Bin und Ascii verboten
                cmp.l   #$0FFFFF,D3     ;maximaler Wert
                bls.s   t_rsset3
                move.l  D3,D1
                andi.l  #$FFF80000,D1
                cmp.l   #$FFF80000,D1
                bne     val_error
                and.l   #$0FFFFF,D3
t_rsset3:       move.w  2(A3),D0
                lsl.w   #4,D0
                ori.w   #$1A00,D0       ;Befehlskennung
                move.l  D3,2(A3)        ;Wert eintragen
                or.w    D0,2(A3)
                rts
t_rsset2:       move.w  #$1A40,D0       ;Kennung für Symbol
                btst    #6,3(A3)        ;Vorzeichenbit bei Symbolen
                beq.s   t_rsset4        ;plus
                or.b    #$80,D0         ;minus
t_rsset4:       move.l  D3,2(A3)        ;Index eintragen
                or.w    D0,2(A3)        ;Flags übertragen
                rts
t_rsreset:      move.w  #$1400,2(A3)
                rts
t_rsbss:        move.w  #$1600,2(A3)
                rts
t_rseven:       move.w  #$2E00,2(A3)
                rts
t_end:          move.w  #$1200,2(A3)
                rts
t_opt:          move.w  #$1000,2(A3)
                moveq   #0,D3
t_opt6:         bsr     cut_space
                move.b  (A0)+,D0
                andi.b  #$DF,D0
                moveq   #0,D1
t_opt2:         cmp.b   t_opt7(PC,D1.w),D0
                beq.s   t_opt3
                addq.w  #1,D1
                cmp.w   #7,D1
                blt.s   t_opt2
                bra     synt_error
t_opt3:         add.w   D1,D1
                bset    D1,D3           ;Option setzen
                move.b  (A0)+,D0
                addq.w  #1,D1
                bclr    D1,D3
                cmp.b   #'+',D0
                beq.s   t_opt4
                cmp.b   #'-',D0
                bne     synt_error
                bset    D1,D3
t_opt4:         bsr     cut_space
                move.b  (A0)+,D0
                beq.s   t_opt5
                cmp.b   #',',D0
                beq.s   t_opt6
                cmp.b   #'*',D0
                beq.s   t_opt5
                cmpi.b  #';',D0
                bne     synt_error
t_opt5:         subq.w  #1,A0
                move.w  D3,4(A3)
                rts
t_opt7:         DC.B 'XDLFPOW'
                EVEN
t_org:          move.w  #$3800,2(A3)
                move.w  #4,(A3)
                moveq   #2,D5
                bsr     get_wert
                cmpi.w  #2,4(A3)
                bhi     synt_error      ;nur Zahl erlaubt
                move.l  D3,14(A3)       ;Adresse eintragen
                bsr     cut_space
                cmpi.b  #',',(A0)
                bne.s   t_org2
                addq.l  #1,A0
                cmpi.b  #'^',(A0)+
                bne     synt_error
                move.b  #1,3(A3)
t_org2:         rts
t_even:         move.w  #$0C00,2(A3)
                clr.w   (A3)
                rts
t_text:         move.w  text_pointer(A4),D1
                cmp.w   D6,D1           ;= aktuelle Zeile?
                beq.s   t_text2         ;Ja! => alles ok!
                cmp.w   #$FFFF,D1       ;Nicht definiert?
                beq.s   t_text2         ;Ja! => alles ok!
t_text3:        movea.l D7,SP
                moveq   #-4,D0
                bra     operand_err
t_text2:        move.w  #$0600,2(A3)
                clr.w   (A3)
                move.w  D6,text_pointer(A4)
                rts
t_data:         move.w  data_pointer(A4),D1
                cmp.w   D6,D1           ;= aktuelle Zeile?
                beq.s   t_data2         ;Ja! => alles ok!
                cmp.w   #$FFFF,D1       ;Nicht definiert?
                bne.s   t_text3         ;Nein! => Fehler
                move.w  text_pointer(A4),D0
                cmp.w   #$FFFF,D0
                beq.s   t_data2         ;Text-Pointer nicht definiert => ok
                cmp.w   D0,D6
                bls.s   t_data3         ;Text-Pointer hinter dem Data => Fehler
t_data2:        move.w  #$0800,2(A3)
                clr.w   (A3)
                move.w  D6,data_pointer(A4)
                rts
t_data3:        movea.l D7,SP
                moveq   #-26,D0
                bra     operand_err
t_bss:          move.w  bss_pointer(A4),D1
                cmp.w   D6,D1           ;= aktuelle Zeile?
                beq.s   t_bss2          ;Ja! => alles ok!
                cmp.w   #$FFFF,D1       ;Nicht definiert?
                bne.s   t_text3         ;Doch! => Fehler
                move.w  data_pointer(A4),D0
                cmp.w   #$FFFF,D0       ;Data-Pointer nicht definiert?
                beq.s   t_bss2          ;dann alles ok!
                cmp.w   D0,D6           ;Bss-Pointer auch hinter dem Data?
                bls.s   t_data3         ;Nein => Fehler
t_bss2:         move.w  #$0A00,2(A3)
                clr.w   (A3)
                move.w  D6,bss_pointer(A4)
                rts
t_cnop:         bsr     get_wert        ;Offset
                tst.b   2(A3)
                bne     synt_error      ;keine Konstanten erlaubt
                cmp.l   #$FFFF,D3
                bhi     val_error
                move.w  D3,4(A3)
                bsr     chk_com
                moveq   #0,D5
                bsr     get_wert        ;alignment
                tst.b   2(A3)
                bne     synt_error
                cmp.l   #$FF,D3
                bhi     val_error
                ori.w   #$2400,D3
                move.w  D3,2(A3)
                rts

t_dsla:         move.w  #$3480,D1
                bra.s   t_ds1
t_dsl:          move.w  #$0480,D1
                bra.s   t_ds1
t_dswa:         move.w  #$3440,D1
                bra.s   t_ds1
t_dsw:          move.w  #$0440,D1
                bra.s   t_ds1
t_dsba:         move.w  #$3400,D1
                bra.s   t_ds1
t_dsb:          move.w  #$0400,D1
t_ds1:          bsr     get_wert        ;Anzahl
                move.w  2(A3),D0
                cmp.w   #$0100,D0       ;Konstante oder Formel
                beq.s   t_ds4           ;ja!
                cmp.w   #2,D0
                bhi     synt_error      ;Strings und negative Zahlen verboten
                swap    D3
                tst.w   D3
                bne     val_error       ;Nur Zahlen < 65536
                swap    D3
                lsl.w   #4,D0
t_ds5:          or.w    D1,D0
                move.w  #4,(A3)         ;Länge für Füllwert
                move.w  D3,4(A3)        ;Anzahl in Zeileninfo eintragen
                moveq   #0,D3
                clr.w   2(A3)
                bsr     cut_space
                cmpi.b  #',',(A0)
                bne.s   t_ds3           ;kein 2. Parameter
                addq.w  #1,A0
                bsr     get_wert        ;Füllwert (optional)
                tst.b   2(A3)
                bne     synt_error      ;keine Konstanten erlaubt
                cmp.w   #$0480,D1       ;DS.L
                beq.s   t_ds3
                cmp.w   #$0440,D1       ;DS.W
                beq.s   t_ds31
                cmp.l   #$FF,D3         ;DS.B
                bls.s   t_ds3
                move.b  D3,D1
                ext.w   D1
                ext.l   D1
                cmp.l   D1,D3
                bne     val_error
                bra.s   t_ds3
t_ds31:         cmp.l   #$FFFF,D3
                bls.s   t_ds3
                move.w  D3,D1
                ext.l   D1
                cmp.l   D1,D3
                bne     val_error
t_ds3:          or.w    D0,2(A3)        ;Flags für Werte
                move.l  D3,14(A3)       ;Füllwert in Programmcode
                moveq   #0,D0
                moveq   #0,D1
                rts
t_ds4:          move.w  #$30,D0         ;Flag für Konstante/Formel setzen
                bra.s   t_ds5

t_rept:         move.w  #$3C00,D1
                bsr     get_wert        ;Anzahl
                move.w  2(A3),D0
                cmp.w   #$0100,D0
                bhs.s   t_rept1         ;Konstante/Formel
                btst    #6,D0           ;Vorzeichen
                bne     synt_error      ;Minus nicht erlaubt
                andi.w  #1,D0           ;nur Dezimal und Hex zulassen
t_rept2:        or.w    D1,D0
                move.w  D0,2(A3)
                move.w  D3,4(A3)        ;Anzahl
                rts
t_rept1:        btst    #6,D0           ;Vorzeichen
                bne     synt_error      ;Minus nicht erlaubt
                move.w  #$0F,D0
                bra.s   t_rept2
t_rsl:          move.w  #$1820,D1
                bra.s   t_rs1
t_rsw:          move.w  #$1810,D1
                bra.s   t_rs1
t_rsb:          move.w  #$1800,D1
t_rs1:          bsr     get_wert        ;Anzahl
                move.w  2(A3),D0
                cmp.w   #$0100,D0
                bhs.s   t_rs3           ;Konstante/Formel
                btst    #3,D0           ;Vorzeichen
                bne     synt_error      ;Minus nicht erlaubt
                andi.w  #1,D0           ;nur Dezimal und Hex zulassen
t_rs4:          or.w    D1,D0
                move.w  D0,2(A3)
                move.w  D3,4(A3)        ;Anzahl
                moveq   #0,D0
                move.w  6(A3),D0
                cmp.w   #$FFFF,D0
                beq.s   t_rs2           ;kein Label definiert
                movea.l label_base(A4),A1
                lsl.l   #5,D0
                move.b  #$FC,5(A1,D0.l) ;Kennung für RS-Konstante setzen
                moveq   #0,D0
t_rs2:          rts
t_rs3:          btst    #6,D0           ;Vorzeichen
                bne     synt_error      ;Minus nicht erlaubt
                move.w  #$0F,D0
                bra.s   t_rs4

t_dcle:         move.w  30(A3),-(SP)    ;letztes Flagword retten
                move.l  A1,D5           ;Zeiger auf Werte retten
                bsr     next_free_entry ;neuen Eintrag anfordern
                move.b  #$FE,31(A1)     ;Kennung für DC-Eintrag
                move.b  D0,32(A3)       ;Low-Byte des Index eintragen
                move.b  #$FF,D0         ;Kennung für Fortsetzung
                move.w  D0,30(A3)       ;High-Byte des Index eintragen
                lea     -2(A1),A3       ;Zeiger auf neuen Eintrag
                movea.l D5,A1           ;Zeiger zurückholen
                moveq   #0,D5
                move.w  (SP)+,2(A3)     ;gerettes Flagword in neuen Eintrag
                bra.s   t_dcl3
t_dcl:          move.w  #$0202,2(A3)
                bsr     t_dc1
                bsr.s   t_dcl2
t_dcl3:         addq.w  #2,D5
                cmp.w   #30,D5
                beq.s   t_dcle
                bsr     cut_space
                cmpi.b  #',',(A0)+
                bne.s   t_dcl4
                bsr.s   t_dcl2          ;Wert holen
                move.w  2(A3,D5.w),D0
                bmi.s   t_dcl3          ;Label, kein Compressing möglich
                cmp.w   0(A3,D5.w),D0   ;mit vorhergehenden vergleichen
                bne.s   t_dcl3          ;ungleich, kein Compressing
                moveq   #0,D1
t_dcl5:         addq.w  #1,D1           ;Zähler
                bsr     cut_space
                cmpi.b  #',',(A0)+
                bne.s   t_dcl6
                bsr.s   t_dcl2          ;Wert holen
                cmp.w   2(A3,D5.w),D0
                beq.s   t_dcl5
                lsl.w   #4,D1
                or.w    D1,D0
                move.w  D0,0(A3,D5.w)
                bra.s   t_dcl3
t_dcl6:         lsl.w   #4,D1
                or.w    D1,D0
                move.w  D0,0(A3,D5.w)
t_dcl4:         move.w  #$FE,2(A3,D5.w)
                subq.w  #1,A0
                movea.l A2,A3
                moveq   #0,D0
                rts
t_dcl2:         bsr     get_wert
                tst.b   2(A3,D5.w)
                beq.s   t_dcl7
                move.b  3(A3,D5.w),2(A3,D5.w) ;Vorzeichen übertragen
                clr.b   3(A3,D5.w)
                bset    #15,D3
                or.w    D3,2(A3,D5.w)
                moveq   #0,D3
t_dcl7:         move.l  D3,(A1)+
                addq.w  #4,(A2)
                rts

t_dcwe:         move.w  30(A3),-(SP)    ;letztes Flagword retten
                move.l  A1,D5           ;Zeiger auf Werte retten
                bsr     next_free_entry ;neuen Eintrag anfordern
                move.b  #$FE,31(A1)     ;Kennung für DC-Eintrag
                move.b  D0,32(A3)       ;Low-Byte des Index eintragen
                move.b  #$FF,D0         ;Kennung für Fortsetzung
                move.w  D0,30(A3)       ;High-Byte des Index eintragen
                lea     -2(A1),A3       ;Zeiger auf neuen Eintrag
                movea.l D5,A1           ;Zeiger zurückholen
                moveq   #0,D5
                move.w  (SP)+,2(A3)     ;gerettes Flagword in neuen Eintrag
                bra.s   t_dcw3
t_dcw:          move.w  #$0201,2(A3)
                bsr     t_dc1
                bsr.s   t_dcw2
t_dcw3:         addq.w  #2,D5
                cmp.w   #30,D5
                beq.s   t_dcwe
                bsr     cut_space
                cmpi.b  #',',(A0)+
                bne.s   t_dcw4
                bsr.s   t_dcw2          ;Wert holen
                move.w  2(A3,D5.w),D0
                bmi.s   t_dcw3          ;Label, kein Compressing möglich
                cmp.w   0(A3,D5.w),D0   ;mit vorhergehenden vergleichen
                bne.s   t_dcw3          ;ungleich, kein Compressing
                moveq   #0,D1
t_dcw5:         addq.w  #1,D1           ;Zähler
                bsr     cut_space
                cmpi.b  #',',(A0)+
                bne.s   t_dcw6
                bsr.s   t_dcw2          ;Wert holen
                cmp.w   2(A3,D5.w),D0
                beq.s   t_dcw5
                lsl.w   #4,D1
                or.w    D1,D0
                move.w  D0,0(A3,D5.w)
                bra.s   t_dcw3
t_dcw6:         lsl.w   #4,D1
                or.w    D1,D0
                move.w  D0,0(A3,D5.w)
t_dcw4:         move.w  #$FE,2(A3,D5.w)
                subq.w  #1,A0
                movea.l A2,A3
                moveq   #0,D0
                rts
t_dcw2:         bsr     get_wert
                tst.b   2(A3,D5.w)
                beq.s   t_dcw7
                move.b  3(A3,D5.w),2(A3,D5.w) ;Vorzeichen übertragen
                clr.b   3(A3,D5.w)
                bset    #15,D3
                or.w    D3,2(A3,D5.w)
                moveq   #0,D3
t_dcw7:         cmp.l   #$FFFF,D3
                bls.s   t_dcw71
                move.w  D3,D2
                ext.l   D2
                cmp.l   D3,D2
                bne     val_error
t_dcw71:        move.w  D3,(A1)+
                addq.w  #2,(A2)
                rts

t_dcbe:         move.w  30(A3),-(SP)    ;letztes Flagword retten
                move.l  A1,D5           ;Zeiger auf Werte retten
                bsr     next_free_entry ;neuen Eintrag anfordern
                move.b  #$FE,31(A1)     ;Kennung für DC-Eintrag
                move.b  D0,32(A3)       ;Low-Byte des Index eintragen
                move.b  #$FF,D0         ;Kennung für Fortsetzung
                move.w  D0,30(A3)       ;High-Byte des Index eintragen
                lea     -2(A1),A3       ;Zeiger auf neuen Eintrag
                movea.l D5,A1           ;Zeiger zurückholen
                moveq   #0,D5
                move.w  (SP)+,2(A3)     ;gerettes Flagword in neuen Eintrag
                bra.s   t_dcb8
t_dcb:          move.w  #$0200,2(A3)
                bsr     t_dc1
                bsr.s   t_dcb2
t_dcb8:         addq.w  #2,D5
                cmp.w   #30,D5
                beq.s   t_dcbe
                bsr     cut_space
                cmpi.b  #',',(A0)+
                bne.s   t_dcb9
                bsr.s   t_dcb2
                beq.s   t_dcb8          ;String
                move.w  2(A3,D5.w),D0
                bmi.s   t_dcb8
                cmp.w   0(A3,D5.w),D0
                bne.s   t_dcb8
                moveq   #0,D1
t_dcb11:        addq.w  #1,D1           ;Zähler
                bsr     cut_space
                cmpi.b  #',',(A0)+
                bne.s   t_dcb10
                bsr.s   t_dcb2          ;Wert holen
                beq.s   t_dcb13         ;wenn String, alle Flags gesetzt
                cmp.w   2(A3,D5.w),D0
                beq.s   t_dcb11
t_dcb13:        lsl.w   #4,D1
                or.w    D1,D0
                move.w  D0,0(A3,D5.w)
                bra.s   t_dcb8
t_dcb10:        lsl.w   #4,D1
                or.w    D1,D0
                move.w  D0,0(A3,D5.w)
t_dcb9:         move.w  #$FE,2(A3,D5.w)
                subq.w  #1,A0
                addq.w  #1,(A2)
                bclr    #0,1(A2)        ;Füllbyte, wenn ungerade
                bne.s   t_dcb12
                bset    #7,4(A2)        ;ungerade Anzahl->Bit 7 im Index setzen
t_dcb12:        movea.l A2,A3
                moveq   #0,D0
                rts

t_dcb2:         bsr     cut_space
                cmpi.b  #$27,(A0)       ;'
                beq.s   t_dcb4          ;auf String prüfen
                cmpi.b  #$22,(A0)       ;"
                beq.s   t_dcb4          ;auf String prüfen
t_dcb21:        bsr     get_wert        ;Ausdruck holen
                tst.b   2(A3,D5.w)      ;Symbol/Formel?
                beq.s   t_dcb3          ;Nein, einfacher Wert =>
                move.b  3(A3,D5.w),2(A3,D5.w) ;Vorzeichen übertragen
                clr.b   3(A3,D5.w)
                bset    #15,D3
                or.w    D3,2(A3,D5.w)
                moveq   #0,D3
t_dcb3:         cmp.l   #$FF,D3         ;Bereich testen
                bls.s   t_dcb31         ;paßt sicher =>
                move.b  D3,D2
                ext.w   D2
                ext.l   D2
                cmp.l   D3,D2           ;Vorzeichenbehaftet? : -128 bis 127
                bne     val_error       ;Wert zu groß => raus
t_dcb31:        move.b  D3,(A1)+        ;Wert übertragen
                addq.w  #1,(A2)
                move    #0,CCR
                rts
t_dcb4:         movem.l D0-D3,-(SP)
                move.l  A0,D3           ;Zeiger auf Text merken
                move.b  (A0)+,D2        ;Endekennung merken
                moveq   #-1,D1
t_dcb5:         move.b  (A0)+,D0        ;Zeichen holen
                beq.s   t_dcbx          ;Nullbyte->Fehler
                cmp.b   D2,D0           ;mit Endezeichen vergleichen
                beq.s   t_dcb6          ;gleich
t_dcb61:        move.b  D0,(A1)+        ;Zeichen übernehmen
                addq.w  #1,(A2)         ;Anzahl erhöhen
                addq.w  #1,D1
                cmp.w   #128,D1         ;max. Länge
                blt.s   t_dcb5
t_dcbx:         movem.l (SP)+,D0-D3
                bra     synt_error
t_dcb6:         cmp.b   (A0)+,D0        ;Folgezeichen auch Endekennung ?
                beq.s   t_dcb61         ;dann in String übernehmen
                subq.l  #1,A0           ;Zeiger zurücksetzen
                tst.w   D1
                bmi.s   t_dcbx          ;Stringlänge=0 => nicht erlaubt
                beq.s   t_dcb7          ;Stringlänge=1 => das geht
                lsl.w   #4,D1
                or.w    #6,D1
                and.w   #1,D2
                or.w    D2,D1           ;Endekennung sichern
                move.w  D1,2(A3,D5.w)
                movem.l (SP)+,D0-D3
                move    #$FF,CCR
                rts
t_dcb7:         subq.w  #1,(A2)
                subq.l  #1,A1           ;Zeiger zurücksetzen
                movea.l D3,A0
                movem.l (SP)+,D0-D3
                bra     t_dcb21         ;Ausdruck holen

t_dc1:          bsr.s   next_free_entry ;A1 zeigt auf Eintrag der Tabelle
                move.w  D0,4(A3)        ;Index speichern
                move.b  #$FE,31(A1)     ;Markierung für Labelsuchroutine
                movea.l A3,A2
                lea     -2(A1),A3       ;Zeiger auf Eintrag setzen
                lea     14(A2),A1       ;Zeiger für Werte
                moveq   #0,D5
                rts

************************************************************************
* sucht nächsten freien Platz in Labeltabelle                          *
************************************************************************
next_free3:     movea.l local_pointer(A4),A1 ;Zeiger auf Hilfstabelle im Zielcode-
                move.w  #$FF00,(A1)     ;speicher / Spezialkennung
                addq.l  #2,local_pointer(A4)
;        move.l  entry_pointer(a4),a1
;        move.l  label_top(a4),(a1)      ;Adresse des Eintrags in entry_buffer
;        addq.l  #4,entry_pointer(a4)
                movea.l label_top(A4),A1
                move.w  label_top_ind(A4),D0
                addq.w  #1,label_top_ind(A4)
                addi.l  #32,label_top(A4)
                rts
next_free_entry:tst.b   load_fl(A4)     ;ASCII-Load
                bmi.s   next_free3      ;ja
                tst.b   entry_free(A4)  ;freier Eintrag vorhanden ?
                beq.s   next_free4      ;nein
                movea.l label_base(A4),A1
                lea     -32(A1),A1
                move.w  label_top_ind(A4),D1
                moveq   #-1,D0
next_loop:      lea     32(A1),A1
                addq.w  #1,D0
                cmp.w   D1,D0
                beq.s   next_found
                tst.b   31(A1)
                beq.s   next_loop
                bmi.s   next_loop
                move.l  A1,D1           ;A1 retten
                movea.l entry_pointer(A4),A1
                move.l  D1,(A1)         ;Adresse des Eintrags in entry_buffer
                addq.l  #4,entry_pointer(A4)
                movea.l D1,A1
                moveq   #0,D1
                move.l  D1,(A1)
                move.l  D1,4(A1)
                move.l  D1,8(A1)
                move.l  D1,12(A1)
                move.l  D1,16(A1)
                move.l  D1,20(A1)
                move.l  D1,24(A1)
                move.l  D1,28(A1)
                rts
next_free4:     movea.l label_top(A4),A1
                move.w  label_top_ind(A4),D0
next_found:     move.l  A1,D1           ;A1 retten
                movea.l entry_pointer(A4),A1
                move.l  D1,(A1)         ;Adresse des Eintrags in entry_buffer
                addq.l  #4,entry_pointer(A4)
                movea.l D1,A1
                moveq   #0,D1
                move.l  D1,(A1)
                move.l  D1,4(A1)
                move.l  D1,8(A1)
                move.l  D1,12(A1)
                move.l  D1,16(A1)
                move.l  D1,20(A1)
                move.l  D1,24(A1)
                move.l  D1,28(A1)
                addq.w  #1,label_top_ind(A4)
                addi.l  #32,label_top(A4)
                sf      entry_free(A4)
                rts

************************************************************************
* Operandenchecks der Befehle                                          *
************************************************************************
t_abcd:         cmp.b   #'D',D0
                beq.s   t_abcd2
                cmp.b   #'d',D0
                beq.s   t_abcd2
                cmp.b   #'\',D0
                beq.s   t_abcd4
                cmp.b   #'-',D0
                bne     op_error
                bsr     get_indirect
                bset    #3,D0
                or.b    D0,15(A3)
                bsr     chk_com
                cmpi.b  #'\',(A0)
                beq.s   t_abcd7
                cmpi.b  #'-',(A0)
                bne     op_error
t_abcd5:        bsr     get_indirect
t_abcd3:        add.w   D0,D0
                or.b    D0,14(A3)
                rts
t_abcd2:        bsr     get_regnr
                or.b    D0,15(A3)
                bsr     chk_com
                cmpi.b  #'\',(A0)
                beq.s   t_abcd7
t_abcd6:        bsr     get_datareg
                bmi     op_error
                bra.s   t_abcd3
t_abcd4:        bsr     get_par_nummer
                move.w  D0,2(A3)
                bsr     chk_com
                cmpi.b  #'-',(A0)
                beq.s   t_abcd8
                cmpi.b  #'\',(A0)
                bne.s   t_abcd6
t_abcd7:        bsr     get_par_nummer
                move.w  D0,4(A3)
                rts
t_abcd8:        ori.b   #8,15(A3)
                bra.s   t_abcd5

t_add1:         bsr     get_par_nummer
                move.w  D0,4(A3)
                move.w  14(A3),D0       ;Opcode holen
                and.w   #$3F,D0         ;EA ausmaskieren
                cmp.w   #7,D0           ;Datenregister ?
                bhi.s   t_add11         ;nein->fertig
                andi.w  #$FFC0,14(A3)   ;sonst ist Macroparameter
                ori.w   #$0110,14(A3)   ;die EA
                bra.s   t_add3
t_addb:         move.w  #$1C02,D1       ;kein Adreßregister bei .B
                bra.s   t_add12
t_add:          move.w  #$1C00,D1
t_add12:        bsr     get_ea
                bsr.s   chk_com
                cmpi.b  #'\',(A0)
                beq.s   t_add1          ;Macroparameter
                bsr     get_adrreg      ;Adreßregister?
                bpl.s   t_add4          ;ja
                bsr     get_datareg
                bmi.s   t_add2
t_add3:         add.w   D0,D0
                or.b    D0,14(A3)
t_add11:        rts
t_add2:         moveq   #$3F,D0         ;EA ausmaskieren
                and.w   14(A3),D0       ;Opcode holen
                cmp.w   #$3C,D0         ;Quelloperand unmittelbar ?
                beq.s   t_add5          ;ja!
                move.w  #$1F03,D1       ;ADD Dx,xx
                move.w  14(A3),D0
                andi.w  #$FFC0,14(A3)
                bsr     get_ea
                and.w   #$3F,D0
                cmp.w   #7,D0
                bgt.s   op_error
                add.w   D0,D0
                bset    #0,D0
                or.b    D0,14(A3)
                rts
t_add4:         move.w  14(A3),D1       ;ADDA xx,Ax
                add.w   D1,D1
                and.w   #$0100,D1
                or.w    #$C0,D1
                or.w    D1,14(A3)
                bra.s   t_add3
t_add5:         move.b  14(A3),D0       ;ADDI #xx,xx
                rol.b   #3,D0           ;ADD zu ADDI und SUB zu SUBI wandeln
                and.b   #7,D0
                move.b  D0,14(A3)
                move.w  #$1F02,D1
                bsr     get_ea
                rts

chk_com:        bsr     cut_space
                cmpi.b  #',',(A0)+
                bne.s   chk_com2
                moveq   #2,D5
                bra     cut_space
chk_com2:       moveq   #-9,D0
                movea.l D7,SP
                bra     operand_err

op_error:       movea.l D7,SP
                moveq   #-7,D0
                bra     operand_err

t_adda:         move.w  #$1C00,D1
                bsr     get_ea
                bsr.s   chk_com
                cmpi.b  #'\',(A0)
                beq.s   t_adda2
                bsr     get_adrreg
                bmi.s   op_error
                add.w   D0,D0
                or.b    D0,14(A3)
                rts
t_adda2:        bsr     get_par_nummer
                move.w  D0,4(A3)
                rts

t_addi:         cmpi.b  #'\',D0
                beq.s   t_addi2
                cmpi.b  #'#',(A0)+
                bne.s   op_error
                bsr     get_wert
                bsr     set_imidiate
t_addi3:        bsr.s   chk_com
                move.w  #$1F02,D1
                bsr     get_ea
                rts
t_addi2:        bsr     get_par_nummer
                move.w  D0,2(A3)
                bra.s   t_addi3

t_addq:         cmpi.b  #'\',D0
                beq.s   t_addq4
                cmpi.b  #'#',(A0)+
                beq.s   t_addq1         ;# braucht nicht eingegeben werden
                subq.l  #1,A0
t_addq1:        bsr     get_wert
                tst.b   2(A3,D5.w)
                bne.s   t_addq3
                tst.l   D3
                beq     val_error
                cmp.l   #8,D3
                bhi     val_error
                andi.w  #7,D3
                add.b   D3,D3
                or.b    D3,14(A3)
t_addq2:        bsr     chk_com
                move.w  #$1F00,D1
                bsr     get_ea
                move.b  15(A3),D0       ;EA holen
                and.w   #$F8,D0         ;untere 3 Bits ausmaskieren
                cmp.w   #8,D0           ;Ax auf Byte?
                bne.s   t_addq21        ;nein
                ori.w   #$40,14(A3)     ;.B->.W
t_addq21:       rts
t_addq3:        bsr     get_quick
                bra.s   t_addq2
t_addq4:        bsr     get_par_nummer
                move.w  D0,2(A3)
                bra.s   t_addq2

t_and:          move.w  #$1C02,D1
                bsr     get_ea
                move.w  14(A3),D0       ;EA holen
                andi.w  #$3F,D0
                cmp.w   #$3C,D0         ;Quelloperant = unmittelbar
                beq.s   t_and3          ;Ja !
                bsr     chk_com
                cmpi.b  #'\',(A0)
                beq     t_add1          ;Macroparameter
                bsr     get_datareg
                bmi     t_add2
t_and4:         add.b   D0,D0
                or.b    D0,14(A3)
                rts
t_and3:         bsr     chk_com
                cmpi.b  #'\',(A0)
                beq.s   t_and2          ;Macroparameter
                bsr     get_datareg
                bpl.s   t_and4          ;Datenregister->keine Wandlung nötig
                move.b  14(A3),D0
                ror.b   #5,D0
                move.b  D0,14(A3)
                andi.w  #$02C0,14(A3)   ;AND zu ANDI und OR zu ORI wandeln
                bra.s   t_andi2
t_and2:         bsr     get_par_nummer
                move.w  D0,4(A3)        ;bei Macropar. der Einfachheit halber
                move.b  14(A3),D0
                ror.b   #5,D0
                move.b  D0,14(A3)
                andi.w  #$02C0,14(A3)   ;zu ANDI bzw. ORI wandeln
                rts

t_andi:         cmpi.b  #'#',(A0)+
                bne.s   t_andi1
t_andi3:        bsr     get_wert
                bsr     set_imidiate
                bsr     chk_com
t_andi2:        move.w  #$1302,D1
                bsr     get_ea
                cmpi.b  #%111110,15(A3) ;CCR ?
                bne.s   t_andi4         ;nein
                andi.b  #$FD,15(A3)     ;in richtige CCR wandeln
t_andi4:        rts
t_andi1:        cmpi.b  #'\',-(A0)
                bne     op_error        ;kein Macroparameter
                bsr     get_par_nummer
                move.w  D0,2(A3)
                bsr     chk_com
                bra.s   t_andi2

t_asl:          cmp.b   #'#',D0
                beq.s   t_asl3
                bsr     get_datareg
                bmi.s   t_asl2
                andi.b  #$F1,14(A3)
                bsr     cut_space
                cmpi.b  #',',(A0)
                bne.s   t_asl6
                add.w   D0,D0
                or.b    D0,14(A3)
                bset    #5,15(A3)
t_asl4:         bsr     chk_com
t_asl42:        bsr     get_datareg
                bmi.s   t_asl41
                or.b    D0,15(A3)
                rts
t_asl41:        cmpi.b  #'\',(A0)
                bne     op_error        ;kein Macroparameter
                bsr     get_par_nummer
                move.w  D0,4(A3)
                rts
t_asl6:         ori.b   #2,14(A3)       ;#1 einsetzen
                or.b    D0,15(A3)       ;Register einsetzen
                rts
t_asl3:         addq.l  #1,A0
                bsr     get_wert
                tst.b   2(A3)
                bne.s   t_asl5
                cmp.w   #8,D3
                bhi     val_error
                andi.w  #7,D3
                add.w   D3,D3
                andi.b  #$F1,14(A3)
                or.b    D3,14(A3)
                bra.s   t_asl4
t_asl2:         cmpi.b  #'\',(A0)
                beq.s   t_asl7
                move.b  #$C0,15(A3)
                move.w  #$1F03,D1
                bsr     get_ea
                rts
t_asl5:         bsr     get_quick
                bra.s   t_asl4
t_asl7:         bsr     get_par_nummer
                move.w  D0,2(A3)
                bsr     cut_space
                cmpi.b  #',',(A0)       ;folgt zweiter Parameter ?
                bne.s   t_asl71         ;nein
                addq.l  #1,A0
                bsr     cut_space
                andi.b  #$F1,14(A3)     ;Bits für ASL Dn,Dm setzen
                bset    #5,15(A3)
                bra     t_asl42         ;zweiten Parameter auswerten
t_asl71:        move.b  #$D0,15(A3)
                rts

t_bccs:         move.w  D4,4(A3)        ;Flag für BLO und BHS
                cmp.b   #'*',D0
                bne.s   t_bcc3s
                addq.w  #1,A0
                cmpi.b  #'+',(A0)+
                beq.s   t_bcc2s
                cmpi.b  #'-',-(A0)
                bne     synt_error
t_bcc2s:        bsr     get_wert
                tst.b   2(A3)
                bne     synt_error
t_bcc5s:        move.b  D3,D1
                beq.s   t_bcc4s         ;Offset gleich 0
                ext.w   D1
                ext.l   D1
                cmp.l   D1,D3
                bne     val_error
                move.b  D3,15(A3)
                rts
t_bcc4s:        move.w  #$4E71,14(A3)   ;durch NOP ersetzen
                rts
t_bcc3s:        cmpi.b  #'#',(A0)+
                beq.s   t_bcc2s
                subq.w  #1,A0
                bsr     get_wert
                tst.b   2(A3)
                beq.s   t_bcc5s         ;eine Zahl
                bsr     get_quick
                move.b  #2,15(A3)
                rts

t_bcc:          move.w  D4,4(A3)        ;Flag für BLO und BHS
                cmp.b   #'*',D0
                bne.s   t_bcc3
                addq.w  #1,A0
                cmpi.b  #'+',(A0)+
                beq.s   t_bcc5
                cmpi.b  #'-',-(A0)
                bne     synt_error
t_bcc5:         bsr     get_wert
                cmp.l   #$FFFF,D3
                blo.s   t_bcc6
                move.w  D3,D1
                ext.l   D1
                cmp.l   D1,D3
                bne     val_error
t_bcc6:         tst.w   D3
                bpl.s   t_bcc7
                ori.w   #8,2(A3,D5.w)   ;$FFFE in -2 wandeln
t_bcc7:         move.w  D3,(A2)+
                addq.w  #2,(A3)
                rts
t_bcc3:         cmp.b   #'#',D0
                bne.s   t_bcc4
                addq.w  #1,A0
                bra.s   t_bcc5
t_bcc4:         bsr     get_wert
                tst.b   2(A3,D5.w)
                beq.s   _kein_label
                move.b  1(A3),3(A3,D5.w)
                ori.w   #$90,2(A3,D5.w)
_kein_label:    move.w  D3,(A2)+
                addq.w  #2,(A3)
                rts

t_bchg:         cmp.b   #'D',D0
                beq.s   t_bchg2
                cmp.b   #'d',D0
                beq.s   t_bchg2
                cmpi.b  #'#',(A0)+
                bne     op_error
                bsr     get_wert
                tst.b   2(A3)
                bne.s   t_bchg3
                cmp.w   #$1F,D3
                bhi     val_error
t_bchg4:        move.b  #%1000,14(A3)
                move.w  D3,(A2)+
                addq.w  #2,(A3)
                bsr     chk_com
                move.w  #$1F02,D1
t_bchg6:        bsr     get_ea
                tst.b   2(A3)
                bne.s   t_bchg5         ;bei Symbol kein Test
                moveq   #$38,D0         ;Modus der EA ausmaskieren
                and.w   14(A3),D0       ;Opcode holen
                beq.s   t_bchg5         ;Datenregister
                cmpi.w  #7,16(A3)       ;max. Bitnummer bei Byte
                bhi     val_error
t_bchg5:        rts
t_bchg3:        ori.w   #$12,2(A3)
                bra.s   t_bchg4
t_bchg2:        bsr     get_regnr
                add.b   D0,D0
                or.b    D0,14(A3)
                bsr     chk_com
                move.w  #$1F02,D1
                bra     get_ea

t_btst:         cmp.b   #'D',D0
                beq.s   t_btst2
                cmp.b   #'d',D0
                beq.s   t_btst2
                cmpi.b  #'#',(A0)+
                bne     op_error
                bsr     get_wert
                tst.b   2(A3)
                bne.s   t_btst3
                cmp.w   #$1F,D3
                bhi     val_error
t_btst4:        move.b  #%1000,14(A3)
                move.w  D3,(A2)+
                addq.w  #2,(A3)
                bsr     chk_com
                move.w  #$1E02,D1
                bra.s   t_bchg6
t_btst3:        ori.w   #$12,2(A3)
                bra.s   t_btst4
t_btst2:        bsr     get_regnr
                add.b   D0,D0
                or.b    D0,14(A3)
                bsr     chk_com
                move.w  #$1C02,D1
                bra     get_ea

t_chk:          move.w  #$1C02,D1
                bsr     get_ea
                bsr     chk_com
                bsr     get_datareg
                bmi     op_error
                add.b   D0,D0
                or.b    D0,14(A3)
                rts

t_clr:          move.w  #$1F00,D1
                bsr     get_ea
                move.b  15(A3),D0       ;EA holen
                andi.w  #$3F,D0
                cmp.w   #7,D0
                bls.s   t_clr2
                cmp.w   #$0F,D0
                bhi.s   t_clr2
                move.w  14(A3),D1       ;Befehl holen
                add.w   D1,D1           ;Breitenbit an richtige Stelle
                andi.w  #$0100,D1       ;und ausmaskieren
                ori.w   #$90C0,D1       ;zu SUBA wandeln
                or.b    D0,D1           ;Adressregister einsetzen
                move.w  D1,14(A3)
                add.w   D0,D0
                or.b    D0,14(A3)       ;Adressregister einsetzen
t_clr2:         rts

t_tst:          move.w  D4,4(A3)        ;Flag für SLO und SHS
                move.w  #$1F02,D1
                bra     get_ea

t_cmpb:         move.w  #$1C02,D1       ;kein Adreßregister bei .B
                bra.s   t_cmp1
t_cmp:          move.w  #$1C00,D1
t_cmp1:         bsr     get_ea
                bsr     chk_com
                move.w  14(A3),D0       ;Befehl retten
                move.w  #$1F00,D1
                bsr     get_ea          ;Ziel-EA holen (CMPI/CMPA)
                moveq   #$3F,D1
                and.b   15(A3),D1
                cmp.w   #7,D1
                bls.s   t_cmp3          ;CMP x,Dx
                cmp.b   #$0F,D1
                bls.s   t_cmp2          ;CMPA x,Ax
                moveq   #$3F,D3
                and.w   D0,D3
                cmp.w   #$3C,D3         ;Quelloperand unmittelbar ?
                bne.s   t_cmpm1         ;Nein !
                andi.w  #$C0,D0
                ori.w   #$0C00,D0       ;CMPI #x,x
                or.w    D1,D0
                move.w  D0,14(A3)
                rts
t_cmp2:         move.w  D0,D3
                add.w   D0,D0
                andi.w  #$0100,D0
                ori.w   #$C0,D0
                or.w    D3,D0
t_cmp3:         move.w  D0,14(A3)
                andi.w  #7,D1
                add.b   D1,D1
                or.b    D1,14(A3)
                rts
t_cmpm1:        moveq   #$38,D1
                and.b   D0,D1
                cmp.w   #$18,D1         ;(Ax)+
                bne     op_error
                moveq   #$38,D1
                and.b   15(A3),D1
                cmp.w   #$18,D1
                bne     op_error        ;(Ay)+
                moveq   #7,D1
                and.b   15(A3),D1       ;Ax holen
                ror.w   #7,D1
                andi.w  #$FFF8,14(A3)   ;Ax löschen
                or.w    D3,14(A3)       ;Ay einsetzen
                andi.w  #$C7,14(A3)
                ori.w   #$B108,14(A3)
                or.w    D1,14(A3)       ;Ax einsetzen
                rts

t_cmpm:         bsr     get_indirect2
                cmpi.b  #'+',(A0)+
                bne     op_error
                or.b    D0,15(A3)
                bsr     chk_com
                bsr     get_indirect2
                cmpi.b  #'+',(A0)+
                bne     op_error
                add.b   D0,D0
                or.b    D0,14(A3)
                rts

t_dbcc:         bsr     get_datareg
                bmi.s   t_dbcc1
                or.b    D0,15(A3)
t_dbcc2:        bsr     chk_com
                move.b  (A0),D0
                bra     t_bcc
t_dbcc1:        cmpi.b  #'\',(A0)
                bne     op_error        ;kein Macroparameter
                bsr     get_par_nummer
                move.w  D0,2(A3)
                bra.s   t_dbcc2

t_eor:          cmpi.b  #'#',D0
                beq.s   t_eor2          ;Quelle unmittelbar
                bsr     get_datareg
                bmi.s   t_eor1
                add.b   D0,D0
                or.b    D0,14(A3)
t_eor3:         bsr     chk_com
                move.w  #$1F02,D1
                bsr     get_ea
                rts
t_eor1:         cmpi.b  #'\',(A0)
                bne     op_error
                bsr     get_par_nummer
                move.w  D0,2(A3)
                bra.s   t_eor3
t_eor2:         move.b  #%1010,14(A3)   ;EORI einsetzen
                addq.w  #1,A0
                bra     t_andi3

t_exg:          cmp.b   #'D',D0
                beq.s   t_exg2
                cmp.b   #'d',D0
                beq.s   t_exg2
                bsr     get_adrreg
                bmi     op_error
                add.b   D0,D0
                or.b    D0,14(A3)
                move.b  #%1001000,15(A3)
                bsr     chk_com
                cmpi.b  #'D',(A0)
                beq.s   t_exg4
                cmpi.b  #'d',(A0)
                beq.s   t_exg4
                bsr     get_adrreg
                bmi     op_error
                or.b    D0,15(A3)
                rts
t_exg4:         lsr.b   #1,D0           ;Adressregister zurückholen
                andi.w  #7,D0
                ori.w   #$C188,D0       ;Bits für Daten/Adressregister setzen
                move.w  D0,14(A3)
                bsr     get_regnr
                add.b   D0,D0
                or.b    D0,14(A3)
                rts
t_exg2:         bsr     get_regnr
                add.b   D0,D0
                or.b    D0,14(A3)
                bsr     chk_com
                cmpi.b  #'D',(A0)
                beq.s   t_exg3
                cmpi.b  #'d',(A0)
                beq.s   t_exg3
                bsr     get_adrreg
                bmi     op_error
                move.b  #%10001000,15(A3)
                or.b    D0,15(A3)
                rts
t_exg3:         bsr     get_regnr
                move.b  #%1000000,15(A3)
                or.b    D0,15(A3)
                rts

t_ext:          cmp.b   #'\',D0
                beq.s   t_ext2
                bsr     get_datareg
                bmi     op_error
                or.b    D0,15(A3)
                rts
t_ext2:         bsr     get_par_nummer
                move.w  D0,2(A3)
                rts

t_jmp:          move.w  #$1E1B,D1
                bsr     get_ea
                rts

t_lea:          move.w  #$1E1B,D1
                bsr     get_ea
                bsr     chk_com
                bsr     get_adrreg
                bmi     op_error
                add.b   D0,D0
                or.b    D0,14(A3)
                rts

t_link:         bsr     get_adrreg
                bmi     op_error
                or.b    D0,15(A3)
                bsr     chk_com
                cmpi.b  #'#',(A0)+
                bne     op_error
                bsr     get_wert
                tst.b   2(A3,D5.w)
                beq.s   t_link2
                ori.b   #$12,3(A3,D5.w)
t_link2:        move.w  D3,(A2)
                addq.w  #2,(A3)
                rts

t_move:         moveq   #0,D1           ;alles zugelassen
                bsr     get_ea
                bsr     chk_com
                move.b  15(A3),D1
                cmp.b   #%1111100,D1    ;SR
                beq.s   t_move2
                cmp.b   #%111110,D1     ;CCR
                beq.s   t_move21
                cmpi.b  #$3F,D1         ;USP
                beq     t_move5
                move.w  14(A3),D0
                move.w  #$0300,D1
                bsr     get_ea
                move.b  15(A3),D1       ;EA holen
                cmp.b   #%1111100,D1    ;SR
                beq.s   t_move3
                cmp.b   #%111110,D1     ;CCR
                beq.s   t_move3
                cmp.b   #$3F,D1         ;USP
                beq     t_move6
                cmp.b   #7,D1
                bls.s   t_move11        ;Dx
                cmp.b   #$0F,D1
                bls     t_move7         ;Ax
t_move11:       move.b  15(A3),D1
                andi.w  #$3F,D1
                move.w  D0,14(A3)       ;Quell-EA zurückschreiben
                lsl.w   #3,D1
                move.w  D1,D0
                andi.w  #$01C0,D1
                or.w    D1,14(A3)       ;Ziel-EA (Modus) einsetzen
                lsr.w   #2,D0
                andi.w  #$0E,D0
                or.b    D0,14(A3)       ;Ziel-EA (Register) einsetzen
                rts
t_move21:       move.b  #%1111100,15(A3) ;CCR zu SR
t_move2:        move.w  #$40C0,14(A3)   ;MOVE von SR
                move.w  #$1302,D1
                bsr     get_ea
                rts
t_move3:        move.w  14(A3),D1
                andi.w  #$FFFD,D1       ;für CCR
                rol.b   #3,D1
                andi.w  #2,D1
                andi.w  #$3F,D0         ;MOVE to CCR
                cmp.w   #8,D0
                blt.s   t_move4
                cmp.w   #$10,D0
                blt     op_error
                cmp.w   #$3C,D0
                bgt     op_error
t_move4:        ori.w   #$44C0,D0
                move.w  D0,14(A3)
                or.b    D1,14(A3)
                rts
t_move5:        bsr     get_adrreg
                bmi     op_error
                ori.w   #$4E68,D0
                move.w  D0,14(A3)
                rts
t_move6:        andi.w  #7,D0
                ori.w   #$4E60,D0
                move.w  D0,14(A3)
                rts
t_move7:        ori.w   #$2040,D0
                move.w  D0,14(A3)
                andi.w  #7,D1
                add.w   D1,D1
                or.b    D1,14(A3)
                rts
t_movem15:      bsr     search_label
                tst.w   D0
                bmi     synt_error
                tst.b   5(A1)
                ble     synt_error
t_movem11:      tst.b   5(A1)
                ble.s   t_movem12       ;Label / Konstante
                move.w  #$8012,2(A3)
                move.w  D0,16(A3)
                bra     t_movem23
t_movem40:      bsr     get_par_nummer  ;Macroparameter holen
                move.w  D0,2(A3)        ;und speichern
                addq.w  #2,(A3)
                bra.s   t_movem121
t_movem:        lea     allowed_chars(PC),A1
                moveq   #0,D3
                moveq   #0,D0
                lea     18(A3),A2
                cmpi.b  #'#',(A0)+
                beq.s   t_movem15
                subq.l  #1,A0
                cmpi.b  #'\',(A0)       ;Macroparameter
                beq.s   t_movem40
                bsr     get_datareg
                bpl     t_movem2
                bsr     get_adrreg
                bpl     t_movem21
                cmpi.b  #',',(A0)
                beq     t_movem22       ;keine Registerliste
                move.l  A0,D1
                bsr     search_label
                tst.w   D0
                bpl.s   t_movem11
t_movem12:      lea     allowed_chars(PC),A1
                movea.l D1,A0
                moveq   #0,D1
                addq.w  #2,(A3)
                move.w  #$1E13,D1
                bsr     get_ea
t_movem121:     ori.w   #$4C80,14(A3)
                bsr     chk_com
                moveq   #0,D3
                cmpi.b  #'#',(A0)+
                beq.s   t_movem16
                subq.l  #1,A0
                move.l  A0,D1
                bsr     search_label
                tst.w   D0
                bpl.s   t_movem13
                moveq   #0,D0
                bra     t_movem32
t_movem16:      bsr     search_label
                tst.w   D0
                bmi     synt_error
                tst.b   5(A1)
                ble     synt_error
t_movem13:      tst.b   5(A1)
                ble.s   t_movem14
                move.w  #$8012,4(A3)
                move.w  D0,16(A3)
                moveq   #0,D1
                rts
t_movem41:      bsr     get_par_nummer  ;Parameternummer holen
                move.w  D0,4(A3)        ;und speichern
                ori.w   #$4890,14(A3)   ;EA auf (An) setzen, damit gültiger Befehl
                rts
t_movem14:      movea.l D1,A0
                moveq   #0,D1
                bra.s   t_movem32
t_movem21:      addq.w  #8,D0
                moveq   #8,D4
t_movem2:       bsr.s   t_movem31
t_movem22:      addq.w  #2,(A3)
                bsr     chk_com
                cmpi.b  #'\',(A0)
                beq.s   t_movem41       ;Macroparameter
                move.w  #$1F0B,D1
                bsr     get_ea
                ori.w   #$4880,14(A3)
                move.w  14(A3),D0
                andi.w  #$38,D0
                cmp.w   #$20,D0         ;-(Ax) ?
                bne.s   t_movem8        ;nein
                move.w  16(A3),D3
                moveq   #15,D0
t_loop:         addx.w  D3,D3
                roxr.w  16(A3)
                dbra    D0,t_loop
t_movem8:       rts
t_movem23:      addq.w  #2,(A3)
                bsr     chk_com
                move.w  #$1F0B,D1
                bsr     get_ea
                ori.w   #$4880,14(A3)
                rts
t_movem32:      lea     allowed_chars(PC),A1
                move.b  (A0),D0         ;Zeichen holen
                tst.b   0(A1,D0.w)
                bne.s   t_movem3        ;Registerliste da
                clr.w   16(A3)
                rts
t_movem3:       bsr.s   t_movem4
                moveq   #8,D4
                and.w   D0,D4
t_movem31:      bset    D0,D3
                move.w  D0,D1
                move.b  (A0)+,D0
                cmp.w   #'/',D0
                beq.s   t_movem3
                cmp.w   #'-',D0
                bne.s   t_movem5
                bsr.s   t_movem4
                moveq   #8,D4
                and.w   D0,D4
                cmp.w   D0,D1
                bge     op_error
t_movem6:       bset    D0,D3
                subq.w  #1,D0
                cmp.w   D1,D0
                bgt.s   t_movem6
                move.b  (A0)+,D0
                cmp.w   #'/',D0
                beq.s   t_movem3
t_movem5:       cmp.b   #';',D0
                beq.s   t_movem9
                tst.b   0(A1,D0.w)
                bne     op_error
t_movem9:       subq.l  #1,A0
                move.w  D3,16(A3)
                rts
t_movem4:       bsr     get_datareg
                bpl.s   t_movem7
                bsr     get_adrreg
                bmi.s   t_movem70
                or.w    #8,D0
t_movem7:       rts
t_movem70:      bsr     get_datareg3
                bmi     op_error
                or.w    D4,D0
                rts

t_movep:        bsr     get_datareg
                bmi.s   t_movep2
                add.w   D0,D0
                or.b    D0,14(A3)
                bset    #7,15(A3)
                bsr     chk_com
                bsr.s   t_movep4
                or.b    D0,15(A3)
                move.w  D3,(A2)+
                addq.w  #2,(A3)
                rts
t_movep2:       bsr.s   t_movep4
                or.b    D0,15(A3)
                move.w  D3,(A2)+
                addq.w  #2,(A3)
                bsr     chk_com
                bsr     get_datareg
                bmi     op_error
                add.w   D0,D0
                or.b    D0,14(A3)
                rts
t_movep4:       moveq   #0,D3
                cmpi.b  #'(',(A0)
                beq     get_indirect2
                bsr     get_wert
                tst.b   2(A3,D5.w)
                bne.s   t_movep5        ;Symbol
                cmp.l   #$FFFF,D3
                bls     get_indirect2
                move.w  D3,D0
                ext.l   D0
                cmp.l   D3,D0
                bne     val_error
                bra     get_indirect2
t_movep5:       move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                ori.w   #$10,D0
                move.w  D0,2(A3,D5.w)
                bra     get_indirect2

t_moveq:        cmpi.b  #'#',(A0)+
                beq.s   t_moveq5
                subq.l  #1,A0
t_moveq5:       bsr     get_wert
                tst.b   2(A3,D5.w)
                bne.s   t_moveq2
                cmp.l   #$FF,D3
                bls.s   t_moveq4
                move.b  D3,D0
                ext.w   D0
                ext.l   D0
                cmp.l   D3,D0
                bne     val_error
t_moveq4:       move.b  D3,15(A3)
t_moveq3:       bsr     chk_com
                bsr     get_datareg
                bmi     op_error
                add.w   D0,D0
                or.b    D0,14(A3)
                rts
t_moveq2:       bsr.s   get_quick
                bra.s   t_moveq3

get_quick:      tst.b   3(A3,D5.w)
                bne.s   get_quick2      ;Minus, dann Formeleintrag
                move.w  D3,2(A3,D5.w)
                ori.b   #$C0,2(A3,D5.w)
                rts
get_quick2:     move.l  A1,-(SP)
                bsr     next_free_entry ;A1 zeigt auf Eintrag der Tabelle
                move.w  D0,2(A3,D5.w)   ;Index speichern
                ori.b   #$C0,2(A3,D5.w) ;Flag für Quick
                move.b  #$FF,31(A1)     ;Markierung für Labelsuchroutine
                addq.l  #6,A1
                move.w  #$88,(A1)+
                move.w  D3,(A1)+        ;Labelindex
                move.w  #$FF,(A1)+      ;Endekennung
                movea.l (SP)+,A1
                rts

t_nop:          rts

t_pea:          move.w  #$1E1B,D1
                bsr     get_ea
                bne.s   t_pea1
                ori.b   #$10,15(A3)     ;für Macro
t_pea1:         rts

t_stop:         cmpi.b  #'#',(A0)+
                bne     op_error
                bsr     get_wert
                move.w  D3,(A2)
                move.b  #4,1(A3)
                rts

t_linea:        cmpi.b  #'#',(A0)
                bne.s   t_line2
                addq.l  #1,A0
t_line2:        bsr     get_wert
                tst.b   2(A3,D5.w)
                bne     synt_error
                btst    #4,editor3_flag(A4) ;Mac-Mode?
                bne.s   t_line5         ;Ja! =>
                cmp.l   #15,D3
                bhi     val_error
t_line5:        or.w    D3,14(A3)
                bsr     cut_space
t_line3:        move.b  (A0)+,D0
                beq.s   t_line4
                cmp.b   #';',D0
                bne.s   t_line3
t_line4:        subq.w  #1,A0
                rts

t_trap:         cmpi.b  #'#',(A0)
                bne.s   t_trap2
                addq.l  #1,A0
t_trap2:        bsr     get_wert
                tst.b   2(A3,D5.w)
                bne.s   t_trap3
                cmp.l   #15,D3
                bhi     op_error
                or.b    D3,15(A3)
                rts
t_trap3:        bsr     get_quick
                rts

t_unlk:         bsr.s   get_adrreg
                bmi     op_error
                or.b    D0,15(A3)
                rts

************************************************************************
*  holt eine Macroparameternummer ab A0-1 nach D0                      *
************************************************************************
get_par_nummer: IF version<$0200
                bra     op_error        ;Grundversion kann keine Macros
                ELSE
                move.w  D1,-(SP)
                addq.l  #1,A0
                moveq   #0,D0
                move.b  (A0)+,D0
                sub.w   #$30,D0
                bmi     synt_error      ;keine Ziffer
                cmp.w   #9,D0
                bhi     synt_error      ;keine Ziffer
                moveq   #0,D1
                move.b  (A0),D1
                sub.w   #$30,D1
                bmi.s   get_par_1
                cmp.w   #9,D1
                bhi.s   get_par_1
                mulu    #10,D0
                add.w   D1,D0
                addq.l  #1,A0
                cmp.w   #31,D0
                bhi     val_error       ;Wert zu groß
get_par_1:      or.w    #$80,D0
                move.w  (SP)+,D1
                rts
                ENDC
************************************************************************
*  holt ein Adressregister ab A0 nach D0                               *
*  wenn Fehler, D0 = -1 und A0 wird rekonstruiert                      *
************************************************************************
get_adrreg:     lea     allowed_chars(PC),A1
                move.b  (A0)+,D0
                cmp.b   #'A',D0
                beq.s   get_adrreg4
                cmp.b   #'a',D0
                beq.s   get_adrreg4
                cmp.b   #'s',D0
                beq.s   get_adrreg2
                cmp.b   #'S',D0
                beq.s   get_adrreg2
                subq.w  #1,A0           ;kein Adressregister -> -1
                moveq   #-1,D0
                rts
get_adrreg2:    move.b  (A0)+,D0
                cmp.b   #'p',D0
                beq.s   get_adrreg3
                cmp.b   #'P',D0
                beq.s   get_adrreg3
                subq.w  #2,A0
                moveq   #-1,D0
                rts
get_adrreg3:    moveq   #0,D0
                move.b  (A0),D0
                tst.b   0(A1,D0.w)
                bne.s   get_adrreg5     ;folgendes Zeichen im Label erlaubt
                moveq   #7,D0
                rts
get_adrreg5:    subq.w  #2,A0
                moveq   #-1,D0
                rts
get_adrreg4:    moveq   #0,D0
                move.b  (A0)+,D0
                subi.w  #'0',D0
                bmi.s   get_adrreg5     ;keine Ziffer
                cmp.w   #7,D0
                bgt.s   get_adrreg5     ;keine Ziffer
                moveq   #0,D2
                move.b  (A0),D2
                tst.b   0(A1,D2.w)
                bne.s   get_adrreg5     ;folgendes Zeichen im Label erlaubt
                tst.w   D0
                rts

************************************************************************
* holt ein Datenregister ab A0 nach D0                                 *
************************************************************************
get_datareg:    cmpi.b  #'D',(A0)
                beq.s   get_datareg2
                cmpi.b  #'d',(A0)
                beq.s   get_datareg2
                moveq   #-1,D0          ;kein Datenregister
                rts
get_datareg2:   addq.w  #1,A0
get_datareg3:   moveq   #0,D0
                move.b  (A0)+,D0
                sub.w   #'0',D0
                bmi.s   get_adrreg5
                cmp.w   #7,D0
                bgt.s   get_adrreg5
                lea     allowed_chars(PC),A1
                moveq   #0,D2
                move.b  (A0),D2
                tst.b   0(A1,D2.w)
                bne.s   get_adrreg5
                tst.w   D0
                rts

get_regnr:      addq.l  #1,A0
                move.b  (A0)+,D0
                sub.b   #'0',D0
                bmi.s   regnr_err
                cmp.b   #7,D0
                bgt.s   regnr_err
                andi.w  #7,D0
                rts
regnr_err:      movea.l D7,SP
                moveq   #-8,D0
                bra     operand_err
get_regnr2:     move.b  1(A0),D0
                sub.b   #'0',D0
                bmi.s   get_regnr3
                cmp.b   #7,D0
                bgt.s   get_regnr3
                moveq   #0,D2
                move.b  2(A0),D2
                tst.b   0(A1,D2.w)      ;Folgezeichen im Label erlaubt
                bne.s   get_regnr3
                addq.l  #2,A0
                rts
get_regnr3:     addq.w  #4,SP
                bra     failed

************************************************************************
*  testet unmittelbaren Wert auf die vom Opcode gegebenen Breite und   *
*  schreibt Wert in Puffer                                             *
************************************************************************
set_imidiate:   move.b  D4,D0           ;Daten für unmittelbaren Operanten aus
                beq.s   set_imi1        ;Befehlstabelle
                bmi.s   set_imi3        ;Befehle wie ADDA,etc.
                cmp.b   #3,D0
                bhi.s   set_imi31
                beq.s   tst_word
                cmp.w   #1,D0
                beq.s   tst_byte
                bra.s   set_imi2
set_imi3:       cmp.b   #$FF,D0         ;Macroaufruf?
                beq.s   set_imi2        ;ja
set_imi31:      btst    #0,14(A3)
                beq.s   tst_word
                bra.s   set_imi2
set_imi1:       move.b  15(A3),D0
                rol.b   #2,D0
                and.w   #3,D0
                beq.s   tst_byte
                cmp.b   #1,D0
                beq.s   tst_word
                cmp.b   #2,D0
                bne     syn_error
set_imi2:       tst.b   2(A3,D5.w)
                beq.s   kein_lab4
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                ori.w   #$20,D0
                move.w  D0,2(A3,D5.w)
kein_lab4:      addq.w  #4,(A3)
                move.l  D3,(A2)+
                rts
tst_byte:       tst.b   2(A3,D5.w)
                beq.s   tst_by1
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                move.w  D0,2(A3,D5.w)
                bra.s   tst_esc
tst_by1:        move.l  D3,D0
                and.l   #$FFFFFF00,D0
                beq.s   tst_esc
                move.l  D3,D0
                ext.w   D0
                ext.l   D0
                cmp.l   D0,D3
                bne.s   val_error
                and.w   #$FF,D3
                bra.s   tst_esc
tst_word:       tst.b   2(A3,D5.w)
                beq.s   tst_wo1
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                or.w    #$10,D0
                move.w  D0,2(A3,D5.w)
                bra.s   tst_esc
tst_wo1:        move.l  D3,D0
                swap    D0
                tst.w   D0
                beq.s   tst_esc
                move.l  D3,D0
                ext.l   D0
                cmp.l   D0,D3
                bne.s   val_error
tst_esc:        addq.w  #2,(A3)
                move.w  D3,(A2)+
                rts
val_error:      moveq   #-5,D0
                movea.l D7,SP
                bra     operand_err

************************************************************************
* holt Adressregister in Klammern                                      *
************************************************************************
get_indirect:   addq.l  #1,A0
get_indirect2:  cmpi.b  #'(',(A0)+
                bne     op_error
                bsr     get_adrreg
                bmi     op_error
                cmpi.b  #')',(A0)+
                bne     op_error
                rts

************************************************************************
* holt <EA>, und odert sie in den Opcode                               *
* Bitplane in D1 gibt die erlaubten EAs an                             *
************************************************************************
get_ea:         moveq   #0,D3
                movem.l D0/A1,-(SP)
                andi.w  #$FFC0,14(A3)   ;EA-Bits löschen
                lea     allowed_chars(PC),A1 ;Tabelle für erlaubte Labelzeichen
                move.b  (A0),D0
                cmp.b   #'#',D0
                beq     immidiate
                cmp.b   #'D',D0
                beq     data_reg
                cmp.b   #'d',D0
                beq     data_reg
                cmp.b   #'A',D0
                beq     adr_reg
                cmp.b   #'a',D0
                beq     adr_reg
                cmp.b   #'(',D0
                beq     indirect
                cmp.b   #'-',D0
                beq     predecrement
                cmp.b   #'C',D0
                beq     _ccr
                cmp.b   #'c',D0
                beq     _ccr
                cmp.b   #'S',D0
                beq     _sr
                cmp.b   #'s',D0
                beq     _sr
                cmp.b   #'U',D0
                beq     _usp
                cmp.b   #'u',D0
                beq     _usp
failed:         bsr     get_wert
                cmpi.b  #'(',(A0)
                beq     indirect2
                btst    #7,D1
                bne     ea_error
                cmpi.b  #'\',(A0)
                beq.s   adr_long2
                cmpi.b  #'.',(A0)
                bne.s   adr_long
adr_long2:      addq.l  #1,A0
                move.b  (A0)+,D0
                cmp.b   #'L',D0
                beq.s   adr_long
                cmp.b   #'l',D0
                beq.s   adr_long
                cmp.b   #'W',D0
                beq.s   adr_short
                cmp.b   #'w',D0
                beq.s   adr_short
                cmp.b   #'s',D0
                beq.s   adr_short
                cmp.b   #'S',D0
                bne     syn_error
adr_short:      ori.b   #%111000,15(A3)
                tst.b   2(A3,D5.w)
                beq.s   kein_lab3b
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                ori.w   #$10,D0
                move.w  D0,2(A3,D5.w)
kein_lab3b:     addq.w  #2,(A3)
                cmp.l   #$FFFF,D3
                bls.s   kein_lab3c      ;Oberes Word=0? => ok
                move.l  D3,D0
                swap    D0
                addq.w  #1,D0
                beq.s   kein_lab3c      ;Oberes Word=$FFFF? => ok
                cmp.w   #$0100,D0
                bne     val_error       ;Oberes Word=$FF? => ok
kein_lab3c:     move.w  D3,(A2)+
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
adr_long:       ori.b   #%111001,15(A3)
                tst.b   2(A3,D5.w)
                beq.s   kein_lab3
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                ori.w   #$20,D0
                move.w  D0,2(A3,D5.w)
kein_lab3:      addq.w  #4,(A3)
                move.l  D3,(A2)+
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
_usp:           cmpi.b  #'s',1(A0)
                beq.s   _usp2
                cmpi.b  #'S',1(A0)
                bne     failed
_usp2:          cmpi.b  #'p',2(A0)
                beq.s   _usp3
                cmpi.b  #'P',2(A0)
                bne     failed
_usp3:          moveq   #0,D0
                move.b  3(A0),D0
                tst.b   0(A1,D0.w)      ;Folgezeichen im Label erlaubt
                bne     failed
                btst    #12,D1
                bne     ea_error
                move.b  #$3F,15(A3)
                addq.l  #3,A0
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
_ccr:           cmpi.b  #'c',1(A0)
                beq.s   _ccr2
                cmpi.b  #'C',1(A0)
                bne     failed
_ccr2:          cmpi.b  #'r',2(A0)
                beq.s   _ccr3
                cmpi.b  #'R',2(A0)
                bne     failed
_ccr3:          moveq   #0,D0
                move.b  3(A0),D0
                tst.b   0(A1,D0.w)      ;Folgezeichen im Label erlaubt
                bne     failed
                btst    #10,D1
                bne     ea_error
                move.b  #%111110,15(A3)
                addq.l  #3,A0
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
_sr:            cmpi.b  #'P',1(A0)
                beq.s   _sp
                cmpi.b  #'p',1(A0)
                beq.s   _sp
                cmpi.b  #'r',1(A0)
                beq.s   _sr2
                cmpi.b  #'R',1(A0)
                bne     failed
_sr2:           moveq   #0,D0
                move.b  2(A0),D0
                tst.b   0(A1,D0.w)      ;Folgezeichen im Label erlaubt
                bne     failed
                btst    #11,D1
                bne     ea_error
                move.b  #%1111100,15(A3)
                addq.l  #2,A0
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
_sp:            moveq   #0,D0
                move.b  2(A0),D0
                tst.b   0(A1,D0.w)      ;Folgezeichen im Label erlaubt
                bne     failed
                moveq   #7,D0
                addq.l  #2,A0
                bra.s   adr_re2
data_reg:       bsr     get_regnr2
                btst    #0,D1
                bne     ea_error
                or.b    D0,15(A3)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
adr_reg:        bsr     get_regnr2
adr_re2:        btst    #1,D1
                bne     ea_error
                ori.b   #%1000,D0
                or.b    D0,15(A3)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
immidiate:      addq.l  #1,A0
                btst    #9,D1
                bne.s   ea_error
                bsr     get_wert
                bsr     set_imidiate
                ori.w   #%111100,14(A3)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
_sp2:           addq.l  #1,A0
                move.b  (A0)+,D0
                cmp.b   #'p',D0
                beq.s   _sp3
                cmp.b   #'P',D0
                bne.s   failed2
_sp3:           moveq   #7,D0
                bra.s   ind_sp
failed2:        subq.l  #3,A0
                bra     failed
indirect:       addq.l  #1,A0
                cmpi.b  #'S',(A0)
                beq.s   _sp2
                cmpi.b  #'s',(A0)
                beq.s   _sp2
                cmpi.b  #'a',(A0)
                beq.s   adr_rel
                cmpi.b  #'A',(A0)
                bne     pc_relb
adr_rel:        bsr     get_regnr
ind_sp:         cmpi.b  #')',(A0)+
                bne     second_reg
                cmpi.b  #'+',(A0)
                beq.s   increment
                btst    #2,D1
                bne.s   ea_error
                ori.b   #%10000,D0
                or.b    D0,15(A3)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
ea_error:       moveq   #-7,D0
                movea.l D7,SP
                bra     operand_err
increment:      addq.l  #1,A0
                btst    #3,D1
                bne.s   ea_error
                ori.b   #%11000,D0
                or.b    D0,15(A3)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
predecrement:   cmpi.b  #'(',1(A0)
                beq.s   pre2
                bra     failed
pre2:           btst    #4,D1
                bne.s   ea_error
                addq.w  #2,A0
                bsr     get_adrreg
                bmi     op_error
                cmpi.b  #')',(A0)+
                bne.s   syn_error
                ori.b   #%100000,D0
                or.b    D0,15(A3)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
syn_error:      moveq   #-8,D0
                movea.l D7,SP
                bra     operand_err
pc_rela:        cmpi.b  #'p',(A0)
                beq.s   pc_rel2
                cmpi.b  #'P',(A0)
                beq.s   pc_rel2
                subq.w  #1,A0
                bra     op_error
pc_relb:        cmpi.b  #'p',(A0)
                beq.s   pc_rel2
                cmpi.b  #'P',(A0)
                beq.s   pc_rel2
                subq.w  #1,A0
                bra     failed
pc_rel2:        btst    #8,D1
                bne     ea_error
                addq.w  #1,A0
                move.b  (A0)+,D0
                cmp.b   #'c',D0
                beq.s   pc_rel3
                cmp.b   #'C',D0
                bne     failed2
pc_rel3:        cmpi.b  #')',(A0)+
                beq.s   no_second
                tst.b   macro_flag(A4)
                beq.s   pc_rel31        ;kein Macroaufruf
                move.w  D3,(A2)+        ;Wert speichern
                addq.w  #2,(A3)         ;Länge plus 2
                clr.w   (A2)
pc_rel31:       bsr     get_second
                ori.b   #%111011,15(A3)
                tst.b   2(A3,D5.w)
                beq.s   kein_lab7
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                addq.b  #1,D0
                ori.w   #$80,D0
                move.w  D0,2(A3,D5.w)
                lsr.w   #8,D3
                ori.b   #$80,D3
                move.b  D3,2(A3,D5.w)
kein_lab7:      addq.w  #2,(A3)         ;xx(PC,Xn)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
no_second:      ori.b   #%111010,15(A3)
                cmp.l   #$FFFF,D3
                bls.s   no_second1a
                move.l  D3,D0
                ext.l   D0
                cmp.l   D3,D0
                bne     val_error
no_second1a:    move.w  D3,(A2)+
                tst.b   2(A3,D5.w)
                beq.s   kein_lab2
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                ori.w   #$90,D0
                move.w  D0,2(A3,D5.w)
kein_lab2:      addq.w  #2,(A3)         ;xxxx(PC)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts
indirect2:      addq.l  #1,A0
                bsr     tst_sp
                cmp.w   #7,D0
                beq.s   indirect4
                cmpi.b  #'a',(A0)
                beq.s   indirect3
                cmpi.b  #'A',(A0)
                bne     pc_rela
indirect3:      bsr     get_regnr
indirect4:      cmpi.b  #')',(A0)+
                beq.s   no_second2
second_reg:     btst    #6,D1
                bne     ea_error
                ori.b   #%110000,D0
                or.b    D0,15(A3)       ;xx(Ax,Xn)
                tst.b   macro_flag(A4)
                beq.s   second_regm     ;kein Macroaufruf
                move.w  D3,(A2)+        ;Wert speichern
                addq.w  #2,(A3)         ;Länge plus 2
                clr.w   (A2)
second_regm:    bsr     get_second
                tst.b   2(A3,D5.w)
                beq.s   kein_lab6
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                addq.b  #1,D0
                move.w  D0,2(A3,D5.w)
                lsr.w   #8,D3
                ori.b   #$80,D3
                move.b  D3,2(A3,D5.w)
kein_lab6:      addq.w  #2,(A3)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts

no_second2:     btst    #5,D1
                bne     ea_error
                ori.b   #%101000,D0
                or.b    D0,15(A3)
                cmp.l   #$FFFF,D3
                bls.s   no_second2a
                move.l  D3,D0
                ext.l   D0
                cmp.l   D3,D0
                bne     val_error
no_second2a:    move.w  D3,(A2)+        ;xxxx(Ax)
                tst.b   2(A3,D5.w)
                beq.s   kein_lab
                move.w  2(A3,D5.w),D0
                or.w    (A3),D0
                ori.w   #$10,D0
                move.w  D0,2(A3,D5.w)
kein_lab:       addq.w  #2,(A3)
                movem.l (SP)+,D0/A1
                move    #0,CCR
                rts

tst_sp:         moveq   #0,D0
                cmpi.b  #'S',(A0)
                beq.s   _sp5
                cmpi.b  #'s',(A0)
                beq.s   _sp5
                rts
_sp5:           addq.w  #1,A0
                move.b  (A0)+,D0
                cmp.b   #'P',D0
                beq.s   _sp4
                cmp.b   #'p',D0
                bne     syn_error
_sp4:           moveq   #7,D0
                rts

get_second:     cmpi.b  #'D',(A0)
                beq.s   dat_reg
                cmpi.b  #'d',(A0)
                beq.s   dat_reg
                bset    #7,(A2)
                bsr.s   tst_sp
                cmp.w   #7,D0
                beq.s   sp_reg
                cmpi.b  #'a',(A0)
                beq.s   dat_reg
                cmpi.b  #'A',(A0)
                bne     syn_error
dat_reg:        bsr     get_regnr
sp_reg:         lsl.b   #4,D0
                or.b    D0,(A2)
                cmpi.b  #')',(A0)
                beq.s   end_reg
                cmpi.b  #'.',(A0)+
                bne     syn_error
                cmpi.b  #'W',(A0)
                beq.s   end_re2
                cmpi.b  #'w',(A0)
                beq.s   end_re2
                cmpi.b  #'l',(A0)
                beq.s   end_re3
                cmpi.b  #'L',(A0)
                bne     syn_error
end_re3:        bset    #3,(A2)
end_re2:        addq.l  #1,A0
                cmpi.b  #')',(A0)
                bne     syn_error
end_reg:        addq.l  #1,A0
                tst.b   2(A3,D5.w)
                bne.s   end_reg2
                cmp.l   #$FF,D3
                bls.s   end_reg2
                move.b  D3,D0
                ext.w   D0
                ext.l   D0
                cmp.l   D3,D0
                bne     val_error
end_reg2:       move.b  D3,1(A2)
                addq.l  #2,A2
                rts

************************************************************************
* Binäre Suchroutine                                                   *
* A0 zeigt auf Befehl                                                  *
************************************************************************
search:         movem.l D0-D7/A2-A6,-(SP)
                lea     spaced(A4),A3
                move.l  #'    ',D0
                move.l  D0,(A3)
                move.l  D0,4(A3)        ;Buffer löschen
                lea     search_tab(PC),A5
                moveq   #7,D0           ;max.7 Zeichen holen
                moveq   #0,D1
search1:        move.b  (A0)+,D1        ;Zeichen holen
                move.b  0(A5,D1.w),D1   ;& konvertieren
                beq.s   search4
                bmi.s   search11        ;nur für '=' erfüllt =>
                move.b  D1,(A3)+        ;Ab in den Buffer
                dbra    D0,search1
                bra.s   search3
search11:       moveq   #'=',D1         ;das brauchen wir 'gleich' noch
                move.b  D1,(A3)+
                cmp.b   (A0)+,D1        ;nur ein '='?
                bne.s   search4         ;dann raus
                move.b  D1,(A3)+        ;2.'=' kopieren
                bra.s   search3
search4:        subq.l  #1,A0           ;Pointer zurück (auf das 1.Zeichen dahinter)
search3:        move.l  spaced(A4),D5   ;die vorderen 4 Zeichen holen (=> Buffer)
                move.l  spaced+4(A4),D6 ;die hinteren 4 Zeichen holen
                lea     code_tab(PC),A1
                moveq   #0,D1
                move.w  tablen(A4),D2
search2:        move.w  D1,D4
                add.w   D2,D4
                lsr.w   #1,D4
                move.w  D4,D0
                lsl.w   #4,D0           ;mal 16 (Länge eines Eintrags)
                cmp.l   0(A1,D0.w),D5
                bhi.s   search6
                bne.s   search5
                cmp.l   4(A1,D0.w),D6
                bhi.s   search6
                bne.s   search5
                lea     0(A1,D0.w),A1
                movem.l (SP)+,D0-D7/A2-A6
                rts
search5:        move.w  D4,D2
                cmp.w   D1,D2
                bne.s   search2
                bra.s   search7
search6:        move.w  D4,D1
                addq.w  #1,D1
                cmp.w   D1,D2
                bne.s   search2
search7:        suba.l  A1,A1
                movem.l (SP)+,D0-D7/A2-A6
                rts

search_tab:     DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,'.',0
                DC.B '0123456789:',0,0,-1,'>',0
                DC.B 0,'ABCDEFGHIJKLMNO'
                DC.B 'PQRSTUVWXYZ',0,0,0,0,'_'
                DC.B 0,'ABCDEFGHIJKLMNO'
                DC.B 'PQRSTUVWXYZ',0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                DC.B 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                EVEN

************************************************************************
* durchsucht die Macintosh Trap-Makrotabelle                           *
* ->A0 zeigt auf Befehl                                                *
************************************************************************
search_mactrap: movem.l D0-D1/A2-A3/A5,-(SP)
                suba.l  A1,A1           ;Flag löschen
                btst    #4,editor3_flag(A4) ;Mac Trap-Makros an?
                beq.s   search_mactrap1 ;nein=>
                cmpi.b  #'_',(A0)       ;Unterstreichungsstrich
                bne.s   search_mactrap1 ;kein Trap-Makro=>
                addq.l  #1,A0           ;Zeichen überspringen
                lea     search_tab(PC),A2 ;Tabelle der gültigen Buchstaben
                lea     spaced(A4),A3   ;Zeiger auf Buffer
                moveq   #0,D0
search_mactrap2:move.b  (A0)+,D0        ;Zeichen holen
                move.b  0(A2,D0.w),(A3)+ ;gewandelt in Buffer
                bne.s   search_mactrap2 ;nächstes Zeichen
                subq.l  #1,A0           ;Zeiger ein Zeichen zurück
                lea     mac_trap_tab(PC),A1 ;Zeiger auf die Tabellenstruktur
                move.w  4(A1),D0        ;Offset auf Letteroffsets
                adda.w  D0,A1           ;Zeiger Letteroffset-Tabelle
                move.b  spaced(A4),D1   ;ersten Buchstaben merken
                move.w  D1,D0
                and.w   #$FF,D0
                sub.w   #'A',D0         ;1.Buchstabe der Tabelle
                add.w   D0,D0           ;mal 2
                adda.w  D0,A1           ;Zeiger auf Offset
                adda.w  (A1),A1         ;Zeiger auf 1. passenden Eintrag
search_mactrap4:lea     2(A1),A5        ;Zeiger auf Trapnamen
                cmp.b   (A5),D1         ;mit 1.Buchstaben vergleichen
                bne.s   search_mactrap3 ;ungleich, nicht gefunden =>
                lea     spaced(A4),A3   ;Zeiger auf Buffer
search_mactrap42:move.b (A5)+,D0        ;Zeichen aus Tabelle holen
                bmi.s   search_mactrap41 ;letztes Zeichen=>
                move.b  0(A2,D0.w),D0   ;nach Groß wandeln
                cmp.b   (A3)+,D0        ;mit Zeichen im Buffer vergleichen
                beq.s   search_mactrap42
                tst.b   -(A3)           ;letztes Zeichen im Buffer testen
                beq.s   search_mactrap1 ;Nullbyte,dann auch gefunden=>
search_mactrap43:tst.b  (A5)+           ;Befehl bis zum Ende überlesen
                bpl.s   search_mactrap43
search_mactrap6:movea.l A5,A1           ;Beginn des nächsten Eintrags
                bra.s   search_mactrap4 ;nächsten Eintrag vergleichen
search_mactrap41:and.b  #$7F,D0         ;negativ-Bit löschen
                move.b  0(A2,D0.w),D0   ;nach Groß wandeln
                cmp.b   (A3),D0         ;mit Zeichen im Buffer vergleichen
                beq.s   search_mactrap5 ;gleich, Befehl gefunden =>
                tst.b   (A3)            ;Zeichen testen
                beq.s   search_mactrap1 ;Nullbyte, dann auch gefunden=>
                bra.s   search_mactrap6
search_mactrap5:tst.b   1(A3)           ;wurden mehr Zeichen eingegeben?
                bne.s   search_mactrap6 ;Ja! => nicht gefunden
                bra.s   search_mactrap1 ;sonst => gefunden
search_mactrap3:suba.l  A1,A1           ;nichts gefunden
search_mactrap1:movem.l (SP)+,D0-D1/A2-A3/A5
                rts

************************************************************************
* holt einen Wert (Zahl oder Variable) nach d3                         *
************************************************************************
get_wert:       movem.l D0-D1/D4/D6/A1,-(SP)
                bsr     cut_space
                move.b  (A0),D0
                cmp.b   #'(',D0
                beq.s   _formel
                cmp.b   #'*',D0         ;PC
                beq.s   _formel
                cmp.b   #'^',D0         ;interne Variablen
                beq.s   _formel
                cmp.b   #'!',D0
                beq.s   _formel
                cmp.b   #'~',D0
                beq.s   _formel
                IF version>=$0200
                cmp.b   #'\',D0
                beq.s   _formel
                ENDC
                cmp.b   #'#',D0
                beq     synt_error
                move.l  A0,D6
                bsr     get_zahl
                tst.w   D1
                bmi.s   wer_err
                cmp.w   #15,D1
                beq.s   label
                cmp.w   #14,D1
                beq.s   _formel2
                move.l  D0,D3
                andi.b  #8,D4           ;Vorzeichen
                or.b    D4,D1
                move.w  D1,2(A3,D5.w)
wer_rts:        cmpi.b  #' ',(A0)+
                beq.s   wer_rts
                subq.l  #1,A0
                move.b  (A0),D0
                beq.s   wer_rt2
                cmp.b   #',',D0
                beq.s   wer_rt2
                cmp.b   #'[',D0
                beq.s   wer_rt2
                cmp.b   #'\',D0
                beq.s   wer_rt2
                cmp.b   #'(',D0
                beq.s   wer_rt2
                cmp.b   #'.',D0
                beq.s   wer_rt2
                cmp.b   #';',D0
                beq.s   wer_rt2
_formel2:       movea.l D6,A0
_formel:        bsr.s   get_formel
wer_rt2:        movem.l (SP)+,D0-D1/D4/D6/A1
                rts
label:          bsr     t_search_label
                tst.b   5(A1)
                bgt     synt_error      ;Registerliste
                andi.w  #$3FFF,D0
                move.l  D0,D3
                tst.b   macro_flag(A4)
                bne.s   label1          ;Macroaufruf
                andi.w  #$40,D4         ;Vorzeichen
                ori.w   #$0100,D4
                move.w  D4,2(A3,D5.w)
                bra.s   wer_rts
wer_err:        movea.l D7,SP
                move.l  D1,D0
                bra     operand_err
label1:         and.w   #8,D4
                ori.w   #$0100,D4
                move.w  D4,2(A3,D5.w)
                bra.s   wer_rts

************************************************************************
* Formelausdruck ab A0 holen                                           *
************************************************************************
get_f_tab:      DC.B '<<','>>','==','<=','=<','>=','=>','<>','><' ;9
                DC.B '+-|^*/&%=<>' ;11
get_f_tab2:     DC.B $0F,$0F,$0E,$0E,$0D,$0D,$0A,5,4
                DC.B $0C,$0B,$0A,9,8,7,6,3,2,1,0
                EVEN
get_formel:     movem.l D2/D5-D6/A2-A3/A5-A6,-(SP)
                bsr     next_free_entry
                lea     27(A1),A5       ;max. Länge für Word
                lea     25(A1),A6       ;max. Länge für Long
                move.w  #$0100,2(A3,D5.w) ;Flag für Label/Formel setzen
                move.b  #$FF,31(A1)     ;Formelflag setzen
                bset    #7,4(A1)        ;defined-flag setzen
                lea     6(A1),A2        ;Platz für Wert
                moveq   #0,D3
                move.w  D0,D3           ;Indexnummer merken
                moveq   #0,D2           ;Klammerebenen
                moveq   #0,D5           ;Rechenoperation
                moveq   #0,D6           ;Zähler für Reloc
                moveq   #0,D1
                bsr     cut_space
                cmpi.b  #'(',1(A0)
                bne     get_formel8     ;auf '-(' testen
                cmpi.b  #'-',(A0)
                beq.s   get_formel01
                cmpi.b  #'~',(A0)       ;auf '~(' testen
                bne     get_formel8
                moveq   #3,D5           ;für Not
                bra.s   get_formel02
get_formel01:   moveq   #1,D5           ;Rechenoperation ist '-'
get_formel02:   addq.l  #1,A0
                bra     get_formel8
get_formel3:    moveq   #0,D1           ;Zähler für Klammern
get_formel11:   move.b  (A0)+,D0
                beq     formelende
                cmp.b   #' ',D0
                beq     formelende
                cmp.b   #'.',D0
                beq     formelende
                cmp.b   #'(',D0
                beq.s   formelende
                cmp.b   #',',D0
                beq.s   formelende
                cmp.b   #';',D0
                beq.s   formelende
                cmp.b   #')',D0
                bne.s   get_formel0
                addq.w  #1,D1
                cmp.w   #4,D1
                blt.s   get_formel11
                bra     synt_error
get_formel0:    sub.w   D1,D2
                bmi     synt_error      ;mehr ')' als '('
                lsl.w   #6,D1
                move.b  D1,(A2)
                moveq   #0,D1
                lsl.w   #8,D0
                move.b  (A0)+,D0        ;zweites Zeichen holen
                lea     get_f_tab(PC),A3
                moveq   #8,D5           ;Anz. der 2 Zeichen Operationen
get_formel5:    cmp.w   (A3)+,D0
                dbeq    D5,get_formel5  ;mit erlaubten Rechenzeichen
                beq.s   get_formel13    ;gefunden
                lsr.w   #8,D0           ;erstes Zeichen
                subq.l  #1,A0
                moveq   #10,D5
get_formel5a:   cmp.b   (A3)+,D0
                dbeq    D5,get_formel5a
                bne     synt_error
                addi.w  #9,D5
get_formel13:   lea     get_f_tab2(PC),A3
                move.b  0(A3,D5.w),D5   ;Operationscode holen
                bra.s   get_formel8
get_formel7:    addq.w  #1,A0
                addq.w  #1,D1
                cmp.w   #4,D1
                beq     synt_error
get_formel8:    cmpi.b  #'(',(A0)
                beq.s   get_formel7
                add.w   D1,D2
                lsl.w   #4,D1
                or.w    D5,D1
                or.b    (A2),D1
                move.b  D1,(A2)+
                bsr.s   get_formel2
                bra     get_formel3
formelende:     sub.w   D1,D2
                tst.w   D2
                bne     synt_error
                lsl.w   #6,D1
                move.b  D1,(A2)+
                move.b  #$FF,(A2)       ;Endekennung
                subq.w  #1,A0
                movem.l (SP)+,D2/D5-D6/A2-A3/A5-A6
                rts

get_formel2:    bsr     cut_space
                moveq   #$20,D0
                cmpi.b  #'!',(A0)+
                beq.s   get_formel22
                moveq   #$10,D0
                cmpi.b  #'~',-1(A0)
                beq.s   get_formel22
                subq.l  #1,A0
                moveq   #0,D0
get_formel22:   move.b  D0,(A2)         ;spezielle Vorzeichen
                bsr     get_zahl
                tst.w   D1
                bmi     val_error
                cmpa.l  A5,A2
                bgt     get_for4        ;Eintrag zuende
                cmp.w   #14,D1          ;keine Zahl?
                beq     synt_error
                cmp.w   #15,D1
                beq.s   get_for2        ;Symbol
                andi.b  #8,D4
                or.b    D4,D1
                cmp.l   #$FFFF,D0       ;Größe der Zahl testen
                bhi.s   get_for3        ;Long
                or.b    D1,(A2)+        ;Flag zur Zahl/Label
                move.w  D0,(A2)+        ;Zahl(word)
                rts
get_for3:       cmpa.l  A6,A2
                bgt     get_for4
                bset    #6,D1
                or.b    D1,(A2)+
                move.l  D0,(A2)+        ;Zahl(long)
                rts
get_for2:       cmpi.b  #'*',(A0)
                beq.s   get_for22       ;Variable für ak. PC
                cmpi.b  #'^',(A0)
                beq.s   get_for23       ;interne Variablen
                IF version>=$0200
                cmpi.b  #'\',(A0)
                beq     get_for24       ;Macroparameter
                ENDC
                bsr     t_search_label  ;Label
                tst.b   4(A1)           ;defined-flag testen
                bpl.s   get_for21       ;undefiniert, nichts zu machen
                tst.b   5(A1)           ;Typ testen
                bmi.s   get_for21
                bne     get_for42
get_for21:      andi.w  #8,D4           ;Vorzeichen
                ori.b   #$80,D4
                or.b    D4,(A2)+
                move.w  D0,(A2)+
                rts
get_for22:      addq.l  #1,A0
                move.b  #$80,(A2)+
                move.w  #$8000,(A2)+
                rts
get_for23:      addq.w  #1,A0           ;interne Variablen
                cmpi.b  #'^',(A0)+
                bne.s   get_for43
                move.l  A2,-(SP)
                lea     search_tab(PC),A2 ;Tabelle der Zeichen
                lea     spaced(A4),A1   ;Buffer
                moveq   #0,D0
                move.l  D0,(A1)         ;Buffer löschen
                move.l  D0,4(A1)
get_for25:      move.b  (A0)+,D0
                cmp.b   #'=',D0         ;Sonderabfrage, da diese
                beq.s   get_for251      ;Zeichen bei Befehlen möglich sind
                cmp.b   #'>',D0
                beq.s   get_for251
                move.b  0(A2,D0.w),(A1)+ ;Zeichen kopieren
                bne.s   get_for25       ;kein Ende
get_for251:     subq.l  #1,A0
                movea.l (SP)+,A2
                lea     spaced(A4),A1
                move.l  (A1),D0         ;ersten 4 Zeichen
                move.l  4(A1),D1        ;letzten 4 Zeichen
                lea     va_tab-8(PC),A1
get_for27:      addq.l  #8,A1
                tst.l   (A1)
                beq.s   get_for43
                cmp.l   (A1),D0
                bne.s   get_for27
                cmp.l   4(A1),D1
                bne.s   get_for27
                suba.l  #va_tab,A1      ;Offset berechnen
                move.w  A1,D0
                andi.w  #8,D4           ;Vorzeichen
                ori.b   #$80,D4
                or.b    D4,(A2)+
                ori.w   #$8000,D0
                move.w  D0,(A2)+
                rts
                IF version>=$0200
get_for24:      addq.l  #1,A0
                moveq   #0,D0
                move.b  (A0)+,D0
                sub.w   #$30,D0
                bmi     synt_error      ;keine Ziffer
                cmp.w   #9,D0
                bhi     synt_error      ;keine Ziffer
                moveq   #0,D1
                move.b  (A0),D1
                sub.w   #$30,D1
                bmi.s   get_for241
                cmp.w   #9,D1
                bhi.s   get_for241
                mulu    #10,D0
                add.w   D1,D0
                addq.l  #1,A0
get_for241:     cmp.w   #31,D0
                bhi     val_error       ;Wert zu groß
                or.w    #$C000,D0       ;Kennung für Macroparameter
                andi.w  #8,D4           ;Vorzeichen
                ori.b   #$80,D4
                or.b    D4,(A2)+
                move.w  D0,(A2)+
                rts
                ENDC
get_for43:      moveq   #-1,D0
                bra.s   get_for41
get_for42:      moveq   #-14,D0         ;unerlaubter Operand
                bra.s   get_for41
get_for4:       moveq   #-13,D0         ;Ausdruck zu komplex
get_for41:      movem.l (SP)+,D2/D5-D6/A2-A3/A5-A6
                movea.l D7,SP
                bra     operand_err

************************************************************************
* Zahl ab A0 holen                                                     *
* <- D0 die geholte Zahl                                               *
* <- D1 = -1 => Fehler/0=Dez,1=Hex,2=Bin,3=Oktal,4=Char,15=keine Zahl  *
* <- D4 = 0 positiv/ =-1 negativ                                       *
* <- A0 zeigt hinter die Zahl                                          *
************************************************************************
get_no_zahl2:   moveq   #14,D1
                bra     get_zahl_end2
get_nxt_zahl:   not.w   D4
get_nxt_zahl2:  addq.l  #1,A0
                bra.s   get_zahl2
get_zahl:       movem.l D2-D3,-(SP)
                moveq   #0,D4
get_zahl2:      moveq   #0,D0
                move.b  (A0),D0
                cmp.b   #'(',D0
                beq.s   get_no_zahl2
                cmp.b   #'$',D0
                beq     get_hex_zahl
                cmp.b   #'%',D0
                beq     get_bin_zahl
                cmp.b   #$22,D0
                beq     get_asc_zahl
                cmp.b   #$27,D0
                beq     get_asc_zahl
                cmp.b   #'-',D0
                beq.s   get_nxt_zahl
                cmp.b   #'+',D0
                beq.s   get_nxt_zahl2
                cmp.b   #'.',D0
                bne.s   get_zahl3
                addq.l  #1,A0
get_zahl3:      moveq   #0,D1
                move.b  (A0),D1
                sub.b   #'0',D1
                bmi.s   get_no_zahl3
                cmp.b   #9,D1
                bhi.s   get_no_zahl3
                addq.l  #1,A0
get_dez_zahl:   move.b  (A0)+,D0
                cmp.b   #' ',D0
                bne.s   get_dez_zahl1
                move.b  (A0)+,D0        ;max.ein Space überlesen
get_dez_zahl1:  subi.b  #'0',D0
                bmi.s   get_dez_zahl2
                cmp.b   #9,D0
                bhi.s   get_dez_zahl2
                add.l   D1,D1
                bcs.s   get_zahl_ov
                move.l  D1,D2
                add.l   D1,D1           ;Obergrenze von 2^32-1 = 4294967295
                bcs.s   get_zahl_ov
                add.l   D1,D1
                bcs.s   get_zahl_ov
                add.l   D2,D1
                bcs.s   get_zahl_ov
                add.l   D0,D1
                bcc.s   get_dez_zahl
                bra.s   get_zahl_ov
get_dez_zahl2:  move.l  D1,D0
                moveq   #0,D1
                bra     get_zahl_end
get_zahl_ov:    moveq   #-5,D1
                bra     get_zahl_end2
get_zahl_err:   moveq   #-1,D1
                bra     get_zahl_end2

get_no_zahl3:   cmpi.b  #'.',-(A0)
                beq.s   get_no_zahl     ;lokales Symbol
                addq.l  #1,A0
get_no_zahl:    moveq   #15,D1
                bra     get_zahl_end2

get_bin_zahl:   addq.l  #1,A0
                cmpi.b  #'-',(A0)
                bne.s   get_bin_zahl0
                addq.l  #1,A0
                not.w   D4
get_bin_zahl0:  moveq   #32,D3
                moveq   #0,D1
                move.b  (A0)+,D0
                cmp.b   #' ',D0
                bne.s   get_bin_zahl3
                move.b  (A0)+,D0        ;max.ein Space überlesen
get_bin_zahl3:  subi.b  #'0',D0
                bmi.s   get_zahl_err
                cmp.b   #1,D0
                bhi.s   get_zahl_err
get_bin_zahl1:  subq.w  #1,D3
                bmi.s   get_zahl_err
                roxr.b  #1,D0
                addx.l  D1,D1
                move.b  (A0)+,D0
                cmp.b   #' ',D0
                bne.s   get_bin_zahl4
                move.b  (A0)+,D0        ;max.ein Space überlesen
get_bin_zahl4:  subi.b  #'0',D0
                bmi.s   get_bin_zahl2
                cmp.b   #1,D0
                bls.s   get_bin_zahl1
get_bin_zahl2:  move.l  D1,D0
                moveq   #2,D1
                bra     get_zahl_end

get_asc_zahl:   move.b  D0,D2
                addq.l  #1,A0
                moveq   #0,D0
                moveq   #4,D3
get_asc_zahl1:  move.l  D0,D1
                rol.l   #8,D0
                move.b  (A0)+,D0
                beq.s   get_zahl_err
                cmp.b   D2,D0
                dbeq    D3,get_asc_zahl1
                bne.s   get_zahl_err
                cmp.b   (A0),D2         ;zweimal Endezeichen ?
                bne.s   get_asc_zahl2   ;nein
                subq.w  #1,D3
                addq.l  #1,A0           ;Zeiger weitersetzen
                bra.s   get_asc_zahl1
get_asc_zahl2:  andi.w  #1,D2           ;Endekennung
                move.l  D1,D0
                moveq   #4,D1
                or.w    D2,D1
                addq.w  #1,A0
                bra     get_zahl_end

get_hex_zahl:   addq.l  #1,A0
                cmpi.b  #'-',(A0)
                bne.s   get_hex_zahl0
                addq.l  #1,A0
                not.w   D4
get_hex_zahl0:  moveq   #8,D3
                moveq   #0,D2
                move.b  (A0)+,D0
                cmp.b   #' ',D0
                bne.s   get_hex_zahl00
                move.b  (A0)+,D0        ;max.ein Space überlesen
get_hex_zahl00: sub.b   #'0',D0
                bmi     get_zahl_err
                cmp.b   #9,D0
                bls.s   get_hex_zahl1
                subq.b  #7,D0
                cmp.b   #10,D0
                blo     get_zahl_err
                cmp.b   #15,D0
                bls.s   get_hex_zahl1
                sub.b   #$20,D0
                cmp.b   #10,D0
                blo     get_zahl_err
                cmp.b   #15,D0
                bhi     get_zahl_err
get_hex_zahl1:  subq.w  #1,D3
                bmi     get_zahl_err
                or.w    D0,D2
                move.l  D2,D1
                lsl.l   #4,D2
                move.b  (A0)+,D0
                cmp.b   #' ',D0
                bne.s   get_hex_zahl11
                move.b  (A0)+,D0        ;max.ein Space überlesen
get_hex_zahl11: sub.b   #'0',D0
                bmi.s   get_hex_zahl2
                cmp.b   #9,D0
                bls.s   get_hex_zahl1
                subq.b  #7,D0
                cmp.b   #10,D0
                blo.s   get_hex_zahl2
                cmp.b   #15,D0
                bls.s   get_hex_zahl1
                sub.b   #$20,D0
                cmp.b   #10,D0
                bcs.s   get_hex_zahl2
                cmp.b   #15,D0
                bls.s   get_hex_zahl1
get_hex_zahl2:  move.l  D1,D0
                moveq   #1,D1
get_zahl_end:   subq.l  #1,A0
                tst.w   D4
                bpl.s   get_zahl_end2
                neg.l   D0
get_zahl_end2:  movem.l (SP)+,D2-D3
                rts

************************************************************************
* Label oder Variable suchen                                           *
* <- D0 = -1 =>Fehler / sonst Index des Labels/Variable                *
* <- A1 = Adresse der Variable oder des Labels                         *
************************************************************************
t_search2:      movem.l D1-D4/A2-A3/A5-A6,-(SP)
                lea     allowed_chars(PC),A2
                moveq   #0,D0
                move.b  (A0),D0         ;erstes Zeichen
                cmp.b   local_char(A4),D0
                beq.s   t_sear0         ;lokales Symbol
                tst.b   0(A2,D0.w)      ;erlaubtes Zeichen
                ble     synt_error      ;nein
t_sear0:        movea.l A0,A6           ;Anfang des Labels
                moveq   #0,D2
                move.b  D0,D2           ;erstes Zeichen schon nehmen
                addq.l  #1,A0
                moveq   #22,D1          ;maximale Länge-1
t_sear1:        move.b  (A0)+,D0
                rol.w   #4,D2           ;siehe Compilerbau S.535
                add.w   D0,D2           ;Checksum bilden
                tst.b   0(A2,D0.w)      ;erlaubtes Zeichen
                dbeq    D1,t_sear1
                bne.s   t_seare         ;Symbol zu lang
                subq.l  #1,A0
                sub.w   D0,D2           ;letztes Zeichen gehört nicht zur Checksum
                movea.l local_pointer(A4),A3
                move.w  D2,(A3)         ;Checksum als letzter Eintrag
                movea.l ass_adr(A4),A5  ;Start der localen Tabelle
t_sear2:        cmp.w   (A5)+,D2        ;Checksums vergleichen
                bne.s   t_sear2         ;ungleich
                cmpa.l  A3,A5
                bhi.s   t_sear3         ;Label muß in Tabelle eingetragen werden
                move.l  A5,D0
                sub.l   ass_adr(A4),D0
                subq.w  #2,D0           ;Indexnummer mal 2
                lsl.l   #4,D0
                movea.l label_base(A4),A1
                lea     0(A1,D0.l),A1   ;Zeiger auf zu testenen Eintrag
                moveq   #0,D1
                moveq   #0,D3
t_sear4:        addq.w  #1,D1
                move.b  8(A1,D1.w),D3
                beq.s   t_sear5
                cmp.b   0(A6,D1.w),D3
                beq.s   t_sear4
                bra.s   t_sear2         ;ungleich, Hilfstabelle weiter absuchen
t_sear5:        move.b  0(A6,D1.w),D3
                tst.b   0(A2,D3.w)      ;Zeichen erlaubt?
                bne.s   t_seare         ;ja
                cmpi.b  #':',(A0)
                bne.s   t_sear6
                addq.w  #1,A0
                cmpi.b  #':',(A0)
                bne.s   t_sear6
                addq.w  #1,A0
                ori.b   #$20,4(A1)      ;global-Flag setzen
t_sear6:        lsr.l   #5,D0           ;Indexnummer
                movem.l (SP)+,D1-D4/A2-A3/A5-A6
                rts
; t_sear9:cmp.w   #23,d1
;         blt.s   t_sear2
t_seare:        movem.l (SP)+,D1-D4/A2-A3/A5-A6
                movea.l D7,SP
                bra     dekl_error
t_sear3:        movea.l label_top(A4),A1
                addq.l  #8,A1
                moveq   #22,D1          ;Anzahl der Zeichen -1
                moveq   #0,D0
                move.b  (A6)+,D0        ;erstes Zeichen
                move.b  D0,(A1)+        ;übernehmen
                cmp.b   local_char(A4),D0
                bne.s   t_sear7         ;nein
                clr.b   -1(A1)          ;Kennung für lokale Symbole
t_sear7:        move.b  (A6)+,D0        ;Symbol in Tabelle eintragen
                move.b  D0,(A1)+
                tst.b   0(A2,D0.w)
                dbeq    D1,t_sear7
                bne.s   t_seare         ;Label zu lang
                clr.b   -(A1)
                movea.l label_top(A4),A1 ;Adresse
                move.w  label_top_ind(A4),D0 ;Index
                addi.l  #32,label_top(A4)
                addq.l  #2,local_pointer(A4)
                addq.w  #1,label_top_ind(A4)
                cmpi.b  #':',(A0)
                bne.s   t_sear8
                addq.l  #1,A0
                cmpi.b  #':',(A0)       ;2. Doppelpunkt
                bne.s   t_sear8         ;nein
                addq.l  #1,A0
                ori.b   #$20,4(A1)      ;global-Flag setzen
t_sear8:        movem.l (SP)+,D1-D4/A2-A3/A5-A6
                rts

t_search_label: tst.b   load_fl(A4)
                bmi     t_search2       ;ASCII-Load
                movem.l D1-D6/A2-A6,-(SP)
                moveq   #0,D3
                suba.l  A3,A3
                lea     allowed_chars(PC),A2
                move.w  label_top_ind(A4),D2
                movea.l label_base(A4),A1
                moveq   #0,D0
                moveq   #0,D1
                move.b  (A0),D1         ;erstes Zeichen
                cmp.b   local_char(A4),D1
                beq.s   lab_loop0       ;lokales Symbol
                tst.b   0(A2,D1.w)
                ble     synt_error      ;Zeichen nicht erlaubt
                move.b  D1,D0           ;Zeichen übertragen
lab_loop0:      movea.l A0,A6           ;Zeiger auf Text merken
                addq.l  #1,A0
                lea     spaced(A4),A5   ;Zeiger auf Buffer
                clr.l   (A5)+
                clr.l   (A5)+
                clr.l   (A5)+           ;Buffer löschen
                clr.l   (A5)+
                clr.l   (A5)+
                clr.l   (A5)
                lea     spaced(A4),A5
                move.b  D0,(A5)+        ;erstes Zeichen in Buffer
                moveq   #24,D1          ;max. Länge+1
lab_loop01:     subq.w  #1,D1           ;Zeichen zählen
                beq.s   lab_err2        ;Symbolname zu lang
                move.b  (A0)+,D0        ;Zeichen holen
                move.b  D0,(A5)+        ;und in Buffer
                tst.b   0(A2,D0.w)      ;Zeichen erlaubt?
                bne.s   lab_loop01      ;ja, nächstes Zeichen
                clr.b   -(A5)           ;letztes Zeichen wieder löschen
                subq.l  #1,A0
                tst.w   spaced(A4)
                beq.s   lab_error       ;verbietet '.' als lokales Symbol
                moveq   #0,D0
lab_loop2:      cmp.w   D2,D0           ;Ende der Tabelle erreicht?
                beq.s   lab_not_found   ;ja
                tst.b   31(A1)
                bmi.s   lab_ungleich    ;spezieller Eintrag (Formel,dc)
                beq.s   lab_loop        ;normaler Namenseintrag
                movea.l A1,A3           ;gelöschter Eintrag (Speicherleiche)
                move.w  D0,D4           ;Adresse und Index merken
                bra.s   lab_ungleich
lab_loop:       lea     spaced(A4),A5   ;Zeiger auf Buffer
                move.l  A1,D1           ;Register retten
                addq.l  #8,A1           ;zeigt auf Symbolnamen
                moveq   #5,D3           ;5*4=24 Zeichen
lab_loop1:      cmpm.l  (A1)+,(A5)+     ;4 Zeichen vergleichen
                dbne    D3,lab_loop1
                movea.l D1,A1           ;Adressregister wiederherstellen
                bne.s   lab_ungleich    ;nicht gleich
lab_t_end:      andi.b  #$DF,4(A1)      ;global-Flag löschen
                cmpi.b  #':',(A0)
                bne.s   lab_leave       ;~keine Symboldefinition
                addq.l  #1,A0
                cmpi.b  #':',(A0)       ;2. Doppelpunkt?
                bne.s   lab_leave       ;nein
                addq.l  #1,A0
                ori.b   #$20,4(A1)      ;global-Flag setzen
lab_leave:      movem.l (SP)+,D1-D6/A2-A6
                rts
lab_err2:       movem.l (SP)+,D1-D6/A2-A6
                moveq   #-6,D0          ;Symbolname zu lang
                movea.l D7,SP
                bra     operand_err
lab_error:      movem.l (SP)+,D1-D6/A2-A6
                movea.l D7,SP
                bra     dekl_error
lab_ungleich:   lea     32(A1),A1       ;auf nächsten Eintrag
                addq.w  #1,D0           ;Index erhöhen
                bra.s   lab_loop2
lab_not_found:  move.l  A3,D1           ;wurde freier Platz gefunden?
                beq.s   no_free_space   ;nein
                movea.l A3,A1           ;Adresse des Eintrags
                move.w  D4,D0           ;Index des Eintrags
                subq.w  #1,label_top_ind(A4)
                subi.l  #32,label_top(A4)
no_free_space:  move.l  A1,D1           ;Register retten
                lea     spaced(A4),A5   ;Zeiger auf Namen
                clr.l   (A1)+           ;Wert löschen
                clr.l   (A1)+           ;Flags löschen
                move.l  (A5)+,(A1)+     ;Symbolnamen kopieren
                move.l  (A5)+,(A1)+
                move.l  (A5)+,(A1)+
                move.l  (A5)+,(A1)+
                move.l  (A5)+,(A1)+
                move.l  (A5)+,(A1)+
                movea.l D1,A1           ;Register zurück
                addq.w  #1,label_top_ind(A4)
                addi.l  #32,label_top(A4)
                move.l  A0,-(SP)
                tst.b   bell_flag(A4)   ;Pling bei neuem Label?
                bne.s   lab_skip1       ;Nein! =>
                bsr     c_bell          ;Pling !!
lab_skip1:      movea.l (SP)+,A0
                bra     lab_t_end

************************************************************************
* Remark kompressen                                                    *
************************************************************************
compress_remark:move.l  A2,-(SP)        ;A2 retten
                lea     zreserve(A4),A1

                move.l  A0,-(SP)
compress5:      tst.b   (A0)+
                bne.s   compress5       ;Nullbyte finden
                subq.l  #1,A0           ;ein Zeichen zurück
compress4:      cmpi.b  #' ',-(A0)
                beq.s   compress4       ;Spaces am Ende eleminieren
                clr.b   1(A0)
                movea.l (SP)+,A0

compress_loop:  move.b  (A0)+,D1        ;Zeichen holen
                beq.s   compress_end
                cmp.b   (A0),D1         ;nächstes Zeichen schon ungleich?
                bne.s   compress7       ;dann wegschreiben (just for speed)
                movea.l A0,A2           ;Adresse merken
                moveq   #-1,D0
compress_loop2: addq.w  #1,D0           ;die gleichen Folgezeichen zählen
                cmp.b   (A0)+,D1
                beq.s   compress_loop2
                subq.l  #1,A0           ;Pointer auf das ungleiche Zeichen zurück
                cmp.b   #1,D1           ;Das Packzeichen lohnt sich immer!
                beq.s   compress2       ;Packen
                subq.w  #1,D0
                cmp.w   #2,D0           ;Weniger als 3 gleiche Zeichen lohnen nicht!
                bls.s   compress1
compress2:      move.b  #1,(A1)+        ;Packzeichen
                move.b  D0,(A1)+        ;Anzahl
                move.b  D1,(A1)+        ;Zeichencode
                bra.s   compress_loop
compress1:      movea.l A2,A0           ;gemerkte Adresse zurück
compress7:      cmp.b   #1,D1           ;Packzeichen
                beq.s   compress3       ;das muß leider "gepackt" werden
                move.b  D1,(A1)+        ;Zeichen ist nicht zu packen
                bra.s   compress_loop   ;Weiter geht's
compress3:      moveq   #1,D0
                move.b  D0,(A1)+        ;Packzeichen
                clr.b   (A1)+           ;Anzahl=1
                move.b  D0,(A1)+        ;Zeichencode=Packzeichen
                bra.s   compress_loop

compress_end:   clr.b   (A1)+
                clr.b   (A1)+
                move.l  A1,D0
                lea     zreserve(A4),A1
                sub.l   A1,D0           ;Länge des Remarks
                andi.w  #$FFFE,D0       ;ev. auf gerade Zahl abrunden
                move.w  D0,8(A3)
                move.l  A1,10(A3)
                movea.l (SP)+,A2
                rts

************************************************************************
* Spaces ab A0 überlesen                                               *
************************************************************************
cut_space:      cmpi.b  #' ',(A0)+
                beq.s   cut_space
                cmpi.b  #9,-1(A0)       ;Tabulator
                beq.s   cut_space
                subq.w  #1,A0
                rts

clear_buffer:   movem.l D0/A0,-(SP)
                lea     zeingabe(A4),A0 ;Zeiger auf Eingabestring
                move.l  #$012000,(A0)+
                clr.w   (A0)+
                move.w  #38,D0
zloopy:         clr.l   (A0)+
                dbra    D0,zloopy
                movem.l (SP)+,D0/A0
return:         rts
                ENDPART

************************************************************************
* Hexausgabe in D1                                                     *
************************************************************************
                >PART 'hex?out'
hexaout:        swap    D1              ;Adresse in D1 ausgeben
                bsr.s   hexbout
                swap    D1
                bra.s   hexwout
hexlout:        swap    D1              ;Longword in D1 ausgeben
                bsr.s   hexwout
                swap    D1
hexwout:        rol.w   #8,D1           ;Word in D1 ausgeben
                bsr.s   hexbout
                rol.w   #8,D1
hexbout:        movem.l D0-D2/A6,-(SP)  ;Byte in D1 ausgeben
                lea     hex2tab(PC),A6
                tst.w   small(A4)
                bne.s   hexbbut
                lea     hex_tab(PC),A6
hexbbut:        moveq   #0,D0
                move.w  D1,D2
                rol.b   #4,D1
                andi.w  #$0F,D1
                move.b  0(A6,D1.w),D0
                bsr     chrout
                andi.w  #$0F,D2
                move.b  0(A6,D2.w),D0
                bsr     chrout
                movem.l (SP)+,D0-D2/A6
                rts
hex_tab:        DC.B '0123456789ABCDEF'
hex2tab:        DC.B '0123456789abcdef'
                ENDPART

************************************************************************
* Der interne Exception-Handler des Assemblers                         *
************************************************************************
                >PART 'exception'
exception:      DS.W 1
                DC.L 'XBRA'
                DC.L 'TASS'
                DS.L 1
exception2:     move.w  #2,exception
                bra.s   except1

                DC.L 'XBRA'
                DC.L 'TASS'
                DS.L 1
exception3:     move.w  #3,exception
                bra.s   except1

                DC.L 'XBRA'
                DC.L 'TASS'
                DS.L 1
exception4:     move.w  #4,exception
                bra.s   except1

                DC.L 'XBRA'
                DC.L 'TASS'
                DS.L 1
exception6:     move.w  #6,exception
                bra.s   except1

                DC.L 'XBRA'
                DC.L 'TASS'
                DS.L 1
exception7:     move.w  #7,exception
                bra.s   except1

                DC.L 'XBRA'
                DC.L 'TASS'
                DS.L 1
exception8:     move.w  #8,exception
except1:        move    #$2700,SR
                move.l  A4,-(SP)
                lea     varbase,A4
                movem.l D0-A6,regs(A4)  ;alle Register retten
                move.l  (SP)+,regs+48(A4) ;nun A4 retten
                move.w  exception(PC),D7 ;Exception-Number
                move.w  (SP)+,_xsr(A4)
                move.l  (SP)+,_pc(A4)
                move.l  SP,_ssp(A4)     ;SSP merken
                move    USP,A0
                move.l  A0,_xusp(A4)    ;und auch den USP
                btst    #5,_xsr(A4)     ;User-Mode an?
                beq.s   excep50
                movea.l SP,A0           ;Nein, Supervisormode
excep50:        move.l  A0,rega7(A4)    ;A7 setzen

                movea.l ass_stack(A4),SP ;eigenen Stack wiederherstellen

;Die wichtigen Vektoren wieder einsetzen
                lea     mfp_irq(PC),A2
                moveq   #6,D0
                bsr     install_irq
                lea     hz200_irq(PC),A2
                moveq   #5,D0
                bsr     install_irq
                bsr     clr_keybuff
                andi.b  #$10,kbshift(A4)
                bclr    #5,$FFFFFA11.w  ;200Hz-Timer wieder freigeben
                bclr    #6,$FFFFFA11.w  ;Keyboard wieder freigeben
                st      vbl_time_flag(A4)
                lea     my_vbl(PC),A0
                move.l  A0,$70.w
                lea     etv_critic(PC),A0
                move.l  A0,$0404.w
                move    #$2300,SR

                lea     knall_rsc(PC),A1
                move.w  #1,8(A1)        ;Hintergrund löschen

                move.w  D7,D1
                lea     knall_xx(PC),A0
                bsr     _hexbout        ;Bombenanzahl einsetzen
                lea     bomben(PC),A0
                moveq   #7,D0
                moveq   #8,D2
excep51:        move.w  D2,(A0)         ;Alle Bomben setzen
                lea     10(A0),A0
                addq.w  #2,D2
                dbra    D0,excep51
                cmp.w   #8,D7
                bls.s   excep58
                moveq   #1,D7
excep58:        mulu    #10,D7
                lea     bomben(PC),A0
                move.w  #-1,0(A0,D7.w)  ;Ende der RSC setzen => Anzahl der Bomben
                lea     regs(A4),A1
                lea     knall_2-1(PC),A0
                moveq   #3,D6
excep52:        moveq   #3,D7
                addq.l  #4,A0
excep53:        move.l  (A1)+,D1        ;Die Register ausgeben
                bsr     _hexlout
                dbra    D7,excep53
                dbra    D6,excep52

                lea     knall_6+3(PC),A0
                move.l  _pc(A4),D1
                bsr     _hexlout
                addq.l  #6,A0
                move.w  _xsr(A4),D1
                bsr     _hexwout
                addq.l  #6,A0
                move.l  _xusp(A4),D1
                bsr     _hexlout
                addq.l  #4,A0
                move.l  basepage(A4),D1
                bsr     _hexlout
                addq.l  #6,A0
                move.w  #version,D1
                bsr     _hexwout
                addq.l  #6,A0
                move.l  _ssp(A4),D1
                bsr     _hexlout

                lea     knall_22+3(PC),A0
                moveq   #31,D0
excep54:        move.b  #'?',(A0)+      ;Stackbereich löschen
                dbra    D0,excep54

                move.l  rega7(A4),D1
                btst    #0,D1
                bne.s   excep56
                cmp.l   #$400000,D1
                bhs.s   excep56

                movea.l D1,A1
                lea     knall_22+3(PC),A0
                moveq   #3,D7
excep55:        move.l  (A1)+,D1
                bsr     _hexlout
                dbra    D7,excep55
excep56:        moveq   #0,D0
                bsr     _graf_mouse     ;Maus auf Pfeil
                lea     knall_rsc(PC),A0
                bsr     _form_do        ;Rückgabe: 1=ENDE, 2=ZURÜCK
                ori.b   #$80,8(A0)      ;Redraw ignorieren
                tst.w   D0
                bmi.s   excep56         ;UNDO wird ignoriert
                subq.w  #2,D0
                bmi.s   excep57         ;Programm verlassen
                bne.s   exceppx         ;Drucken
                moveq   #0,D6
                move.w  D6,D0
                bsr     calc_pointer
                clr.w   top_line(A4)    ;alles auf Zeile 0
                movem.l A3/A5-A6,top_ptr(A4)
                clr.w   scr_z(A4)
                jsr     redraw_all
                jmp     main_loop
excep57:        jmp     do_quit

exceppx:        btst    #0,$FFFFFA01.w  ;Busy-Flag des Druckers
                bne.s   excep56         ;kein Drucker da! ^^^
                moveq   #$01,D0
                bsr     prn_spezchar    ;CR ausgeben
                lea     knall_yy(PC),A0
                bsr.s   excep90
                lea     knall_2(PC),A0
                bsr.s   excep90
                lea     knall_3(PC),A0
                bsr.s   excep90
                lea     knall_4(PC),A0
                bsr.s   excep90
                lea     knall_5(PC),A0
                bsr.s   excep90
                lea     knall_22(PC),A0
                bsr.s   excep90
                lea     knall_6(PC),A0
                bsr.s   excep90
                lea     knall_17(PC),A0
                bsr.s   excep90
                bra     excep56

excep90:        move.b  (A0)+,D0        ;String ab A0 zum Drucker
                beq.s   excep91
                bsr     prn_char
                bra.s   excep90
excep91:        moveq   #$01,D0
                bra     prn_spezchar    ;CR ausgeben

knall_rsc:      DC.W 0,0,37,19,1
                DC.W 27,17
                DC.L knall_0
                DC.W $24
                DC.W 15,17
                DC.L knall_1
                DC.W $26
                DC.W 2,17
                DC.L knall_21
                DC.W $24
                DC.W 1,5
                DC.L knall_2
                DC.W 8
                DC.W 1,6
                DC.L knall_3
                DC.W 8
                DC.W 1,7
                DC.L knall_4
                DC.W 8
                DC.W 1,8
                DC.L knall_5
                DC.W 8
                DC.W 1,10
                DC.L knall_6
                DC.W 8
                DC.W 1,3
                DC.L knall_7
                DC.W 8
                DC.W 4,1
                DC.L knall_8
                DC.W 8
                DC.W 1,11
                DC.L knall_17
                DC.W 8
                DC.W 1,13
                DC.L knall_18
                DC.W 8
                DC.W 1,14
                DC.L knall_19
                DC.W 8
                DC.W 1,15
                DC.L knall_20
                DC.W 8
                DC.W 1,9
                DC.L knall_22
                DC.W 8
bomben:         DC.W 8,3
                DC.L knall_9
                DC.W $1183
                DC.W 10,3
                DC.L knall_9
                DC.W $1183
                DC.W 12,3
                DC.L knall_9
                DC.W $1183
                DC.W 14,3
                DC.L knall_9
                DC.W $1183
                DC.W 16,3
                DC.L knall_9
                DC.W $1183
                DC.W 18,3
                DC.L knall_9
                DC.W $1183
                DC.W 20,3
                DC.L knall_9
                DC.W $1183
                DC.W 22,3
                DC.L knall_9
                DC.W $1183
                DC.W -1

knall_2:        DC.B 'D0:                                ',0
knall_3:        DC.B 'D4:                                ',0
knall_4:        DC.B 'A0:                                ',0
knall_5:        DC.B 'A4:                                ',0
knall_22:       DC.B 'SK:                                ',0
knall_6:        DC.B 'PC:           SR:      USP:        ',0
knall_17:       DC.B 'BP:          VER:      SSP:        ',0
                SWITCH sprache
                CASE 0
knall_8:        DC.B 'Ein kleines internes Problem',0
knall_7:        DC.B 'Bomben',0
knall_18:       DC.B 'Bitte notieren Sie sich die obigen',0
knall_19:       DC.B 'Werte und setzen Sie sich mit uns',0
knall_20:       DC.B 'in Verbindung.',0
knall_0:        DC.B '  ENDE  ',0
knall_1:        DC.B ' ZURÜCK ',0
knall_21:       DC.B ' DRUCKEN ',0
knall_yy:       DC.B 'Bomben:'
                CASE 1
knall_8:        DC.B 'A little internal problem',0
knall_7:        DC.B 'Bombs',0
knall_18:       DC.B 'Please notate the values above',0
knall_19:       DC.B 'and contact us.',0
knall_20:       DC.B 0
knall_0:        DC.B ' EXIT ',0
knall_1:        DC.B ' BACK ',0
knall_21:       DC.B ' PRINT ',0
knall_yy:       DC.B 'Bombs :'
                ENDS
knall_xx:       DC.B '  ',0
                EVEN
knall_9:        DC.L $0C005200,$01009080,$23E003E0,$0FF81FFC,$1BFC3FFE
                DC.L $3FDE1FDC,$1FBC0FF8,$07F001C0
_hexlout:       swap    D1              ;Longword in D1 ausgeben
                bsr.s   _hexwout
                swap    D1
_hexwout:       rol.w   #8,D1           ;Word in D1 ausgeben
                bsr.s   _hexbout
                rol.w   #8,D1
_hexbout:       movem.l D0-D2,-(SP)     ;Byte in D1 ausgeben
                moveq   #0,D0
                move.w  D1,D2
                rol.b   #4,D1
                and.w   #$0F,D1
                move.b  _hex_tab(PC,D1.w),(A0)+
                and.w   #$0F,D2
                move.b  _hex_tab(PC,D2.w),(A0)+
                movem.l (SP)+,D0-D2
                rts
_hex_tab:       DC.B '0123456789ABCDEF'
                ENDPART

************************************************************************
* Menüleiste (für ACCs) anzeigen                                       *
************************************************************************
                >PART 's_accs'
s_accs:         movem.l D0-A6,-(SP)
                bsr.s   f_menu
                movem.l (SP)+,D0-A6
                jmp     main_loop
f_menu:         bsr     org_driver

                lea     rsc_base(PC),A6 ;Anfangsadresse des Menübaumes
                tas.b   (A6)            ;Menübaum schon fix?
                bne.s   do_aes2         ;Ja! =>

                moveq   #13,D7          ;14 Objekte im Baum
do_aes1:        move.w  D7,intin(A4)    ;die Objektnummer
                move.l  A6,addrin(A4)   ;Adresse des Baumes
                move.l  #$72010101,D0
                bsr     aes             ;rsrc_obfix()
                dbra    D7,do_aes1

do_aes2:        move.l  #$0A000100,D0
                bsr     aes             ;appl_init()

                move.w  #1,intin(A4)
                move.l  #$6B010100,D0
                bsr     aes             ;wind_update(0)

                bsr     waitaes

                clr.w   intin(A4)
                move.l  #$4E010101,D0
                bsr     aes             ;graf_mouse(Arrow)

                moveq   #1,D0
                bsr     _menu_bar       ;Menüleiste anzeigen

                move.w  #14,intin(A4)
                clr.l   intin+2(A4)
                move.l  #$69060100,D0
                bsr     aes             ;wind_set(olddesk)

                moveq   #5,D0
                move.l  D0,intin(A4)
                move.l  #$68020500,D0
                bsr     aes             ;wind_get()

                move.w  #3,intin(A4)
                move.l  intout+2(A4),intin+10(A4)
                move.l  intout+6(A4),intin+14(A4)
                move.l  #$33090100,D0
                bsr     aes             ;form_dial() - Bildschirm neu zeichnen

                clr.w   intin(A4)
                move.l  #$6B010100,D0
                bsr     aes             ;wind_update(0)

do_aes3:        lea     evnt_buff(A4),A5
                move.l  A5,addrin(A4)
                lea     intin(A4),A0
                move.w  #%10001,(A0)    ;MU_MESAG && MU_KEYBD
                move.l  #$19100701,D0
                bsr     aes             ;evnt_multi()
                move.w  intout(A4),D0
                btst    #0,D0           ;MU_KEYBD?
                beq.s   do_aes30        ;Nein! =>
                cmpi.w  #$6100,intout+10(A4) ;UNDO?
                beq.s   do_aes4         ;Ja! => raus
                cmpi.w  #$011B,intout+10(A4) ;ESC?
                beq.s   do_aes4         ;Ja! => raus
do_aes30:       btst    #4,D0           ;MU_MESAG?
                beq.s   do_aes3         ;Nein! =>
                cmpi.w  #10,(A5)        ;MENU_SELECTED?
                bne.s   do_aes3
                cmpi.w  #6,8(A5)        ;Objekt-Index des Menüeintrags holen
                bne.s   do_aes3         ;Nicht der erste?

do_aes4:        moveq   #10,D0
                move.l  D0,intin(A4)
                move.l  #$68020500,D0
                bsr.s   aes             ;wind_get(0,10)
                tst.w   intout+2(A4)
                bne.s   do_aes4

                move.l  #$030001,intin(A4) ;revers aus
                move.l  A6,addrin(A4)
                move.l  #$21020101,D0
                bsr.s   aes             ;menu_tnormal()

                moveq   #0,D0
                bsr.s   _menu_bar       ;Menüleiste ausschalten

                move.l  #$13000101,D0
                bsr.s   aes             ;appl_exit()

                lea     8.w,A0
                lea     save_data(A4),A1
                movea.l A1,A2
                move.w  #323,D1
initcop2:       move.l  (A0)+,(A1)+     ;$8-$517 erneut retten
                dbra    D1,initcop2

                jmp     switch_my_drv

************************************************************************
* menu_bar(d0)                                                         *
************************************************************************
_menu_bar:      move.l  A6,addrin(A4)
                move.w  D0,intin(A4)
                move.l  #menu_bar,D0
                ENDPART
                >PART 'aes'
************************************************************************
* Mein eigener kleiner AES-Aufruf                                      *
* D0=Die ersten 4 Einträge im int_in-Array (Bytebreite!)               *
************************************************************************
aes:            movem.l D1-A6,-(SP)
                lea     contrl(A4),A0
                clr.l   (A0)
                clr.l   4(A0)           ;int_in-Array löschen
                movep.l D0,1(A0)        ;und die neuen Daten eintragen
                lea     aes_pb(PC),A0
                move.l  A0,D1
                move.w  #200,D0
                trap    #2              ;AES aufrufen
                moveq   #0,D0
                move.w  intout(A4),D0   ;int_out[0]
                movem.l (SP)+,D1-A6
                rts
                ENDPART
                >PART 'vdi'
************************************************************************
* Und das gleiche nochmal für die VDI-Funktionen                       *
* D0 = Die Eingabeparameter                                            *
*      Bit 24-31 = Opcode der Funktion                                 *
*      Bit 16-23 = Länge des Intin-Arrays                              *
*      Bit 8-15  = Identifikationsnummer für Unter-Opcodes             *
*      Bit 0-7   = Anzahl der Einträge in ptsin                        *
* Die Gerätekennung wird der Variable "gr_handle" entnommen.           *
************************************************************************
vdi:            movem.l D1-A6,-(SP)
                lea     contrl+2(A4),A0
                clr.w   (A0)+           ;alle Parameter löschen
                clr.l   (A0)+
                clr.w   (A0)
                move.l  D0,-(SP)
                tst.b   (SP)            ;kein Opcode vorhanden? => Kurzformat
                addq.l  #4,SP
                bne.s   vdi1
                move.b  D0,1-8(A0)      ;Funktionsnummer in den Bits 0-7
                bra.s   vdi2            ;alle anderen Parameter sind 0!
vdi1:           move.b  D0,3-8(A0)      ;Anzahl der Einträge in ptsin
                lsr.w   #8,D0
                move.w  D0,10-8(A0)     ;Unter-Opcode
                swap    D0
                move.b  D0,7-8(A0)      ;Anzahl der Einträge in intin
                lsr.w   #8,D0
                move.w  D0,0-8(A0)      ;Funktionsnummer
vdi2:           move.w  vdi_handle(A4),12-8(A0) ;VDI-Handle
                lea     vdi_pb(PC),A0
                move.l  A0,D1
                moveq   #115,D0
                trap    #2
                moveq   #0,D0
                move.w  intout(A4),D0   ;int_out[0]
                movem.l (SP)+,D1-A6
                rts
                ENDPART
                >PART 'waitaes'
************************************************************************
* Kleine Pause für das AES                                             *
************************************************************************
waitaes:        move.l  #$230001,intin(A4)
                move.l  #$010001,intin+4(A4)
                move.l  #$640000,intin+28(A4)
                move.l  #$19100701,D0
                bsr     aes             ;evnt_multi(Keyboard, Maustasten & Timer)
                moveq   #$20,D0
                sub.w   intout(A4),D0
                bne.s   waitaes         ;sonst noch warten
waitae1:        move.l  #$4F000500,D0
                bsr     aes             ;graf_mkstate()
                tst.l   intout+6(A4)
                bne.s   waitae1         ;warten, bis Maustasten & Keyboard ruhig
                rts
                ENDPART
                >PART 'rsc_base'
************************************************************************
* Nun ein paar wichtige Daten                                          *
************************************************************************
rsc_base:       DC.W $FF,1,4,$19,0,0,0,0,0,0,$50,$19 ;Objekt 0
                DC.W 4,2,2,$14,0,0,0,$1100,0,0,$50,$0201 ;Objekt 1
                DC.W 1,3,3,$19,0,0,0,0,2,0,4,$0301 ;Objekt 2
                DC.W 2,-1,-1,$20,0,0 ;Objekt 3
                DC.L men_tx1
                DC.W 0,0,4,$0301
                DC.W 0,5,5,$19,0,0,0,0,0,$0301,$50,$13 ;Objekt 4
                DC.W 4,6,13,$14,0,0,$FF,$1100,2,0,$19,8 ;Objekt 5
                DC.W 7,-1,-1,$1C,0,0 ;Objekt 6
                DC.L men_tx2
                DC.W 0,0,$19,1
                DC.W 8,-1,-1,$1C,0,8 ;Objekt 7
                DC.L men_tx3
                DC.W 0,1,$19,1
                DC.W 9,-1,-1,$1C,0,0 ;Objekt 8
                DC.L men_tx1
                DC.W 0,2,$19,1
                DC.W 10,-1,-1,$1C,0,0 ;Objekt 9
                DC.L men_tx1
                DC.W 0,3,$19,1
                DC.W 11,-1,-1,$1C,0,0 ;Objekt 10
                DC.L men_tx1
                DC.W 0,4,$19,1
                DC.W 12,-1,-1,$1C,0,0 ;Objekt 11
                DC.L men_tx1
                DC.W 0,5,$19,1
                DC.W 13,-1,-1,$1C,0,0 ;Objekt 12
                DC.L men_tx1
                DC.W 0,6,$19,1
                DC.W 5,-1,-1,$1C,$20,0 ;Objekt 13
                DC.L men_tx1
                DC.W 0,7,$19,1

men_tx1:        DC.B ' ',0
men_tx2:        SWITCH sprache
                CASE 0
                DC.B '  zurück zum Assembler',0
                CASE 1
                DC.B '  back to the assembler',0
                ENDS
men_tx3:        DC.B '-------------------------',0
                EVEN
aes_pb:         DC.L contrl
                DC.L global
                DC.L intin
                DC.L intout
                DC.L addrin
                DC.L addrout
vdi_pb:         DC.L contrl     ;Der VDI-Parameterblock
                DC.L intin
                DC.L ptsin
                DC.L intout
                DC.L ptsout
                ENDPART

************************************************************************
* Eigener etv_critic-Handler                                           *
************************************************************************
                >PART 'etv_critic'
etv_critic:     move.l  4(SP),D0
                movem.l D1-A6,-(SP)
                lea     varbase,A4
                move.l  D0,D1
                moveq   #0,D0
                bsr     _graf_mouse     ;Mausform als Pfeil
                move.l  D1,D0
                lea     etv_tx3(PC),A0
                lea     etv_txt(PC),A1  ;ab hier werden die Texte eingesetzt
                moveq   #3,D1           ;4 Zeilen
etv_cr0:        move.l  A0,(A1)+        ;Leertext einsetzen
                addq.l  #6,A1
                dbra    D1,etv_cr0
                moveq   #'A',D1
                add.w   D0,D1           ;Laufwerk in D1
                swap    D0              ;Fehlernummer in D0
                lea     etv_tab(PC),A0
etv_cr2:        move.b  (A0)+,D2
                beq.s   etv_cr9         ;Tabellenende => Default nehmen
                bmi.s   etv_cr4         ;Wert negativ => Fehlernummer
etv_cr3:        cmpi.b  #-1,(A0)+       ;bis -1 überlesen
                bne.s   etv_cr3
                bra.s   etv_cr2         ;und weitersuchen
etv_cr9:        lea     etv_dtab(PC),A0
                bra.s   etv_cr5
etv_cr4:        cmp.b   D0,D2           ;Fehlernummer gefunden?
                bne.s   etv_cr2         ;Nein => weitersuchen
etv_cr5:        move.b  (A0)+,D3        ;Bis zum positiven Wert alles lesen
                bmi.s   etv_cr5
                move.b  D3,etv_siz+1    ;Breite des Alerts einsetzen
                lea     etv_txt(PC),A1  ;ab hier werden die Texte eingesetzt
                movea.l A1,A2           ;im Notfall zerstört durch Laufwerk
etv_cr6:        tst.b   (A0)            ;1.Zeichen testen
                bmi.s   etv_cr8         ;Alles zuende, wenn negativ
                move.l  A0,(A1)+        ;Zeilenadr einsetzen
                addq.l  #6,A1
etv_cr7:        move.b  (A0)+,D3
                beq.s   etv_cr6         ;Zeilenende?
                cmp.b   #'#',D3         ;Kennung für's Laufwerk
                bne.s   etv_cr7
                lea     -1(A0),A2       ;Adresse der Laufwerkskennung merken
                move.b  D1,(A2)         ;Laufwerk einsetzen
                bra.s   etv_cr7
etv_cr8:        move.w  etv_siz(PC),D3
                sub.w   #11,D3
                move.w  D3,etv_but
                movem.l D0/A2,-(SP)
                lea     etv_critic_rsc(PC),A0
                bsr     _form_do        ;Alert ausgeben
                move.w  D0,D1
                movem.l (SP)+,D0/A2
                ext.w   D0
                ext.l   D0
                moveq   #$01,D2
                swap    D2              ;Flag für "Nochmal"
                cmp.w   #1,D1           ;Abbruch?
                beq.s   etv_c10         ;ja =>
                move.l  D2,D0           ;Sonst nochmal probieren
etv_c10:        cmp.w   #-17,D0         ;Disk gewechselt?
                bne.s   etv_c11
                move.l  D2,D0           ;Dann stets nochmal probieren
etv_c11:        move.b  #'#',(A2)       ;Laufwerkskennung löschen
                movem.l (SP)+,D1-A6
                rts

etv_critic_rsc: DC.W 0,0
etv_siz:        DC.W 18
                DC.W 8,1
                DC.W 1,1
etv_txt:        DC.L 0
                DC.W 8
                DC.W 1,2
                DC.L 0
                DC.W 8
                DC.W 1,3
                DC.L 0
                DC.W 8
                DC.W 1,4
                DC.L 0
                DC.W 8

                DC.W 2,6
                DC.L abbruch_button
                DC.W $24
etv_but:        DC.W 10,6
                DC.L nochmal_button
                DC.W $26        ;Default
                DC.W -1

etv_tab:        DC.B -1,-9,-15
etv_dtab:       DC.B 31
                SWITCH sprache
                CASE 0
                DC.B 'Ausgabegerät antwortet nicht!',0
                DC.B 'Ist es angeschlossen und ein-',0
                DC.B 'geschaltet?',0,-1
                DC.B -2,-3,-5,-6
                DC.B 28
                DC.B 'Floppy #: antwortet nicht.',0
                DC.B 'Bitte überprüfen und eine',0
                DC.B 'Disk einlegen.',0,-1
                DC.B -4,-7,-8,-10,-11,-12,-16
                DC.B 29
                DC.B 'Daten auf Disk #: defekt?',0
                DC.B 'Prüfen Sie die Disk und die',0
                DC.B 'Verbindungskabel.',0,-1
                DC.B -13
                DC.B 27
                DC.B 'Disk in Floppy #: ist',0
                DC.B 'schreibgeschützt. Vor dem',0
                DC.B 'nächsten Versuch',0
                DC.B 'Schreibschutz entfernen.',0,-1
                DC.B -14
                DC.B 29
                DC.B 'Die Anwendung kann die Disk',0
                DC.B 'in Floppy #: nicht lesen',0,-1
                DC.B -17
                DC.B 27
                DC.B 'Bitte Disk # in Floppy A:',0
                DC.B 'einlegen.',0,-1
                DC.B 0
                CASE 1
                DC.B 'Ausgabegerät antwortet nicht!',0
                DC.B 'Ist es angeschlossen und ein-',0
                DC.B 'geschaltet?',0,-1
                DC.B -2,-3,-5,-6
                DC.B 28
                DC.B 'Floppy #: antwortet nicht.',0
                DC.B 'Bitte überprüfen und eine',0
                DC.B 'Disk einlegen.',0,-1
                DC.B -4,-7,-8,-10,-11,-12,-16
                DC.B 29
                DC.B 'Daten auf Disk #: defekt?',0
                DC.B 'Prüfen Sie die Disk und die',0
                DC.B 'Verbindungskabel.',0,-1
                DC.B -13
                DC.B 27
                DC.B 'Disk in Floppy #: ist',0
                DC.B 'schreibgeschützt. Vor dem',0
                DC.B 'nächsten Versuch',0
                DC.B 'Schreibschutz entfernen.',0,-1
                DC.B -14
                DC.B 29
                DC.B 'Die Anwendung kann die Disk',0
                DC.B 'in Floppy #: nicht lesen',0,-1
                DC.B -17
                DC.B 27
                DC.B 'Please insert Disk # in',0
                DC.B 'Floppy A:.',0,-1
                DC.B 0
                ENDS
etv_tx3:        DC.B ' ',0
                EVEN
                ENDPART

************************************************************************
* Media-Change auf dem aktuellen Laufwerk nötig? Dann ausführen        *
************************************************************************
                >PART 'do_mediach'
do_mediach_d0:  movem.l D0-D6/A0-A2,-(SP) ;Media-Change auf Laufwerk D0
                bra.s   do_mediach1
do_mediach:     movem.l D0-D6/A0-A2,-(SP)
                move.w  #$19,-(SP)
                bsr     do_trap_1       ;Dgetdrv()
                addq.l  #2,SP
do_mediach1:    move.w  D0,a_mediach_drv
                move.w  D0,D6           ;Laufwerk D0
                addq.w  #1,D0
                move.w  D0,-(SP)        ;Laufwerk D0+1
                pea     a_mediach_buf(PC)
                move.w  #$47,-(SP)
                bsr     do_trap_1       ;Dgetpath()
                addq.l  #8,SP
                lea     a_mediach_buf(PC),A0
do_mediach2:    tst.b   (A0)+           ;Ende des Pfades suchen
                bne.s   do_mediach2
                clr.b   (A0)
                move.b  #'\',-(A0)      ;und den Pfad abschlie·en
                move.w  D6,-(SP)
                move.w  #7,-(SP)
                trap    #13             ;Getbpb()
                addq.l  #4,SP
                tst.l   D0              ;keinen BPB gefunden?
                ble.s   do_mediach7     ;dann Media-Change ausführen =>
                moveq   #9,D3           ;Anzahl der Sektoren
                moveq   #0,D4           ;bei Sektor 0 anfangen
                moveq   #0,D5           ;Prüfsumme über die Sektoren
                lea     sektor_buf(A4),A0
                moveq   #127,D0
do_mediach3:    clr.l   (A0)+           ;Sektor-Buffer löschen
                dbra    D0,do_mediach3
do_mediach4:    move.w  D6,-(SP)        ;Laufwerk
                move.w  D4,-(SP)        ;Sektornummer
                move.w  #1,-(SP)        ;einen Sektor
                pea     sektor_buf(A4)  ;Bufferadresse
                clr.w   -(SP)           ;Lesen mit Media-Test
                move.w  #4,-(SP)        ;Rwabs()
                trap    #13
                lea     14(SP),SP
                tst.w   D4              ;der Bootsektor?
                beq.s   do_mediach5     ;Ja! => kein Fehlertest (Winz-Ramdisk)
                tst.l   D0              ;ein Fehler?
                bmi.s   do_mediach7     ;Ja! => Sofort einen Media-Change
do_mediach5:    lea     sektor_buf(A4),A0
                moveq   #127,D0
do_mediach6:    add.l   (A0)+,D5        ;Prüfsumme über den Sektor
                rol.l   #2,D5
                dbra    D0,do_mediach6
                addq.w  #1,D4           ;nächste Sektornummer
                dbra    D3,do_mediach4  ;alle Sektoren durch? Nein! => weiter
                move.w  a_mediach_drv(PC),D0 ;das Laufwerk zurückholen
                lsl.w   #2,D0           ;Laufwerk mal 4
                lea     drv_chk_table(A4),A0
                cmp.l   0(A0,D0.w),D5   ;Prüfsumme noch gleich?
                beq.s   do_mediach9     ;Ja! => kein Media-Change => raus
                move.l  D5,0(A0,D0.w)   ;neue Prüfsumme merken
do_mediach7:    moveq   #'A',D1
                add.w   a_mediach_drv(PC),D1 ;das Laufwerk
                move.b  D1,do_mediach16
                move.l  $0472.w,a_mediach_bpb
                move.l  $047E.w,a_mediach_med
                move.l  $0476.w,a_mediach_rw
                move.l  #do_mediach10,$0472.w
                move.l  #do_mediach12,$047E.w
                move.l  #do_mediach14,$0476.w
                clr.w   -(SP)
                pea     do_mediach16(PC)
                move.w  #$3D,-(SP)
                trap    #1              ;Fopen()
                addq.w  #8,SP
                tst.l   D0
                bmi.s   do_mediach8
                move.w  D0,-(SP)
                move.w  #$3E,-(SP)
                trap    #1              ;Fclose()
                addq.w  #4,SP
do_mediach8:    cmpi.l  #do_mediach10,$0472.w
                bne.s   do_mediach9
                move.l  a_mediach_bpb(PC),$0472.w
                move.l  a_mediach_med(PC),$047E.w
                move.l  a_mediach_rw(PC),$0476.w
do_mediach9:    move.w  #$19,-(SP)
                bsr     do_trap_1       ;Dgetdrv()
                addq.l  #2,SP
                move.w  D0,-(SP)        ;Laufwerk retten
                move.w  a_mediach_drv(PC),-(SP)
                move.w  #$0E,-(SP)
                bsr     do_trap_1       ;Dsetdrv(Changedrive)
                addq.l  #4,SP
                pea     a_mediach_buf(PC)
                move.w  #$3B,-(SP)
                bsr     do_trap_1       ;Dsetpath(OldPath)
                addq.l  #6,SP
                move.w  #$0E,-(SP)
                bsr     do_trap_1       ;Dsetdrv(OldAktDrive)
                addq.l  #4,SP
                movem.l (SP)+,D0-D6/A0-A2
                rts

do_mediach10:   move.w  a_mediach_drv(PC),D0
                cmp.w   4(SP),D0
                bne.s   do_mediach11
                move.l  a_mediach_bpb(PC),$0472.w
                move.l  a_mediach_med(PC),$047E.w
                move.l  a_mediach_rw(PC),$0476.w
do_mediach11:   movea.l a_mediach_bpb(PC),A0
                jmp     (A0)

do_mediach12:   move.w  a_mediach_drv(PC),D0
                cmp.w   4(SP),D0
                bne.s   do_mediach13
                moveq   #2,D0
                rts
do_mediach13:   movea.l a_mediach_med(PC),A0
                jmp     (A0)

do_mediach14:   move.w  a_mediach_drv(PC),D0
                cmp.w   14(SP),D0
                bne.s   do_mediach15
                moveq   #-14,D0
                rts
do_mediach15:   movea.l a_mediach_rw(PC),A0
                jmp     (A0)

do_mediach16:   DC.B 'x:\X',0
                EVEN
a_mediach_drv:  DS.W 1
a_mediach_bpb:  DS.L 1
a_mediach_med:  DS.L 1
a_mediach_rw:   DS.L 1
a_mediach_buf:  DS.B 128
                ENDPART

************************************************************************
* Alles mgl. initialisieren                                            *
************************************************************************
                >PART 'init'
less_mem:       DC.B '[3][ |der Speicher reicht nicht!|(für den Textscreen)][ ABBRUCH ]'
less_rez:       DC.B '[3][ |Auflösung zu gering!|(min. 640x200 Pixel)][ ABBRUCH ]'
big_rez:        DC.B '[3][ |Auflösung zu groß!|(max. 70 Zeilen)][ ABBRUCH ]'
                EVEN
_do_pterm_alert:move.l  A0,addrin(A4)
                move.w  #1,intin(A4)
                move.l  #form_alert,D0
                bsr     aes
                moveq   #-1,D7
_do_pterm:      move.l  #appl_exit,D0
                bsr     aes             ;Applikation wieder abmelden
_pterm:         move.w  D7,-(SP)        ;Fehlercode
                move.w  #$4C,-(SP)
                trap    #1              ;Pterm(Fehlercode)
init:           move.l  #appl_init,D0
                bsr     aes             ;Programm als GEM-Applikation anmelden
                moveq   #-1,D7          ;-1: appl_init() Fehler (kann beim
                addq.w  #1,D0           ;aktuellen GEM nie (!) auftreten!)
                beq.s   _pterm          ;keine ID für das Programm => Ende

                move.l  #graf_handle,D0
                bsr     aes
                move.w  D0,vdi_handle(A4)
                lea     intin(A4),A0
                movea.l A0,A1           ;Zeiger merken (s.u.)
                moveq   #10,D0
init1:          move.w  #1,(A0)+        ;1,1,1,1,1,1,1,1,1,1,2
                dbra    D0,init1
                addq.w  #1,-(A0)
                move.l  #v_opnvwk,D0
                bsr     vdi             ;Workstation öffnen
                moveq   #-39,D7         ;-39: kein Speicher für VDI-Workstation
                move.w  12+contrl(A4),vdi_handle(A4)
                beq.s   _do_pterm       ;kein Speicherplatz für eine Workstation
                movem.w intout(A4),D0-D1 ;max.X, max.Y
                movem.w D0-D1,sdrv_max_x(A4)
                lsr.w   #3,D0           ;maximale Cursorspalte
                move.w  D0,sdrv_maxcur_x(A4)
                move.w  #1,intin(A4)    ;erweiterte Parameter
                move.l  #vq_extnd,D0
                bsr     vdi             ;vq_extnd()
                move.w  intout+8(A4),D0 ;Anzahl der Planes
                move.w  D0,sdrv_planes(A4)
                move.w  D0,D1
                subq.w  #1,D0
                add.w   D0,D0
                move.w  D0,sdrv_poffset(A4) ;Offset auf die nächste Plane
                moveq   #0,D0
init2:          lsr.w   #1,D1
                dbeq    D0,init2
                neg.w   D0
                move.w  D0,sdrv_plnshift(A4)
                move.l  #$0BFFFF,-(SP)
                trap    #13             ;Kbshift()
                addq.l  #4,SP
                move.w  D0,D3
                linea   #0 [ Init ]
                movea.l -$01CC(A0),A0   ;Adresse des aktuellen Fonts
                move.l  4(A1),sdrv_sml_font(A4) ;8x8-Font-Header
                lea     alt_flags,A2
                and.w   (A2)+,D3        ;Bitmaske über Kbshift()
                cmp.w   (A2),D3         ;stimmt der Wert?
                bne.s   init20          ;Nein! =>
                movea.l sdrv_sml_font(A4),A0
init20:         move.w  82(A0),D0       ;Fonthöhe aus dem Zeichensatz
                movea.l 76(A0),A0       ;Zeiger auf das Font-Image
                move.l  A0,sdrv_akt_font(A4) ;Zeiger auf den Font
                move.w  D0,sdrv_cheight(A4)
                moveq   #1,D1
                add.w   sdrv_max_y(A4),D1
                divu    D0,D1           ;max.Cursorzeile errechnen
                subq.w  #1,D1
                move.w  D1,sdrv_maxcur_y(A4)
                moveq   #v_clsvwk,D0
                bsr     vdi             ;Workstation schliessen

                lea     big_rez(PC),A0
                cmpi.w  #max_scrlines,sdrv_maxcur_y(A4)
                bhs     _do_pterm_alert ;=> Auflösung zu groß! =>

                lea     less_rez(PC),A0
                movem.w sdrv_max_x(A4),D0-D1
                cmp.w   #639,D0
                blo     _do_pterm_alert ;Auflösung zu gering! =>
                cmp.w   #199,D1
                blo     _do_pterm_alert

                move.l  #appl_exit,D0
                bsr     aes             ;Applikation wieder abmelden

                linea   #0 [ Init ]
                move.w  2(A0),D0        ;physikalische Rasterzeilenbreite in Bytes
                move.w  D0,sdrv_loffset(A4)
                mulu    sdrv_cheight(A4),D0
                move.w  D0,sdrv_offset(A4)

                move.w  sdrv_maxcur_y(A4),D0
                addq.w  #1,D0
                mulu    sdrv_loffset(A4),D0 ;Größe des Textscreens
                move.l  D0,-(SP)
                move.w  #$48,-(SP)
                trap    #1              ;Malloc()
                addq.l  #6,SP
                lea     less_mem(PC),A0
                move.l  D0,sdrv_tscradr(A4)
                beq     _do_pterm_alert ;der Speicher reicht nicht! =>

                move.w  #3,-(SP)
                trap    #14             ;Logbase()
                addq.l  #2,SP
                move.l  D0,sdrv_scrbase(A4)
                move.w  sdrv_maxcur_y(A4),D0
                subq.w  #menu_offset,D0
                move.w  D0,sdrv_zanz(A4)

                move.l  #hires+255,D0
                add.l   A4,D0
                clr.b   D0
                move.l  D0,screen_adr(A4) ;Bildschirmseite für den Assembler

                lea     line_out2+2(PC),A0
                lea     line_out6+2(PC),A1
                lea     uline_out2+2(PC),A2
                move.w  sdrv_loffset(A4),D0
                move.w  D0,D2
                move.w  sdrv_cheight(A4),D1
                subq.w  #2,D1           ;für DBRA und den Nulloffset
init3:          subq.w  #1,D0
                move.w  D0,(A0)         ;write_line an die Auflösung anpassen
                move.w  D0,(A1)
                move.w  D0,(A2)
                addq.w  #1,D0
                add.w   D2,D0
                addq.l  #4,A0
                addq.l  #4,A1
                addq.l  #4,A2
                dbra    D1,init3

                move.w  sdrv_cheight(A4),D0
                subq.w  #1,D0
                cmp.w   #15,D0          ;16 Pixel (oder mehr, naja)
                bhs.s   init4           ;dann kein BRA einsetzen
                lea     line_out2(PC),A0
                lea     line_out6(PC),A1
                lea     uline_out2(PC),A2
                lsl.w   #2,D0
                moveq   #58,D2
                sub.w   D0,D2
                or.w    #$6000,D2
                move.w  D2,0(A0,D0.w)   ;BRA.S
                move.w  D2,0(A2,D0.w)   ;BRA.S
                move.w  D2,0(A1,D0.w)   ;BRA.S
init4:          jsr     clr_cache

                lea     normal_font(A4),A1
                lea     block_font(A4),A2
                movea.l sdrv_akt_font(A4),A0
                move.w  #$0100,D1       ;Offset im Font
                move.w  #$FF,D0         ;256 Zeichen
init5:          movea.l A0,A3
                move.w  sdrv_cheight(A4),D2
                subq.w  #1,D2
init6:          move.b  (A3),(A1)+      ;Zeichen übertragen
                move.b  (A3),(A2)+
                adda.w  D1,A3
                dbra    D2,init6
                addq.l  #1,A0
                dbra    D0,init5

                lea     block_font(A4),A0
                move.w  #$0100,D0
                mulu    sdrv_cheight(A4),D0
                lsr.w   #2,D0
                subq.w  #1,D0
init7:          ori.l   #$44001100,(A0)+
                dbra    D0,init7

                move.w  sdrv_max_x(A4),D0
                lsr.w   #1,D0
                move.w  D0,mausx(A4)
                move.w  sdrv_max_y(A4),D0
                lsr.w   #1,D0
                move.w  D0,mausy(A4)
                st      mausflg(A4)
                st      mausmove(A4)
                st      mausprell(A4)
                st      _dumpflg(A4)
                st      mausprell2(A4)
                sf      mausdauer(A4)
                move.l  #5*60*200,screen_delay(A4) ;Bildabschaltung nach 5min

;Tastatur init
                move.w  #$1111,timer_c_bitmap(A4) ;200Hz-Timer-Teiler (auf 50Hz)
                lea     iorec_IKBD(A4),A0
                lea     iorec_puffer(A4),A1
                move.l  A1,(A0)+
                clr.l   (A0)            ;Tastaturbuffer setzen und leeren

                movea.l $04F2.w,A0
                movea.l 8(A0),A0
                move.w  $1C(A0),D0
                lsr.w   #1,D0           ;Landeskennung holen
                move.w  D0,language(A4)

                moveq   #-1,D0
                move.l  D0,-(SP)
                move.l  D0,-(SP)
                move.l  D0,-(SP)
                move.w  #$10,-(SP)
                trap    #14
                lea     14(SP),SP
                movea.l D0,A0
                lea     std_keytab(A4),A1
                move.l  (A0)+,(A1)+
                move.l  (A0)+,(A1)+     ;Tastaturtabellen setzen
                move.l  (A0),(A1)
                lea     zscan,A0        ;Zeiger auf die Tastaturtabelle
init8:          tst.l   (A0)
                beq.s   init12          ;Ende der Tabelle
                move.b  3(A0),D0        ;ASCII-Code holen
                beq.s   init11          ;=> weiter
                cmp.b   #'0',D0         ;ASCII-Code zu klein?
                blo.s   init11          ;=> weiter
                tst.b   (A0)            ;F-Taste?
                bmi.s   init11          ;=> weiter
                cmpi.b  #$3A,1(A0)      ;max.Scancode des Alphateils
                bhi.s   init11          ;Scancode zu groß => nix wandeln
                movea.l -4(A1),A2       ;Scancode-SHIFT-Tabelle
                cmpi.b  #1,(A0)         ;SHIFT?
                beq.s   init9           ;Taste patchen
                movea.l -8(A1),A2       ;normale Scancode-Tabelle
init9:          moveq   #127,D1
                moveq   #-1,D2
init10:         addq.w  #1,D2           ;SCAN-Code mitzählen
                cmp.b   (A2)+,D0        ;ASCII-Code gefunden?
                dbeq    D1,init10
                bne.s   init11
                move.b  D2,1(A0)        ;Scan-Code kopieren
init11:         addq.l  #8,A0           ;Zeiger auf die nächste Taste
                bra.s   init8

init12:         lea     menü_tab(PC),A0 ;Zeiger auf die Tastaturtabelle
init13:         tst.w   (A0)+
                bmi.s   init16          ;Ende der Tabelle
                move.b  3(A0),D0        ;ASCII-Code=0?
                beq.s   init15          ;=> weiter
                cmp.b   #'0',D0         ;ASCII-Code zu klein?
                blo.s   init15          ;=> weiter
                tst.b   (A0)            ;F-Taste?
                bmi.s   init15          ;=> weiter
                tst.b   1(A0)           ;Scancode negativ?
                bmi.s   init15          ;Sonderfunktion =>
                movea.l -8(A1),A2       ;normale Scancode-Tabelle
                moveq   #127,D1
                moveq   #-1,D2
init14:         addq.w  #1,D2           ;SCAN-Code mitzählen
                cmp.b   (A2)+,D0        ;ASCII-Code gefunden?
                dbeq    D1,init14
                bne.s   init15
                move.b  D2,1(A0)        ;Scan-Code kopieren
init15:         addq.l  #4,A0           ;Zeiger auf die nächste Taste
                bra.s   init13

init16:         move.w  language(A4),D0
                subq.w  #2,D0
                bne.s   init17          ;kein Frenchi =>
                moveq   #'$',D0
                move.b  D0,kbd_patch2   ;im Drop-Down-Menü ändern
                move.b  D0,kbd_patch1+5
                move.b  D0,kbd_patch4+3
                move.b  #'#',kbd_patch3+3 ;CTRL~ in CTRL-# ändern
                move.b  #'^',asc_show_key+3 ;CTRL-ü in CTRL-^ ändern
init17:         pea     -1.w
                move.w  #$23,-(SP)
                trap    #14             ;Tastatur-Wiederholrate holen
                addq.l  #6,SP
                move.w  D0,kbd_r_init(A4) ;und intern setzen

                moveq   #-2,D0          ;(noch) keine TMacros
                move.l  D0,tmacro_tab(A4)
                move.l  D0,tmacro_tab_end(A4)

************************************************************************
* Vektoren retten/setzen                                               *
************************************************************************
                movea.l $04F2.w,A0      ;Sysbase
                movea.l 8(A0),A0        ;Zeiger ins ROM
                movea.l $24(A0),A1      ;Kbshift-Varadr ab Blitter-TOS
                movea.l $28(A0),A2      ;act_pd ab Blitter-TOS
                cmpi.w  #$0102,$02(A0)  ;Ist's das Blitter-TOS oder neuer?
                bge.s   init18          ;JA!
                lea     $0E1B.w,A1      ;kbshift-Adr (vor dem Blitter-TOS)
                lea     $602C.w,A2      ;act_pd (vor dem Blitter-TOS)
                move.w  $1C(A0),D0      ;os_conf holen
                lsr.w   #1,D0           ;PAL/NTSC-Mode ignorieren
                subq.w  #4,D0           ;Spanisches TOS 1.0?
                bne.s   init18          ;Nein! =>
                lea     $873C,A2        ;act_pd des spanischen TOS 1.0
init18:         move.l  A1,kbshift_adr(A4)
                move.l  A2,act_pd(A4)
                ENDPART

************************************************************************
* Umschaltung der Treiber (insbesondere der Tastatur)                  *
************************************************************************
                >PART 'my_driver' ;eigene Treiber aktivieren
my_driver:      move    SR,-(SP)
                trap    #3
                movem.l D0-A6,-(SP)
                lea     varbase,A4
                ori     #$0700,SR
                movem.l $FFFF8240.w,D0-D7
                movem.l D0-D7,old_color(A4)
                lea     $FFFF8240.w,A0
                move.w  col0(A4),(A0)+
                moveq   #14,D0
my_driver1:     move.w  col1(A4),(A0)+
                dbra    D0,my_driver1
                bsr     set_spez_vek    ;Exception-Vektoren einsetzen
                bsr     set_maus
                linea   #10 [ Hidem ]
                lea     mfp_irq(PC),A0
                movea.l $0118.w,A1
                cmpa.l  A1,A0           ;eigener Treiber schon drin?
                beq.s   my_driver3      ;Ja! => raus
                bsr.s   clr_ikbd
                jsr     set_clock       ;Uhr neu stellen
                move.l  A1,save_kbdvek(A4) ;alten Treiber merken
                move.l  A0,$0118.w      ;und den eigenen rein
my_driver3:     lea     hz200_irq(PC),A0
                movea.l $0114.w,A1
                cmpa.l  A1,A0
                beq.s   my_driver4
                move.l  A1,save_hz200(A4)
                move.l  A0,$0114.w      ;eigenen 200Hz-Timer rein
my_driver4:     st      vbl_time_flag(A4)
                lea     my_vbl(PC),A0
                movea.l $70.w,A1
                cmpa.l  A1,A0
                beq.s   my_driver5
                move.l  A1,save_vbl(A4)
                move.l  A0,$70.w        ;eigene VBL-Routine rein
my_driver5:     lea     etv_critic(PC),A0
                movea.l $0404.w,A1
                cmpa.l  A1,A0
                beq.s   my_driver6
                move.l  A1,old_critic(A4)
                move.l  A0,$0404.w      ;eigenen etv_critic() rein
my_driver6:     IFEQ ^^SYMTAB
                moveq   #14,D0
                bsr     disable_irq     ;Ring-Indikator verbieten
                ENDC
                movem.l (SP)+,D0-A6
                move    (SP)+,SR
                rts
                ENDPART
                >PART 'clr_ikbd'
clr_ikbd:       movem.l D0-D2/A0-A2,-(SP)
                moveq   #$80,D0
                bsr.s   ikbd_send
                moveq   #$01,D0         ;IKBD-Reset
                bsr.s   ikbd_send
                move.w  #$22,-(SP)
                trap    #14             ;Kbdvbase()
                addq.l  #2,SP
                movea.l D0,A0
                clr.b   $24(A0)         ;Paket entfernen
                movea.l kbshift_adr(A4),A0
                andi.b  #$10,(A0)       ;alte Kbshift-Bits löschen (nicht CAPS)
                clr.b   30(A0)          ;~akt.Taste löschen
                move.l  #$0E0001,-(SP)
                trap    #14             ;Iorec(Tastatur)
                addq.l  #4,SP
                movea.l D0,A0
                clr.l   6(A0)           ;Tastaturbuffer löschen
                sf      kbd_repeat_on(A4)
                clr.b   kbstate(A4)     ;noch ein Paket unterwegs?
                andi.b  #$10,kbshift(A4) ;alte Kbshift-Bits löschen (nicht CAPS)
                bsr     clr_keybuff
                movem.l (SP)+,D0-D2/A0-A2
                rts
                ENDPART
                >PART 'ikbd_send'
ikbd_send:      movem.l D0-D1/A0,-(SP)
                move.w  #5000,D1
                lea     $FFFFFC00.w,A0
ikbd_send0:     move.b  (A0),D2         ;wie im ROM...
                btst    #1,D2
                dbne    D1,ikbd_send0   ;allerdings mit: Timeout
                move.w  #950,D0
ikbd_send1:     bsr.s   ikbd_send2      ;noch 'ne kleine Verzögerung
                dbra    D0,ikbd_send1
                movem.l (SP)+,D0-D1/A0
                move.b  D0,$FFFFFC02.w  ;und ab das Byte...
ikbd_send2:     rts
                ENDPART
                >PART 'org_driver' ;Originale Treiber einschalten
************************************************************************
* Originale Treiber aktivieren                                         *
************************************************************************
org_driver:     move    SR,-(SP)
                trap    #3
                movem.l D0-A6,-(SP)
                lea     varbase,A4
                ori     #$0700,SR
                movem.l old_color(A4),D0-D7 ;Farben zurücksetzen
                movem.l D0-D7,$FFFF8240.w
                bsr     reset_spez_vek  ;Exception-Vektoren entfernen
                bsr     clr_ikbd
                bsr     clr_maus
                linea   #9 [ Showm ]
                move.l  save_kbdvek(A4),$0118.w
                move.l  save_hz200(A4),$0114.w
                move.l  save_vbl(A4),$70.w
                move.l  old_critic(A4),$0404.w
                movem.l (SP)+,D0-A6
                move    (SP)+,SR
                rts
                ENDPART

************************************************************************
* MFP-Routinen                                                         *
************************************************************************
                >PART 'install_irq'
************************************************************************
* MFP Interruptvektor setzen                                           *
* D0 = Vektornummer                                                    *
* A2 = Adresse der neuen IRQ-Routine                                   *
* >A0 = Adresse der alten IRQ-Routine                                  *
************************************************************************
install_irq:    movem.l D0-D2/A1-A2,-(SP)
                bsr.s   disable_irq
                move.l  D0,D2
                lsl.w   #2,D2
                addi.l  #$0100,D2
                movea.l D2,A1
                movea.l (A1),A0         ;alten Vektor merken
                move.l  A2,(A1)         ;neuen Vektor setzen
                bsr.s   enable_irq
                movem.l (SP)+,D0-D2/A1-A2
                rts
                ENDPART
                >PART 'disable_irq'
************************************************************************
* MFP-IRQ D0 sperren                                                   *
************************************************************************
disable_irq:    movem.l D0-D1/A0-A1,-(SP)
                lea     $FFFFFA01.w,A0
                lea     $12(A0),A1
                bsr.s   bselect
                bclr    D1,(A1)
                lea     6(A0),A1
                bsr.s   bselect
                bclr    D1,(A1)
                lea     $0A(A0),A1
                bsr.s   bselect
                bclr    D1,(A1)
                lea     $0E(A0),A1
                bsr.s   bselect
                bclr    D1,(A1)
                movem.l (SP)+,D0-D1/A0-A1
                rts
                ENDPART
                >PART 'enable_irq'
************************************************************************
* MFP-IRQ D0 freigeben                                                 *
************************************************************************
enable_irq:     movem.l D0-D1/A0-A1,-(SP)
                lea     $FFFFFA01.w,A0
                lea     6(A0),A1
                bsr.s   bselect
                bset    D1,(A1)
                lea     $12(A0),A1
                bsr.s   bselect
                bset    D1,(A1)
                movem.l (SP)+,D0-D1/A0-A1
                rts

************************************************************************
* Bit/Registernummer für MFP bestimmen                                 *
************************************************************************
bselect:        move.b  D0,D1
                cmp.b   #8,D1
                blt.s   bselec1
                subq.w  #8,D1
                rts
bselec1:        addq.l  #2,A1
                rts
                ENDPART

************************************************************************
* Druckertreiber                                                       *
************************************************************************
                >PART 'prn_spezchar' ;Steuerzeichen in D0 zum Drucker
************************************************************************
* Steuer-Zeichen in D0 zum Drucker senden                              *
* D0=1 ist z.B. CR/LF senden (siehe *.HEX-File bei 1st Word)           *
************************************************************************
prn_spezchar:   movem.l D1/A6,-(SP)
                movea.l prt_tab1(A4),A6
                moveq   #0,D1
prn_spezchar1:  move.b  (A6)+,D1
                beq.s   prn_spezchar2   ;Tabellenende suchen
                subq.b  #1,D1
                cmp.b   (A6),D0
                beq.s   prn_spezchar4   ;Steuerzeichen gefunden
                adda.w  D1,A6
                bra.s   prn_spezchar1
prn_spezchar4:  subq.b  #2,D1
                bmi.s   prn_spezchar2   ;Zeichen nicht ausgeben
                addq.l  #1,A6
prn_spezchar5:  move.b  (A6)+,D0
                bsr.s   prnout          ;Steuerzeichen senden
                dbra    D1,prn_spezchar5
                moveq   #0,D0           ;alles OK
                bra.s   prn_spezchar3
prn_spezchar2:  moveq   #-1,D0          ;Zeichen nicht vorhanden!
prn_spezchar3:  movem.l (SP)+,D1/A6
                rts
                ENDPART
                >PART 'prn_char' ;Zeichen in D0 zum Drucker (mit Wandlung!)
************************************************************************
* Zeichen in D0 zum Drucker senden (mit Wandlung)                      *
************************************************************************
prn_char:       movem.l D0-D1/A6,-(SP)
                movea.l prt_tab2(A4),A6
                moveq   #0,D1
prn_char1:      move.b  (A6)+,D1
                beq.s   prn_char2       ;Tabellenende suchen
                subq.b  #1,D1
                cmp.b   (A6),D0
                beq.s   prn_char4       ;Zeichen gefunden
                adda.w  D1,A6
                bra.s   prn_char1
prn_char4:      moveq   #' ',D0         ;Space als Vorbesetzung
                subq.b  #2,D1
                bmi.s   prn_char2       ;Zeichen nicht ausgeben
                addq.l  #1,A6
prn_char5:      move.b  (A6)+,D0
                bsr.s   prnout          ;Ersatzstring senden
                dbra    D1,prn_char5
                bra.s   prn_char3
prn_char2:      bsr.s   prnout          ;Zeichen ungewandelt ausgeben
prn_char3:      movem.l (SP)+,D0-D1/A6
                rts
                ENDPART
                >PART 'prnstatus' ;Druckerstatus abfragen (Z=1: Drucker Busy)
************************************************************************
* Druckerstatus abfragen                                               *
************************************************************************
prnstatus:      movem.l D0-D2/A0-A2,-(SP)
                move.l  #$080000,-(SP)  ;Bcostat
                trap    #13
                addq.l  #4,SP
                tst.b   D0              ;Z=1, wenn nicht bereit
                movem.l (SP)+,D0-D2/A0-A2
                rts
                ENDPART
                >PART 'prnout'  ;Zeichen ohne Wandlung zum Drucker
************************************************************************
* Zeichen in D0 zum Drucker                                            *
************************************************************************
prnout:         movem.l D1-D2/A0-A2,-(SP)
                and.w   #$FF,D0
                move.w  D0,-(SP)
                move.l  #$030000,-(SP)  ;Bconout
                trap    #13
                addq.l  #6,SP
                movem.l (SP)+,D1-D2/A0-A2
                rts
                ENDPART

************************************************************************
* Keyboardtreiber                                                      *
************************************************************************
                >PART 'clr_keybuff' ;Tastaturbuffer, etc. zurücksetzen
************************************************************************
* Tastaturbuffer löschen (nach dem Umschalten der Treiber nötig)       *
************************************************************************
clr_keybuff:    move.w  #-1,maus_flag(A4) ;Flag wieder zurücksetzen
                clr.b   maus_merk(A4)
                clr.b   maus_merk2(A4)
                move.l  $04BA.w,D0
                move.l  D0,maus_time2(A4)
                move.l  D0,maus_time(A4)
                clr.b   kbd_r_key(A4)
                clr.b   kbd_r_verz(A4)  ;alles löschen
                clr.b   kbd_r_cnt(A4)
                clr.l   iorec_IKBD+4(A4) ;Tastaturbuffer löschen
                rts
                ENDPART
                >PART 'conin'   ;akt.Tastencode nach D0 (mit Makros) D0=0 => nix
************************************************************************
* akt.Tastencode nach D0 holen                                         *
************************************************************************
conin:          movem.l D1-D2/A0-A1,-(SP)
                move.l  tmacro_pointer(A4),D0 ;TMacro aktiv?
                bne.s   conin7          ;Ja! =>
conin0:         lea     iorec_IKBD(A4),A0
                moveq   #0,D0
                move    SR,-(SP)
                ori     #$0700,SR
                move.w  4(A0),D1
                cmp.w   6(A0),D1
                beq.s   conin2          ;Abbruch, wenn keine Taste gedrückt
                addq.b  #4,D1
                movea.l (A0),A1
                move.l  0(A1,D1.w),D0   ;Tastaturcode holen
                tst.l   tmacro_def_key(A4)
                bne.s   conin3          ;keine aktive TMacro-Definition
                lea     tmacro_tab(A4),A1
conin4:         move.l  (A1),D2
                addq.l  #2,D2           ;-2
                beq.s   conin3          ;Ende der Tabelle, kein TMacro
                move.l  (A1)+,D2
                cmp.l   D2,D0
                beq.s   conin6          ;TMacro gefunden
conin5:         move.l  (A1)+,D2
                addq.l  #1,D2           ;TMacro überlesen (bis -1)
                bne.s   conin5
                bra.s   conin4          ;nächstes TMacro
conin3:         move.w  D1,4(A0)
conin2:         move    (SP)+,SR
conin20:        movem.l (SP)+,D1-D2/A0-A1
                rts
conin6:         move.l  (A1),D0         ;neuer Tastencode
                move.w  D0,D2
                lsr.w   #8,D2
                and.w   #$7F,D2
                move.w  D2,tmacro_repeat(A4) ;Anzahl der Wiederholungen
                and.w   #$80FF,D0
                move.l  A1,tmacro_pointer(A4) ;Pointer merken
                bra.s   conin3          ;Ende

conin7:         movea.l D0,A1
                subq.w  #1,tmacro_repeat(A4) ;Anzahl der Wiederholungen-1
                bpl.s   conin9          ;Immer noch??? =>
                addq.l  #4,A1           ;Zeiger auf die nächste Taste
                move.l  (A1),D0         ;Nächste Taste des TMacro holen
                move.w  D0,D2
                lsr.w   #8,D2
                and.w   #$7F,D2
                move.w  D2,tmacro_repeat(A4) ;Anzahl der Wiederholungen
                addq.l  #1,D0
                beq.s   conin8          ;Ende des TMacro
conin9:         move.l  (A1),D0         ;Tastencode nochmal holen
                and.w   #$80FF,D0
                move.l  A1,tmacro_pointer(A4) ;neuen Pointer merken
                bra.s   conin20         ;dat war's
conin8:         clr.l   tmacro_pointer(A4) ;TMacro ist zuende
                bra     conin0          ;nächste Taste holen
                ENDPART
                >PART 'mfp_irq' ;Keyboard-MFP-IRQ
************************************************************************
* Keyboard-IRQ des Mfp                                                 *
************************************************************************
mfp_irq:        movem.l D0-D3/A0-A5,-(SP)
                lea     varbase,A4
k_mfp1:         lea     $FFFFFC04.w,A1
                bsr.s   k_dokbd         ;MIDI-IRQ
                subq.l  #4,A1
                bsr.s   k_dokbd1        ;Keyboard-IRQ
                btst    #4,$FFFFFA01.w
                beq.s   k_mfp1          ;Noch ein IRQ?
                movem.l (SP)+,D0-D3/A0-A5
                bclr    #6,$FFFFFA11.w  ;IRQ wieder freigeben
                rte

k_dokbd:        tst.b   kbstate(A4)     ;kommt was vom Keyboard?
                bne.s   k_isys5         ;Ja! => dann nicht auswerten
k_dokbd1:       movem.l D2/A1,-(SP)
                move.b  (A1),D2
                bpl.s   k_isys3         ;IRQ-Request?
                btst    #0,D2           ;Receiver-Buffer full?
                beq.s   k_isys2
                move.w  A1,D2
                subq.b  #4,D2           ;normale Tastatur?
                bne.s   k_isys0         ;dann stets eine Abfrage
                btst    #0,editor3_flag(A4) ;MIDI-Tastatur an?
                beq.s   k_isys4         ;Nein! =>
k_isys0:        bsr.s   k_avint
k_isys2:        and.b   #$20,D2
                beq.s   k_isys3
k_isys4:        move.b  2(A1),D0
k_isys3:        movem.l (SP)+,D2/A1
k_isys5:        rts

************************************************************************
* Zeichen von ACIA holen                                               *
************************************************************************
k_avint:        jsr     scr_on          ;Bildschirm an

                move.b  2(A1),D0        ;Zeichen holen

                tst.b   kbstate(A4)     ;Ein Paket ist im Anrollen
                bne.s   k_arpak

                and.w   #$FF,D0
                cmp.w   #$F6,D0
                blo     k_arkey         ;Nur ne' Taste

                sub.w   #$F6,D0
                move.b  k_kbsta1(PC,D0.w),kbstate(A4)
                move.b  k_kbind1(PC,D0.w),kbindex(A4)

                add.w   #$F6,D0
                cmp.w   #$F8,D0
                blt.s   k_avin1
                cmp.w   #$FB,D0
                bgt.s   k_avin1
                move.b  D0,maus_paket_2(A4)
k_avin1:        rts

k_kbsta1:       DC.B 1,2,3,3,3,3,4,5,6,6
k_kbind1:       DC.B 7,5,2,2,2,2,6,2,1,1

k_arpak:        cmpi.b  #6,kbstate(A4)
                bhs.s   k_arpk2         ;Joystickdaten ignorieren
                lea     k_arjmt(PC),A2
                moveq   #0,D2
                move.b  kbstate(A4),D2
                subq.b  #1,D2
                mulu    #12,D2
                movea.l 0(A2,D2.w),A0
                adda.l  A4,A0
                movea.l 4(A2,D2.w),A1
                adda.l  A4,A1
                movea.l 8(A2,D2.w),A2   ;Adresse der Routine
                moveq   #0,D2
                move.b  kbindex(A4),D2
                suba.l  D2,A1
                move.b  D0,(A1)
                subq.b  #1,kbindex(A4)  ;Paket komplett?
                bne.s   k_arpk1         ;Nö!
                jsr     (A2)            ;IRQ-Routine anspringen
k_arpk2:        clr.b   kbstate(A4)     ;Paketflag wieder freigeben
k_arpk1:        rts

k_arjmt:        DC.L stat_paket,maus_paket_1,k_arpk1
                DC.L maus_paket_1,maus_paket_2,mausvec
                DC.L maus_paket_2,zeit_paket,mausvec
                DC.L zeit_paket,joydat0,k_arpk1
                DC.L joydat0,joydat2,k_arpk1
                ENDPART
                >PART 'k_arkey' ;Scancode in D0 verarbeiten
k_arkey:        move.b  kbshift(A4),D1
                cmp.b   #$2A,D0
                bne.s   k_ark1
                bset    #1,D1           ;Shift (links) gedrückt
                bra.s   k_ark10
k_ark1:         cmp.b   #$AA,D0
                bne.s   k_ark2
                bclr    #1,D1           ;Shift (links) losgelassen
                bra.s   k_ark10
k_ark2:         cmp.b   #$36,D0
                bne.s   k_ark3
                bset    #0,D1           ;Shift (rechts) gedrückt
                bra.s   k_ark10
k_ark3:         cmp.b   #$B6,D0
                bne.s   k_ark4
                bclr    #0,D1           ;Shift (rechts) losgelassen
                bra.s   k_ark10
k_ark4:         cmp.b   #$1D,D0
                bne.s   k_ark5
                bset    #2,D1           ;Control gedrückt
                bra.s   k_ark10
k_ark5:         cmp.b   #$9D,D0
                bne.s   k_ark6
                bclr    #2,D1           ;Control losgelassen
                bra.s   k_ark10
k_ark6:         cmp.b   #$38,D0
                bne.s   k_ark7
                bset    #3,D1           ;Alternate gedrückt
                bra.s   k_ark10
k_ark7:         cmp.b   #$B8,D0
                bne.s   k_ark8
                bclr    #3,D1           ;Alternate losgelassen
                moveq   #0,D3
                move.b  kbalt(A4),D3    ;Alternate-Zehnerblocktaste?
                beq.s   k_ark10
                move.b  D1,kbshift(A4)  ;Neuer kbshift-Status
                move.w  D3,D0           ;als aktuelle ASCII-Code
                moveq   #0,D1           ;KEIN Scancode!
                moveq   #0,D2           ;kbshift ebenfalls löschen
                bra     k_insert        ;und in den Keyboardbuffer
k_ark8:         cmpi.b  #$3A,D0
                bne.s   k_ark11
                lea     clickdata(PC),A0
                bsr     do_sound        ;CAPS LOCK- Klick
                bchg    #4,D1           ;Bit invertieren
k_ark10:        move.b  D1,kbshift(A4)  ;Neuer kbshift-Status
k_arkxx:        rts
k_ark11:        tst.b   D0
                bmi.s   k_ark13         ;Taste losgelassen
                tst.b   kbd_r_key(A4)
                bne.s   k_ark12         ;Ein Taste wird bereits wiederholt
                move.b  D0,kbd_r_key(A4)
                move.b  kbd_r_init(A4),kbd_r_verz(A4)
                move.b  kbd_r_rate(A4),kbd_r_cnt(A4)
                cmp.b   #$53,D0         ;DELETE gedrückt?
                bne.s   k_arkin         ;Nein? => Weg
                cmpi.b  #%1100,kbshift(A4) ;CTRL+ALT = Warmstart des Debuggers
                beq.s   k_aaa10
                cmpi.b  #%1101,kbshift(A4) ;CTRL+ALT+RSHFT = Cold-Boot
                bne.s   k_arkin
                bra     kill_all
k_aaa10:        movea.l $04F2.w,A0
                jmp     (A0)            ;und ab geht die Post

k_ark12:        clr.b   kbd_r_verz(A4)  ;Zurücksetzen
                clr.b   kbd_r_cnt(A4)
                sf      kbd_repeat_on(A4)
                bra.s   k_arkin

k_ark13:        moveq   #0,D1
                move.b  D1,kbd_r_key(A4)
                move.b  D1,kbd_r_verz(A4) ;alles löschen
                move.b  D1,kbd_r_cnt(A4)
                tst.b   kbd_repeat_on(A4)
                beq.s   k_arkxx         ;Nur löschen, wenn kein Auto-Repeat
                bra     clr_keybuff

k_arkin:        btst    #0,conterm+1(A4)
                beq.s   k_arkii
                lea     clickdata(PC),A0
                bsr     do_sound        ;CAPS LOCK- Klick
k_arkii:        moveq   #0,D1
                move.b  D0,D1           ;Scancode merken
                movea.l std_keytab(A4),A0 ;Normale Tabelle
                and.w   #$7F,D0         ;Bit für losgelassen löschen
                moveq   #$0C,D2         ;CTRL oder ALT gedrückt?
                and.b   kbshift(A4),D2
                bne.s   k_ark16         ;dann nicht wandeln
                btst    #4,kbshift(A4)  ;CAPS LOCK aktiv?
                beq.s   k_ark14
                movea.l caps_keytab(A4),A0 ;Caps-Tastaturtabelle
k_ark14:        btst    #0,kbshift(A4)
                bne.s   k_ark15         ;Shift links?
                btst    #1,kbshift(A4)
                beq.s   k_ark16         ;Shift rechts?
k_ark15:        movea.l shift_keytab(A4),A0 ;Shift-Tastaturtabelle

k_ark16:        move.b  0(A0,D0.w),D0   ;Zeichen aus der Tabelle holen
;ASCII-Code in D0 / Scancode in D1

                btst    #3,kbshift(A4)  ;Alternate gedrückt?
                beq     k_arkbu         ;Nö
                move.w  language(A4),D2
                cmp.w   #2,D2
                bls.s   k_ark170
                moveq   #0,D2           ;im Notfall nur die USA-Tastatur (die is deutsch...)
k_ark170:       add.w   D2,D2
                lea     keyboard_lang(PC,D2.w),A0
                adda.w  (A0),A0
                subq.l  #2,A0
k_ark17:        addq.l  #2,A0
                move.b  (A0)+,D2
                beq.s   k_ark19         ;Ende der Tabelle => raus
                cmp.b   D2,D1           ;Scancode gefunden
                bne.s   k_ark17         ;weiter suchen
                moveq   #3,D2
                and.b   kbshift(A4),D2
                sne     D2              ;Wenn SHIFT-Taste gedrückt, dann
                ext.w   D2
                move.b  1(A0,D2.w),D0   ;neuen ASCII-Code holen
                bra     k_arkbu

                BASE DC.W,*
keyboard_lang:  DC.W gkeyboard_tab ;(für die Ammis gibt's nix)
                DC.W gkeyboard_tab ;Deutsche Tastatur
                DC.W fkeyboard_tab ;Französische Tastatur

gkeyboard_tab:  DC.B $1A,'\','@' ;Deutsche Tastatur
                DC.B $27,'{','['
                DC.B $28,'}',']'
                DC.B 0
fkeyboard_tab:  DC.B $1A,'{','[' ;Französische Tastatur
                DC.B $1B,'}',']'
                DC.B $28,0,'\'
                DC.B $2B,'~','@'
                DC.B 0
                EVEN

k_ark19:        cmp.b   #$62,D1
                bne     k_arkbu         ;Help
                moveq   #3,D2
                and.b   kbshift(A4),D2  ;keine Shift-Taste?
                beq.s   k_ark1x         ;genau =>
                move.b  _dumpflg(A4),D0
                subq.b  #1,D0
                beq.s   k_ark1y
                sf      _dumpflg(A4)    ;Hardcopy auslösen
k_ark1y:        andi.b  #$10,kbshift(A4)
                rts
k_ark1x:        bsr     prnstatus       ;Busy-Flag des Druckers
                beq.s   k_ark1y         ;Nichts zu machen
                tas.b   _dumpflg2(A4)
                bne.s   k_ark1y         ;Hardcopy bereits aktiv! =>
                not.w   $FFFF8240.w     ;Nun geht's los
                moveq   #$01,D0
                bsr     prn_spezchar    ;CR/LF vorneweg
                movea.l sdrv_tscradr(A4),A0 ;Textscreen
                moveq   #menu_offset,D0
                mulu    sdrv_loffset(A4),D0
                adda.w  D0,A0
                move.w  sdrv_maxcur_y(A4),D4
                sub.w   #menu_offset,D4
k_ark20:        lea     prn_buff(A4),A1
                clr.b   (A1)+           ;Damit min. 1 Zeichen kein Space
                move.w  sdrv_maxcur_x(A4),D5 ;Spalten
                IF slider
                sub.w   #slsize,D5
                ENDC
k_ark21:        move.b  (A0)+,(A1)+     ;Zeichen aus dem Bildschirm holen
                dbra    D5,k_ark21
k_ark22:        cmpi.b  #' ',-(A1)      ;Spaces am rechten Rand entfernen
                beq.s   k_ark22
                addq.w  #1,A1
                clr.b   (A1)
                lea     prn_buff+1(A4),A1
k_ark23:        move.b  (A1)+,D0        ;Nun den Buffer ausgeben
                beq.s   k_ark24
                bsr     prn_char
                tst.w   D0              ;Fehler aufgetreten?
                bne.s   k_ark23         ;Nö, weiter
                bra.s   k_ark25         ;Fehler aufgetreten!
k_ark24:        moveq   #$01,D0
                bsr     prn_spezchar    ;Zeilenvorschub
                dbra    D4,k_ark20      ;Nächste Zeile
k_ark25:        moveq   #$21,D0
                bsr     prn_spezchar    ;Sequenz nach dem Drucken
                not.w   $FFFF8240.w
                sf      _dumpflg2(A4)   ;Hardcopy fertig
                bra.s   k_ark1y

k_arkbu:        and.w   #$FF,D1         ;nur die unteren 8 Bits interessieren
                moveq   #0,D3
                moveq   #0,D2
                move.b  kbshift(A4),D2
                bclr    #4,D2           ;CAPS/LOCK weg
                btst    #3,D2           ;Alternate gedrückt?
                beq.s   k_arkbt         ;Nein!
                cmp.b   #$67,D1         ;Tasten 0-9 am Zehnerblock gedrückt?
                blo.s   k_arkbt
                cmp.b   #$70,D1
                bhi.s   k_arkbt
                subi.b  #'0',D0
                move.b  kbalt(A4),D3    ;alten Alternate-Wert holen
                mulu    #10,D3          ;Zehnerposition nach links
                add.b   D0,D3           ;neuen Wert rein
                cmp.w   #256,D3         ;Überlauf?
                blo.s   k_arkbq
                moveq   #0,D3           ;wenn ja, dann löschen
k_arkbq:        move.b  D3,kbalt(A4)
                bra     k_arkex         ;Abbruch
k_arkbt:        bclr    #1,D2           ;Nur eine Shift-Taste weiterleiten
                beq.s   k_arkbv
                bset    #0,D2
k_arkbv:        cmp.b   #$3B,D1         ;kleiner F1
                blo.s   k_arkbw
                cmp.b   #$44,D1         ;größer F10
                bhi.s   k_arkbw         ;dann Abbruch
                subi.b  #$3B,D1
                move.w  D1,D0           ;In den ASCII-Code
                moveq   #0,D1           ;Scan-Code nun löschen
                ori.b   #$80,D2         ;F-Tastenflag ins kbshift
                and.b   #$F3,D2         ;Alternate und Control-Bits löschen
                btst    #0,D2           ;Shift?
                beq.s   k_insert        ;Nein!
                addi.w  #10,D0          ;für F-Tasten mit Shift + 10
                andi.b  #$FE,D2         ;Shift killen
                bra.s   k_insert
k_arkbw:        moveq   #$0C,D3
                and.b   D2,D3           ;Alternate oder Control?
                beq.s   k_insert        ;Anscheinend nicht!
                cmp.b   #2,D1
                blo.s   k_arkbx         ;'1'
                cmp.b   #13,D1
                bhi.s   k_arkbx         ;bis "'"
                subq.w  #2,D1
                move.w  D1,D0
                ori.w   #$8000,D0       ;Flag für Marker-Tasten
                moveq   #0,D1           ;Scancode löschen
                bra.s   k_insert
k_arkbx:        cmp.b   #41,D1
                bne.s   k_insert        ;'#'
                move.w  #$800C,D0       ;s.o., nur alles auf einmal
                moveq   #0,D1           ;Scancode löschen
k_insert:       cmp.b   #$72,D1         ;Enter?
                bne.s   k_arkby
                moveq   #$1C,D1         ;Scancode für Return nehmen
k_arkby:        asl.w   #8,D2           ;kbshift in die Bits 8-15
                or.w    D1,D2           ;Scancode rein
                swap    D2              ;ab in das obere Word
                or.w    D0,D2           ;ASCII-Code reinmaskieren
                move.l  D2,D0
                swap    D0
                btst    #6,editor3_flag(A4)
                beq.s   k_arkby0        ;Hex-Zehnerblock? Nein! =>
                moveq   #'E',D1
                cmp.b   #$4A,D0         ;"-"
                beq.s   k_arkby2        ;gefunden
                moveq   #'F',D1
                cmp.b   #$4E,D0         ;"+"
                beq.s   k_arkby2        ;gefunden
                move.b  D0,D1
                sub.b   #$22,D1         ;Scancode in Buchstaben wandeln
                cmp.b   #'A',D1
                blo.s   k_arkbz         ;dat war nix...
                cmp.b   #'D',D1
                bhi.s   k_arkbz         ;dat war auch nix...
k_arkby2:       swap    D0
                move.b  D1,D0           ;neuen ASCII-Code einsetzen
                swap    D0
k_arkby0:       btst    #5,editor3_flag(A4)
                beq.s   k_arkbz         ;IBM-Zehnerblock? Nein! =>
                cmp.b   #$63,D0         ;kleiner als "("
                blo.s   k_arkbz         ;keine IBM-Taste???
                cmp.b   #$71,D0         ;größer als "."
                bhi.s   k_arkbz
                ext.w   D0              ;Bit 7 ist NIE gesetzt!
                sub.w   #$63,D0
                lsl.w   #2,D0           ;mal 4
                move.l  ibm_table(PC,D0.w),D0 ;IBM-Tastencode holen
                beq.s   k_arkex         ;keinen Code erzeugen
k_arkbz:        swap    D0
                bsr.s   into_kbd_buff
                beq.s   k_arkex         ;Zeichen wurde nicht angenommen
                clr.b   kbalt(A4)       ;Alternate-Taste löschen
k_arkex:        rts

;Der IBM-Zehnerblock, Scancode & ASCII-Code sind vertauscht (Wordbreite)
ibm_table:      DC.L $00        ;(
                DC.L $00        ;)
                DC.L $00        ;/
                DC.L $00        ;*
                DC.L $740814    ;7 Home
                DC.L $48        ;8 
                DC.L $0448      ;9 PgUp
                DC.L $4B        ;4 
                DC.L $00        ;5
                DC.L $4D        ;6 
                DC.L $650812    ;1 End
                DC.L $50        ;2 
                DC.L $0450      ;3 PgDn
                DC.L $52        ;0 Ins
                DC.L $7F0053    ;. Del
                ENDPART
                >PART 'into_kbd_buff' ;Tastencode D0 in den Keyboard-Buffer
************************************************************************
* Tastencode in D0 in den Keyboard-Buffer eintragen (Z=1 => kein Platz)*
************************************************************************
into_kbd_buff:  movem.l D0-D1/A0-A1,-(SP)
                tst.b   tmacro_def_flag(A4) ;Taste nach Control-ESC?
                bne     into_kbd_buff50 ;ja! =>
                lea     iorec_IKBD(A4),A0
                move.w  6(A0),D1        ;Tail-Index
                addq.b  #4,D1           ;plus 4 (Größe eines Eintrags)
                cmp.w   4(A0),D1        ;= Head-Index?
                beq     into_kbd_buff2  ;dann beenden
                movea.l (A0),A1         ;Pufferadr holen
                cmp.l   #$0801001B,D0   ;Alt-ESC?
                beq.s   into_kbd_buff13 ;nicht übernehmen
                cmp.l   #$0401001B,D0   ;Control-ESC?
                beq.s   into_kbd_buff13 ;nicht übernehmen
                move.l  D0,0(A1,D1.w)   ;Tastencode eintragen
                move.w  D1,6(A0)        ;Tail-Index neu setzen
into_kbd_buff13:tst.l   tmacro_def_key(A4) ;TMacro-Definition aktiv
                beq.s   into_kbd_buff5  ;Nein! =>

                cmp.l   #$0801001B,D0   ;Alt-ESC
                bne.s   into_kbd_buff12
                movea.l tmacro_def_adr(A4),A0
                moveq   #-1,D1          ;TMacro-Definition abschließen
                move.l  D1,(A0)
                lea     tmacro_tab(A4),A0
into_kbd_buff14:move.l  (A0)+,D1        ;Tabellenende suchen
                addq.l  #2,D1
                bne.s   into_kbd_buff14
                move.l  4(A0),D0
                addq.l  #1,D0           ;TMacro löschen?
                beq.s   into_kbd_buff16 ;ja! =>
into_kbd_buff15:move.l  (A0),-4(A0)     ;Tabellenende (-2) überkopieren
                move.l  (A0)+,D1
                addq.l  #1,D1
                bne.s   into_kbd_buff15
                moveq   #-2,D1
                move.l  D1,-(A0)        ;neues Tabellenende setzen
into_kbd_buff16:clr.l   tmacro_def_key(A4)
                clr.l   tmacro_def_adr(A4)
                bra     into_kbd_buff3  ;Ende und raus (Puuuuuhhhhh!)

into_kbd_buff12:movea.l tmacro_def_adr(A4),A0
                cmp.l   -4(A0),D0       ;gleiche Taste wie zuvor?
                bne.s   into_kbd_buff4  ;Nein! =>
                addq.b  #1,-2(A0)       ;sonst nur die Anzahl erhöhen
                bpl.s   into_kbd_buff3  ;max.Anzahl (128) noch nicht erreicht
                move.b  #$7F,-2(A0)     ;max.Anzahl setzen und neuen Eintrag
into_kbd_buff4: lea     tmacro_tab_end(A4),A1
                cmpa.l  A1,A0           ;Tabellenende erreicht?
                bhs.s   into_kbd_buff3  ;dann Tastencode nicht mehr nehmen
                move.l  D0,(A0)+        ;Tastencode merken
                move.l  A0,tmacro_def_adr(A4) ;erhöhten Pointer merken
                bra.s   into_kbd_buff3

into_kbd_buff5: cmp.l   #$0401001B,D0   ;Control-ESC
                bne.s   into_kbd_buff3  ;Nein! =>
                st      tmacro_def_flag(A4) ;auch zu belegende Taste warten
                bra.s   into_kbd_buff3  ;raus hier =>

into_kbd_buff50:tst.l   D0
                beq.s   into_kbd_buff3
                cmp.l   #$0401001B,D0   ;Control-ESC
                beq.s   into_kbd_buff3  ;dat wird ignoriert
                cmp.l   #$0801001B,D0   ;Alt-ESC
                beq.s   into_kbd_buff3  ;dat wird auch ignoriert
                sf      tmacro_def_flag(A4)
                lea     tmacro_tab(A4),A0
                suba.l  A1,A1
into_kbd_buff8: move.l  (A0),D1
                addq.l  #2,D1           ;Ende der Tabelle gefunden
                beq.s   into_kbd_buff7  ;ja! =>
                cmp.l   (A0)+,D0        ;gibt's schon ein Macro mit dieser Taste?
                bne.s   into_kbd_buff10 ;nein! =>
                lea     -4(A0),A1       ;Pointer merken
into_kbd_buff10:move.l  (A0)+,D1
                addq.l  #1,D1           ;TMacro überlesen (bis -1)
                bne.s   into_kbd_buff10
                move.l  A1,D1
                beq.s   into_kbd_buff8  ;nächstes TMacro
into_kbd_buff9: move.l  (A0),(A1)+      ;TMacro entfernen
                move.l  (A0)+,D1
                addq.l  #2,D1
                bne.s   into_kbd_buff9
                movea.l A1,A0
                bra.s   into_kbd_buff11
into_kbd_buff7: addq.l  #4,A0           ;Pointer hinter das Tabellenende (-2)
into_kbd_buff11:lea     tmacro_tab_end(A4),A1
                cmpa.l  A1,A0
                bhs.s   into_kbd_buff3  ;Buffer voll =>
                move.l  D0,tmacro_def_key(A4) ;TMacro-Definition starten
                move.l  D0,(A0)+        ;Tastencode merken
                move.l  A0,tmacro_def_adr(A4)
into_kbd_buff3: moveq   #-1,D0          ;Z-Flag löschen
into_kbd_buff2: movem.l (SP)+,D0-D1/A0-A1
                rts
                ENDPART
                >PART 'mausvec' ;IKBD Mouse-Handler
************************************************************************
* IKBD Mouse-Handler                                                   *
************************************************************************
mausvec:        movem.l D0-D2/A0-A2,-(SP)
                moveq   #3,D0
                and.b   (A0),D0         ;Maustasten-Status
                eor.b   D0,(A0)
                cmpi.b  #$F8,(A0)+      ;Maus-Header?
                bne.s   mausvec7        ;Nein! =>
                move.b  D0,akt_maust(A4) ;und merken
                move.b  (A0)+,D0        ;Delta X
                or.b    (A0),D0         ;Delta Y
                beq.s   mausvec7        ;Maus nicht bewegt
                move.l  $04BA.w,D0
                sub.l   mausf_time(A4),D0 ;Differenz zum letzten Aufruf bilden
                move.l  $04BA.w,mausf_time(A4) ;200Hz-Timerwert merken
                subq.l  #3,D0           ;>5ms zurück?
                bhs.s   mausvec1        ;dann Ende
                move.b  -(A0),D0
                add.b   D0,(A0)+        ;sonst die Koordinaten verdoppeln
                move.b  (A0),D0
                add.b   D0,(A0)
mausvec1:       subq.l  #1,A0
                lea     mausx(A4),A1
                lea     sdrv_max_x(A4),A2
                moveq   #1,D2
mausvec2:       move.w  (A1),D0         ;Alte X-Position holen
                move.b  (A0)+,D1
                ext.w   D1
                add.w   D1,D0           ;neue X-Position
                bpl.s   mausvec3
                moveq   #0,D0
mausvec3:       move.w  (A2)+,D1
                subq.w  #1,D1
                cmp.w   D1,D0
                bls.s   mausvec6
                move.w  D1,D0
mausvec6:       move.w  D0,(A1)+        ;X-Position retten
                dbra    D2,mausvec2
                sf      mausmove(A4)    ;Maus wurde bewegt
mausvec7:       movem.l (SP)+,D0-D2/A0-A2
                rts
                ENDPART

************************************************************************
* Die 200Hz-Timer-Routine                                              *
************************************************************************
                >PART 'hz200_irq'
hz200_irq:      addq.l  #1,$04BA.w      ;200Hz-Timer erhöhen
                movem.l D0-A6,-(SP)
                lea     varbase(PC),A4
                addq.l  #1,screen_time(A4) ;Zeit des Screen-Savers
                rol.w   timer_c_bitmap(A4)
                bpl     hz200i4         ;auf 50Hz runterteilen
                tst.b   kbd_r_key(A4)   ;Taste gedrückt?
                beq.s   hz200i2
                tst.b   kbd_r_verz(A4)  ;Verzögerung abgelaufen?
                beq.s   hz200i1
                subq.b  #1,kbd_r_verz(A4)
                bne.s   hz200i2
hz200i1:        subq.b  #1,kbd_r_cnt(A4)
                bne.s   hz200i2
                st      kbd_repeat_on(A4) ;Es läuft der Auto-Repeat
                move.b  kbd_r_rate(A4),kbd_r_cnt(A4)
                move.b  kbd_r_key(A4),D0
                bsr     k_arkin         ;Taste in den Tastaturbuffer
hz200i2:        move.b  akt_maust(A4),D2
                tst.b   mausdauer(A4)
                bne.s   hz200ia
                cmpi.w  #menu_offset*16,mausy(A4) ;In den oberen 2 Zeilen
                blo.s   hz200i3         ;Taste direkt übernehmen
hz200ia:        tst.b   no_dklick(A4)   ;Keine Doppelklickabfrage?
                bne.s   hz200i3         ;Genau => Taste übernehmen
                subq.b  #1,maus_merk2(A4)
                bgt.s   hz200i8
                clr.b   maus_merk2(A4)
                andi.b  #3,D2
                beq.s   hz200i6         ;keine Taste gedrückt
                tst.w   maus_flag(A4)
                beq.s   hz200i7         ;Doppelklick melden
                move.l  $04BA.w,D0
                move.l  D0,maus_time2(A4)
                sub.l   maus_time(A4),D0 ;Solange wird die Taste schon gedrückt
                cmp.l   #40,D0
                bhs.s   hz200i5         ;ein langer Klick!
                sf      maus_flag(A4)
                move.b  D2,maus_merk(A4) ;Taste merken
                bra.s   hz200i9
hz200i7:        lsl.b   #2,D2           ;Doppelklick melden
                move.b  #5,maus_merk2(A4) ;Timeout
                bra.s   hz200i3
hz200i5:        lsl.b   #4,D2           ;langen Klick melden
                bra.s   hz200i3
hz200i6:        move.l  $04BA.w,D0
                move.l  D0,maus_time(A4)
                sub.l   maus_time2(A4),D0 ;solange wurde die Taste gedrückt
                move.b  maus_merk(A4),D2 ;alten Maustastenstatus holen
                cmp.l   #30,D0
                bhs.s   hz200i3         ;Es war ein Einfach-Klick (oder keiner)!
                sf      maus_flag+1(A4)
                bra.s   hz200i9         ;noch nix melden=> Doppelklickgefahr
hz200i3:        move.b  D2,maustast(A4) ;Maustastenstatus setzen
hz200i8:        move.w  #-1,maus_flag(A4) ;Flag wieder zurücksetzen
                clr.b   maus_merk(A4)
hz200i9:        move.w  save_data-8+$0442(A4),-(SP)
                movea.l save_data-8+$0400(A4),A0
                jsr     (A0)            ;etv_timer ausführen
                addq.l  #2,SP
                subq.w  #1,hz200_time(A4) ;Nun noch die eigene Uhr
                bpl.s   hz200i4
                move.w  #49,hz200_time(A4)
                sf      vbl_time_flag(A4)
                addq.b  #1,time_s(A4)   ;Sekunden erhöhen
                cmpi.b  #60,time_s(A4)
                blo.s   hz200i4         ;<60 => Ende
                clr.b   time_s(A4)
                addq.b  #1,time_m(A4)   ;Minuten erhöhen
                cmpi.b  #60,time_m(A4)
                blo.s   hz200i4         ;<60 => Ende
                clr.b   time_m(A4)
                addq.b  #1,time_h(A4)   ;Stunden erhöhen
                cmpi.b  #24,time_h(A4)
                blo.s   hz200i4         ;<24 => Ende
                clr.b   time_h(A4)
hz200i4:        moveq   #$11,D0         ;rechte Taste?
                and.b   maustast(A4),D0 ;Maustastenstatus holen
                beq.s   hz200i41        ;nein
                tst.b   maustast_flag(A4) ;Maustastenflag setzen?
                beq.s   hz200i41        ;Nein! =>
                st      maustast_flag(A4)
hz200i41:       movem.l (SP)+,D0-A6
                bclr    #5,$FFFFFA11.w  ;IRQ wieder freigeben
                rte
                ENDPART

************************************************************************
* VBL-Routine (für die Maus)                                           *
************************************************************************
                >PART 'my_vbl'
my_vbl:         addq.l  #1,$0466.w
                bmi     my_vbl_exit
                movem.l D0-A6,-(SP)
                lea     varbase(PC),A4
                ori     #$0700,SR       ;Bitte nicht stören!
                addq.l  #1,$0462.w

                tst.w   $04A6.w         ;überhaupt ein Laufwerk vorhanden?
                beq.s   my_vbl1         ;Nein! =>
                tst.w   $043E.w         ;Laufwerk gesperrt?
                bne.s   my_vbl1         ;Ja! =>
                move.w  $FFFF8604.w,D0  ;FDC-Status lesen
                tst.b   D0
                bmi.s   my_vbl1         ;Motor läuft noch =>
                move.b  #14,$FFFF8800.w
                moveq   #7,D1
                or.b    $FFFF8800.w,D1  ;deselect alle Drives
                move.b  D1,$FFFF8802.w

my_vbl1:        btst    #7,curflag(A4)
                beq.s   my_vbl4         ;Cursor ist aus! =>
                subq.b  #1,curflag+1(A4) ;Timer rückwärts
                bne.s   my_vbl4
                move.b  #$20,curflag+1(A4) ;Timer neu setzen
                bchg    #6,curflag(A4)  ;Cursorzustand (1=An/0=Aus)
                move.b  mausoff(A4),D0
                move.b  mausmove(A4),D1
                move.b  mausflg(A4),D2
                move.w  D0,-(SP)
                move.l  zeile(A4),-(SP)
                moveq   #-1,D0
                move.w  sdrv_maxcur_x(A4),D0
                sub.w   #14,D0
                move.l  D0,zeile(A4)
                moveq   #' ',D0
                btst    #4,kbshift(A4)
                beq.s   my_vbl2         ;Caps aus
                moveq   #'C',D0
my_vbl2:        bsr     char_out        ;Status ausgeben
                subq.w  #1,spalte(A4)
                moveq   #' ',D0
                tst.l   tmacro_def_key(A4)
                beq.s   my_vbl3
                moveq   #'M',D0         ;Macro-Definition an
my_vbl3:        bsr     char_out
                move.l  (SP)+,zeile(A4)
                move.w  (SP)+,D0
                bsr     flash_cursor
                tst.b   D2
                beq.s   my_vbl4
                move.b  D0,mausoff(A4)
                move.b  D1,mausmove(A4)

my_vbl4:        tas.b   vbl_time_flag(A4)
                bne.s   my_vbl6         ;Nicht darstellen
                lea     time_txt(PC),A0
                tst.b   uhr_flag(A4)    ;Uhr an?
                beq.s   my_vbl5         ;Ja! =>
                move.l  #'    ',D0
                move.l  D0,(A0)+        ;Uhr löschen
                move.l  D0,(A0)
                bra.s   my_vbl6
my_vbl5:        moveq   #0,D0
                move.b  time_h(A4),D0   ;Stunden einsetzen
                divu    #10,D0
                or.l    #'  ',D0
                move.b  D0,(A0)+
                swap    D0
                move.b  D0,(A0)+
                move.b  #':',(A0)+
                moveq   #0,D0
                move.b  time_m(A4),D0   ;Minuten einsetzen
                divu    #10,D0
                or.l    #'  ',D0
                move.b  D0,(A0)+
                swap    D0
                move.b  D0,(A0)+
                move.b  #':',(A0)+
                moveq   #0,D0
                move.b  time_s(A4),D0   ;Sekunden einsetzen
                divu    #10,D0
                or.l    #'  ',D0
                move.b  D0,(A0)+
                swap    D0
                move.b  D0,(A0)

my_vbl6:        tas.b   mausmove(A4)    ;Wurde die Maus bewegt?
                bne.s   my_vbl7         ;Nein! =>
                tst.b   mausoff(A4)     ;ist die Maus aus?
                bne.s   my_vbl7         ;Ja! =>
                bsr     undraw_sprite   ;Undraw, wenn nötig
                movem.w mausx(A4),D0-D1
                bsr.s   draw_sprite     ;Maus neu setzen
my_vbl7:        tst.b   kbd_r_key(A4)   ;Taste gedrückt?
                beq.s   my_vbl_end
                bsr     undraw_sprite   ;dann die Maus ausschalten
my_vbl_end:     movem.l (SP)+,D0-A6
my_vbl_exit:    rte
                ENDPART
                >PART 'draw_sprite'
draw_sprite:    lea     mausbuffer(A4),A2
                move.w  sprite_no(A4),D2
                lsl.w   #7,D2           ;mal 128 (Spritelänge)
                lea     sprite(PC),A0
                adda.w  D2,A0
                movea.l sdrv_scrbase(A4),A1 ;Bildschirmadresse
                move.w  sdrv_max_y(A4),D2
                sub.w   D1,D2
                mulu    sdrv_loffset(A4),D1
                adda.l  D1,A1           ;+ Y-Offset
                moveq   #15,D1          ;Anzahl der Zeilen (minus 1)
                cmp.w   D1,D2
                bhs.s   draw_sprite1    ;Clipping am unteren Rand
                move.w  D2,D1
draw_sprite1:   move.w  D1,(A2)+        ;Anzahl der Zeilen merken
                move.w  sdrv_max_x(A4),D2 ;max. X-Koordinate (z.B. 639)
                sub.w   D0,D2
                cmp.w   #15,D2          ;kein Clipping am rechten Rand?
                slo     D6
                ext.w   D6              ;Clipping am rechten Rand
                move.w  D6,D5
                not.w   D5
                moveq   #$0F,D2
                and.w   D0,D2           ;X-Koordinate
                eor.w   D2,D0
                lsr.w   #3,D0           ;X durch 8 teilen = Wortposition in der Zeile
                move.w  sdrv_plnshift(A4),D3
                lsl.w   D3,D0
                adda.w  D0,A1           ;+ X-Offset
                move.l  A1,(A2)+        ;Adresse merken
                move.w  sdrv_poffset(A4),D4 ;Offset auf die nächste Plane
draw_sprite2:   move.l  (A0)+,D3        ;Maske holen
                lsr.l   D2,D3           ;in die richtige Position schieben
                not.l   D3
                or.w    D6,D3           ;Clipping am rechten Rand
                move.w  (A1),(A2)+      ;Hintergrund retten
                move.w  2(A1,D4.w),(A2)+
                and.w   D3,2(A1,D4.w)   ;Maske reinknüpfen
                swap    D3
                and.w   D3,(A1)
                move.l  (A0)+,D3        ;Spritedaten holen
                lsr.l   D2,D3           ;in die richtige Position schieben
                and.w   D5,D3           ;Clipping am rechten Rand
                or.w    D3,2(A1,D4.w)   ;Daten reinknüpfen
                swap    D3
                or.w    D3,(A1)
                adda.w  sdrv_loffset(A4),A1 ;Nächste Zeile
                dbra    D1,draw_sprite2
                sf      mausflg(A4)     ;"Maus an"-Flag
                rts
                ENDPART
                >PART 'undraw_sprite'
undraw_sprite:  tas.b   mausflg(A4)     ;War die Maus an?
                bne.s   undraw_sprite2  ;Nein! =>
                movem.l D0-D1/A0-A1,-(SP)
                lea     mausbuffer(A4),A0
                move.w  (A0)+,D0        ;Anzahl der geretteten Zeilen
                movea.l (A0)+,A1        ;Bildschirmposition des Buffers
                move.w  sdrv_poffset(A4),D1 ;Plane-Offset
undraw_sprite1: move.w  (A0)+,(A1)      ;Buffer zurückschreiben
                move.w  (A0)+,2(A1,D1.w)
                adda.w  sdrv_loffset(A4),A1
                dbra    D0,undraw_sprite1
                movem.l (SP)+,D0-D1/A0-A1
undraw_sprite2: rts
                ENDPART
                >PART 'sprite'  ;Die Mausformen
sprite:         DC.L %11000000000000000000000000000000 ;Der normale Mauszeiger
                DC.L %0
                DC.L %11100000000000000000000000000000
                DC.L %1000000000000000000000000000000
                DC.L %11110000000000000000000000000000
                DC.L %1100000000000000000000000000000
                DC.L %11111000000000000000000000000000
                DC.L %1110000000000000000000000000000
                DC.L %11111100000000000000000000000000
                DC.L %1111000000000000000000000000000
                DC.L %11111110000000000000000000000000
                DC.L %1111100000000000000000000000000
                DC.L %11111111000000000000000000000000
                DC.L %1111110000000000000000000000000
                DC.L %11111111100000000000000000000000
                DC.L %1111111000000000000000000000000
                DC.L %11111111110000000000000000000000
                DC.L %1111111100000000000000000000000
                DC.L %11111111111000000000000000000000
                DC.L %1111100000000000000000000000000
                DC.L %11111110000000000000000000000000
                DC.L %1101100000000000000000000000000
                DC.L %11101111000000000000000000000000
                DC.L %1000110000000000000000000000000
                DC.L %11001111000000000000000000000000
                DC.L %110000000000000000000000000
                DC.L %10000111100000000000000000000000
                DC.L %11000000000000000000000000
                DC.L %111100000000000000000000000
                DC.L %11000000000000000000000000
                DC.L %11100000000000000000000000
                DC.L %0
                DC.W 65535,0,65535,0,65535,0,65529,0,65535,0,65529,0,65535,0,65535,0
                DC.W 65535,0,65535,0,65535,0,65535,0,65535,0,65535,0,65535,0,65535,0
                DC.W 65535,0,65535,0,65535,0,63519,0,65535,0,64287,0,65535,0,64287,0
                DC.W 65535,0,64287,0,65535,0,64287,0,32767,0,30751,0,16382,0,16382,0

                DC.W %1111111111111111,0
                DC.W %1111111111111111,0
                DC.W %1111111111111111,0
                DC.W %1111111111111111,0
                DC.W %1111111111111111,0
                DC.W %110000000000110,0
                DC.W %1111111111111111,0
                DC.W %110000000000110,0
                DC.W %111111111111110,0
                DC.W %11000000001100,0
                DC.W %11111111111100,0
                DC.W %1101111011000,0
                DC.W %1111111111000,0
                DC.W %110110110000,0
                DC.W %111111110000,0
                DC.W %11001100000,0
                DC.W %111111110000,0
                DC.W %11001100000,0
                DC.W %1111111111000,0
                DC.W %110000110000,0
                DC.W %11111111111100,0
                DC.W %1100000011000,0
                DC.W %111111111111110,0
                DC.W %11001111001100,0
                DC.W %1111111111111111,0
                DC.W %110111111110110,0
                DC.W %1111111111111111,0
                DC.W %110111111110110,0
                DC.W %1111111111111111,0
                DC.W %1111111111111111,0
                DC.W %1111111111111111,0
                DC.W %1111111111111111,0
                ENDPART

                >PART 'clr_maus' ;Maus ausschalten
************************************************************************
* Maus an/ausschalten                                                  *
************************************************************************
clr_maus:       tas.b   mausoff(A4)     ;Maus muß ausgeschaltet werden
                bne.s   set_maus2       ;Maus ist bereits aus! =>
                bra     undraw_sprite   ;und weg von Bildschirm
                ENDPART
                >PART 'set_maus' ;Maus anschalten
set_maus:       tst.b   kbd_r_key(A4)   ;Taste gedrückt?
                bne.s   set_maus1       ;=> Maus nicht sofort wieder darstellen
                sf      mausmove(A4)    ;Maus wurde bewegt => wird dargestellt
set_maus1:      sf      mausoff(A4)     ;Maus darf wieder an
set_maus2:      rts
                ENDPART
                >PART 'graf_mouse' ;Mausform ändern
_graf_mouse:    bsr.s   clr_maus
                move.w  D0,sprite_no(A4) ;Neuen Mauszeiger setzen
                bra.s   set_maus
                ENDPART

                >PART 'do_sound' ;Sound ab A0 "erklingen" lassen
************************************************************************
* Sound ab A0 "erklingen" lassen                                       *
************************************************************************
do_sound:       movem.l D0/A1,-(SP)
                lea     $FFFF8800.w,A1
do_sound1:      move.w  (A0)+,D0
                bmi.s   do_sound2
                movep.w D0,0(A1)
                bra.s   do_sound1
do_sound2:      movem.l (SP)+,D0/A1
                rts
                ENDPART
                >PART 'bell_data/clickdata' ;Sounddaten
************************************************************************
* Sounddaten                                                           *
************************************************************************
bell_data:      DC.W $34,$0100,$0200,$0300,$0400,$0500,$0600
                DC.W $07FE,$0810,$0900,$0A00,$0B00,$0C10,$0D09,-1
clickdata:      DC.W $3B,$0100,$0200,$0300,$0400,$0500,$0600
                DC.W $07FE,$0810,$0D03,$0B80,$0C01,-1
                ENDPART
                >PART 'kill_all' ;echter Kaltstart
************************************************************************
* Den gesamten Speicher löschen & RESET                                *
************************************************************************
kill_all:       move    #$2700,SR
                lea     kill_a2(PC),A0
                moveq   #$0D,D0
                lea     8.w,A1
kill_a1:        move.l  (A0)+,(A1)+
                dbra    D0,kill_a1
                jmp     8.w
kill_a2:        lea     kill_a4(PC),A0
                move.l  A0,8.w
                lea     kill_a5(PC),A0
                moveq   #0,D0
                move.l  D0,D1
                move.l  D0,D2
                move.l  D0,D3
                move.l  D0,D4
                move.l  D0,D5
                move.l  D0,D6
                move.l  D0,D7
                movea.l D0,A1
                movea.l D0,A2
                movea.l D0,A3
                movea.l D0,A4
                movea.l D0,A5
                movea.l D0,A6
kill_a3:        movem.l D0-D7/A1-A6,(A0)
                lea     $38(A0),A0
                bra.s   kill_a3
kill_a4:        movea.l 4.w,A0
                jmp     (A0)
kill_a5:
                ENDPART

                >PART 'mauschk' ;Haupt-Mausabfrage
************************************************************************
* Mausabfrage (Irgendwas ausgelöst?)                                   *
************************************************************************
mauschk:        bsr     print_time      ;Uhrzeit updaten
                moveq   #0,D0
                moveq   #0,D1
                move.w  mausx(A4),D0
                move.w  mausy(A4),D1    ;Mauskoordinaten
                lsr.w   #3,D0
                divu    sdrv_cheight(A4),D1 ;In Zeichenkoordinaten umrechnen
                move.w  D0,mausxb(A4)
                move.w  D1,mausyb(A4)
                tst.b   scroll_action2(A4)
                bne.s   mauscc4         ;es wird bereits gescrollt
                tst.w   D1              ;oberste Zeile?
                bne.s   mauscc4         ;Nein! =>
                bsr     evnt_menü       ;Menüverwaltung
mauscc4:        tst.w   D1              ;Maus noch in der 1.Zeile?
                beq.s   mauscc7         ;dann weiter
                tst.b   scroll_action(A4)
                bne.s   mauscc7         ;wird noch gescrollt? dann weiter
                clr.b   scroll_action2(A4) ;Menü wieder erlauben
mauscc7:        tst.w   menü_titel(A4)  ;Menü aktiv?
                bpl.s   mauscc5         ;dann nix anderes mehr auswerten
                tst.b   curflag(A4)     ;War der Cursor aus?
                bmi.s   mauscc6         ;dann bleibt er aus ...
                bsr     cursor_on       ;Cursor sonst wieder an
mauscc6:        tst.w   D1              ;Maus in der 1.Zeile?
                beq.s   mauscc8
mauscc60:       btst    #5,maustast(A4) ;Dauerklick links
                bne     mausch4         ;ja!
                clr.b   mausdauer(A4)   ;Flag löschen
                btst    #3,maustast(A4) ;Doppelklick links
                bne     mausch6         ;ja!
                btst    #2,maustast(A4) ;Doppelklick rechts
                bne     mausch5         ;ja!
                btst    #1,maustast(A4) ;Linke Taste gedrückt?
                beq.s   mausch1         ;Nein!
                clr.b   mausprell(A4)   ;merken, daß gedrückt wurde
                bra     mauschf         ;Ende
mauscc5:        bsr     evnt_menü       ;Menüverwaltung
                move    #0,CCR
                rts
mauscc8:        tst.b   mausdauer(A4)
                bne.s   mauscc60
                moveq   #$22,D0
                and.b   maustast(A4),D0 ;linke Maustaste in der 1.Zeile?
                beq     mauschf         ;Ende, wenn nicht
                move.w  sdrv_maxcur_x(A4),D0
                subq.w  #7,D0
                cmp.w   mausxb(A4),D0   ;Maus über der Uhr?
                bhi.s   mauscc9
                move.l  #$80000009,D0   ;F10 - Uhr stellen
                bra     mausc21         ;Aktion aufgetreten
mauscc9:        subq.w  #1,D0
                cmp.w   mausxb(A4),D0
                beq     mauschf         ;Über dem ASCII-Code?
                subq.w  #3,D0
                cmp.w   mausxb(A4),D0
                bhi     mauschf
mauscc10:       tst.b   maustast(A4)    ;Maus entprellen
                bne.s   mauscc10
                move.l  asc_show_key,D0 ;Control-ü
                bra     mausc21         ;Aktion aufgetreten

mauscc2:        tst.b   scroll_action(A4)
                bne.s   mauschf         ;Ende, da gescrollt wird
                st      s_left_right(A4) ;Flag für rechte Taste
                bra     mausch2
mausch1:        tas.b   mausprell(A4)   ;Wurde die Taste losgelassen?
                bne.s   mauschf         ;Nö => rechte Taste und Scrollen prüfen
                sf      s_left_right(A4) ;Flag für linke Taste
                bra     mausch2
mausch4:        subq.w  #menu_offset,D1
                bpl.s   mausch42
                moveq   #0,D1
                tst.b   mausdauer(A4)
                beq.s   mausche         ;keine Aktion
mausch42:       cmp.w   sdrv_zanz(A4),D1
                blo.s   mausch45
                move.w  sdrv_zanz(A4),D1
mausch45:       move.w  D1,s_zeile(A4)
                tas.b   mausdauer(A4)
                beq.s   mausch41
                move.w  mausy(A4),D0
                moveq   #menu_offset,D1
                mulu    sdrv_cheight(A4),D1
                addq.w  #8,D1
                cmp.w   D1,D0
                bhi.s   mausch44
                move.l  blockm_up_key,D0 ;Blockmarke verändern und Crsr up
                bra     mausc21         ;Aktion aufgetreten
mausch44:
                move.w  sdrv_max_y(A4),D1
                subq.w  #8,D1
                cmp.w   D1,D0
                blo.s   mausch43
                move.l  blockm_down_key,D0 ;Blockmarke verändern und Crsr down
                bra     mausc21         ;Aktion aufgetreten
mausch43:       move.l  blockm_chg_key,D0 ;Scancode für Blockmarken verändern
                bra     mausc21         ;Aktion aufgetreten
mausch41:       move.l  blockm_mrk_key,D0 ;Scancode für Blockdefinition beginnen
                bra     mausc21         ;Aktion aufgetreten
mausche:        move    #0,CCR          ;Es wurde nichts getan
                rts
mauschf:        btst    #0,maustast(A4) ;Rechte Taste gedrückt?
                beq.s   mauscf1         ;Nein!
                clr.b   mausprell2(A4)  ;merken, daß gedrückt wurde
                bra.s   mauscf2         ;Ende
mauscf1:        tas.b   mausprell2(A4)  ;Wurde die Taste losgelassen?
                beq     mauscc2         ;ja
mauscf2:        tst.b   scroll_action(A4)
                bne.s   mauscf3         ;es wird bereits gescrollt
                btst    #4,maustast(A4) ;Langer Klick rechts ist auch OK
                bne.s   mauscf3
                btst    #0,maustast(A4) ;Scrollen nur mit der rechten Maustaste!
                beq.s   mauschg         ;kein Scrollen, wenn nicht gedrückt
mauscf3:        tas.b   s_scroll_delay(A4)
                beq.s   mauschg         ;Chance zum Redraw
                move.w  mausy(A4),D0
                cmp.w   #8,D0
                bhi.s   mauschh
                st      scroll_action(A4)
                st      scroll_action2(A4)
                sf      s_scroll_delay(A4)
                move.l  sftcrsrup_key,D0 ;Shift Control Cursor up
                bra.s   mausc21         ;Aktion aufgetreten
mauschh:        move.w  sdrv_max_y(A4),D1
                subq.w  #8,D1
                cmp.w   D1,D0
                blo.s   mauschg1
                st      scroll_action(A4)
                st      scroll_action2(A4)
                sf      s_scroll_delay(A4)
                move.l  sftcrsrdown_key,D0 ;Shift Control Cursor down
                bra.s   mausc21         ;Aktion aufgetreten
mauschg1:       sf      scroll_action(A4)
mauschg:        move    #0,CCR
                rts

mausch2:        cmp.w   #menu_offset-1,D1
                bne     mausch3
                move.w  sdrv_maxcur_x(A4),D1
                sub.w   D0,D1
                tst.w   D0
                beq.s   mausc20
                cmp.w   #12,D1          ;Modus
                bls.s   mausc22
                cmp.b   #16,D1          ;'B'
                beq.s   mausc23
                cmp.b   #14,D1          ;'C' CAPS an/aus
                beq.s   mausch24
                cmp.w   #6,D0
                bhi.s   mausc25
                move.l  z_line,D0       ;Sprung zur Zeile
                tst.b   s_left_right(A4)
                beq.s   mausc21         ;linke Maustaste
                move.l  z_last,D0       ;letzte geänderte Zeile
mausc21:        move    #$FF,CCR
                rts
mausch24:       bchg    #4,kbshift(A4)
                bra.s   mauschg
mausc20:        move.l  z_home,D0       ;zum Quelltextanfang
                bra.s   mausc21
mausc25:        cmp.w   #13,D0
                bhi.s   mauschg
                move.l  z_left,D0       ;Control left
                tst.b   s_left_right(A4)
                beq.s   mausc24         ;linke Maustaste
                move.l  z_right,D0      ;Control right
                bra.s   mausc24
mausc22:        move.l  z_swit,D0       ;Insert/Overwrite
                bra.s   mausc24
mausc23:        move.l  z_bhid,D0       ;Block hide
                tst.b   mausprell2(A4)
                beq.s   mausc24         ;Klick links bei gedrückter rechter Taste
                move.l  z_banf,D0       ;Blockanfang
                tst.b   s_left_right(A4)
                beq.s   mausc24         ;linke Maustaste
                move.l  z_bend,D0       ;Blockende
mausc24:        move    #$FF,CCR
                rts
mausch3:        tst.b   s_left_right(A4) ;Ende, wenn
                bne     mauschg         ;die rechte Taste gedrückt wird
                move.w  D0,s_spalte(A4) ;Zeile und Spalte merken
                subq.w  #menu_offset,D1
                move.w  D1,s_zeile(A4)
                move.l  setcrsr_key,D0  ;Scancode für Cursor setzen
                move    #$FF,CCR
                rts
mausch5:        movem.l D2/A0-A1,-(SP)
                movea.l sdrv_tscradr(A4),A0
                move.w  D0,s_spalte(A4)
                move.w  D1,s_zeile(A4)  ;Zeichenposition merken
                mulu    sdrv_loffset(A4),D1
                adda.w  D1,A0           ;Adresse der Bildschirmzeile
                move.l  A0,D2
                adda.w  D0,A0
                cmpi.b  #'#',(A0)
                bne.s   mausc51
                addq.l  #1,A0
mausc51:        move.b  -(A0),D1
                cmp.b   #'#',D1
                beq.s   mausc52
                cmp.b   #':',D1
                beq.s   mausc52
                cmp.b   #';',D1
                beq.s   mausc52
                cmp.b   #',',D1
                beq.s   mausc52         ;Anfang der Formel bestimmen
                cmp.b   #' ',D1
                dbeq    D0,mausc51
mausc52:        addq.l  #1,A0
                move.l  A0,D1
                sub.l   D2,D1           ;neue Spaltenposition bestimmen
                move.w  D1,block_pointer(A4) ;und merken
                lea     rechner_0,A1
                moveq   #66,D0
mausc54:        move.b  (A0)+,(A1)+
                beq.s   mausc55
                cmpi.b  #':',-1(A0)
                beq.s   mausc55
                cmpi.b  #' ',-1(A0)     ;Formel kopieren
                beq.s   mausc55
                cmpi.b  #',',-1(A0)
                dbeq    D0,mausc54
                bne.s   mausc59
mausc55:        subq.l  #1,A1
                cmp.w   #66,D0
                beq.s   mausc58         ;keine Formel
                cmpi.b  #')',-1(A1)     ;letztes Zeichen
                beq.s   mausc552
                cmpi.b  #'w',-1(A1)
                beq.s   mausc559
                cmpi.b  #',',(A1)
                bne.s   mausc551
                cmpi.b  #'(',-3(A1)
                bne.s   mausc551
                subq.l  #3,A1           ; (Ax,Rx.w) am Ende
                bra.s   mausc551
mausc559:       cmpi.b  #'.',-2(A1)     ;vorletztes Zeichen
                bne.s   mausc551
                subq.w  #2,A1           ; .w am Ende
mausc551:       move.l  A1,D1
                sub.l   #rechner_0,D1
                move.w  D1,block_pointer+2(A4) ;Länge der Formel merken
                moveq   #67,D0          ;max. Länge
                sub.w   D1,D0           ;minus Länge der Formel
                bra.s   mausc56
mausc57:        move.b  #' ',(A1)+      ;mit Spaces auffüllen
mausc56:        dbra    D0,mausc57
mausc59:        move.l  #$80000004,D0   ;Scancode für Rechner
                movem.l (SP)+,D2/A0-A1
                move    #$FF,CCR
                rts
mausc58:        movem.l (SP)+,D2/A0-A1  ;keine Aktion aufgetreten
                move    #0,CCR
                rts
mausc552:       move.b  -2(A1),D2       ;vorletztes Zeichen
                cmpi.b  #'c',D2
                beq.s   mausc554
                cmp.b   #'C',D2
                beq.s   mausc554
                cmp.b   #'p',D2
                beq.s   mausc556
                cmp.b   #'P',D2
                beq.s   mausc556
                cmpi.b  #'A',-3(A1)
                beq.s   mausc555
                cmpi.b  #'a',-3(A1)
                bne.s   mausc551
mausc555:       cmpi.b  #'(',-4(A1)
                bne.s   mausc551
                subq.l  #4,A1           ; (Ax) am Ende
                bra.s   mausc551
mausc554:       cmpi.b  #'P',-3(A1)
                beq.s   mausc555        ; (PC) am Ende
                cmpi.b  #'p',-3(A1)
                beq.s   mausc555
                bra.s   mausc551
mausc556:       cmpi.b  #'s',-3(A1)
                beq.s   mausc555        ; (SP) am Ende
                cmpi.b  #'S',-3(A1)
                beq.s   mausc555
                bra     mausc551

mausch6:        movem.l D2/A0-A2,-(SP)
                movea.l sdrv_tscradr(A4),A0
                mulu    sdrv_loffset(A4),D1
                adda.w  D1,A0           ;Adresse der Bildschirmzeile
                adda.w  D0,A0           ;plus Mausspalte
                lea     allowed_chars(PC),A1
                moveq   #0,D2
                move.b  (A0),D2
                tst.b   0(A1,D2.w)
                beq.s   mausc68         ;das war nix!
mausc61:        move.b  -(A0),D2
                tst.b   0(A1,D2.w)      ;Anfang des Symbolnamen bestimmen
                dbeq    D0,mausc61
                tst.w   D0
                bmi.s   mausc610        ;in der Spalte -1 -> Zeichen gehört nicht zum Symbol
                cmp.b   local_char(A4),D2 ;lokales Symbol?
                beq.s   mausc611        ;ja
mausc610:       addq.l  #1,A0
                move.b  (A0),D2
                tst.b   0(A1,D2.w)
                bpl.s   mausc611
                addq.l  #1,A0
mausc611:       move.w  D0,D2           ;Spalte merken (0=Symboldefinition!)
                bsr     search_label    ;Symbol in Tabelle suchen
                tst.w   D0
                bmi.s   mausc68         ;nicht gefunden
                move.w  D0,s_spalte(A4) ;Index speichern
                tst.w   D2              ;Klick auf Symboldefinition?
                ble.s   mausc621        ;ja
                move.l  jmplabel_key,D0 ;Scancode für Sprung zur Labeldefinition
                movem.l (SP)+,D2/A0-A2
mausc62:        btst    #3,maustast(A4) ;Doppelkick entprellen
                bne.s   mausc62
                move    #$FF,CCR
                rts
mausc68:        movem.l (SP)+,D2/A0-A2
                move    #0,CCR          ;keine Aktion
                rts
mausc621:       moveq   #3,D0           ;linke und rechte SHIFT-taste testen
                and.b   kbshift(A4),D0
                bne.s   mausc626        ;SHIFT gedrückt
                lea     sym_such_1,A2   ;Zeiger auf Suchstring
                bsr.s   mausc625        ;Symbolnamen kopieren
                move.l  z_such,D0       ;Scancode für Control F
                movem.l (SP)+,D2/A0-A2
                bra.s   mausc62
mausc626:       lea     sym_repl_1,A2   ;Zeiger auf Suchstring
                bsr.s   mausc625        ;Symbolnamen kopieren
                move.l  z_repl,D0       ;Scancode für Control E
                movem.l (SP)+,D2/A0-A2
                bra.s   mausc62

mausc625:       addq.l  #8,A1           ;A1 zeigt auf Symbolnamen (im Eintrag)
                moveq   #23,D1          ;max. Länge
mausc622:       subq.w  #1,D1
                move.b  (A1)+,(A2)+     ;Zeichen kopieren
                bne.s   mausc622        ;Ende noch nicht erreicht
                subq.l  #1,A2
                tst.w   D1
                bmi.s   mausc623        ;volle Länge
mausc624:       move.b  #' ',(A2)+      ;Rest mit Spaces füllen
                dbra    D1,mausc624
mausc623:       clr.b   (A2)+
                rts
                ENDPART

************************************************************************
* Menüverwaltung                                                       *
************************************************************************
                >PART 'evnt_menü'
evnt_menü:      movem.l D0-A6,-(SP)
                moveq   #$22,D0
                and.b   maustast(A4),D0 ;linke Maustaste
                bne.s   menü_check25
                moveq   #$11,D0
                and.b   maustast(A4),D0 ;rechte Maustaste
                bne.s   menü_check23
                tst.w   mausyb(A4)
                bne     menü_check1
                move.w  mausxb(A4),D2
                beq     menü_check1
                tst.w   menü_stitel(A4)
                bmi.s   menü_check0
                move.w  #-1,menü_stitel(A4) ;kein Untertitel selektiert
                bra.s   menü_check20
menü_check0:    moveq   #-1,D0          ;Menütitel=-1
                moveq   #0,D1           ;akt.Spalte
                movea.l menü_baum_adr(A4),A0
                bra.s   menü_check3
menü_check4:    move.b  (A0)+,D3
                addq.b  #1,D3
                beq.s   menü_check7     ;nächsten Titel gefunden
                addq.b  #1,D3
                bne.s   menü_check4
                moveq   #-1,D0
                bra.s   menü_check6
menü_check7:    subq.w  #1,D1
menü_check3:    addq.w  #1,D1
                tst.b   (A0)+
                bne.s   menü_check3
                addq.w  #1,D0           ;Menütitel erhöhen
                cmp.w   D1,D2           ;Titel gefunden?
                bhs.s   menü_check4     ;NEIN! => weiter suchen
                tst.w   menü_titel(A4)  ;Titel selektiert?
                bpl.s   menü_check6     ;Nein! =>
                bsr     cursor_off
                bsr     save_mback      ;Hintergrund retten
menü_check6:    cmp.w   menü_titel(A4),D0
                beq.s   menü_check5     ;Titel bereits selektiert? Ja! => raus
                move.w  D0,menü_titel(A4)
menü_check24:   bsr     restore_mback   ;Hintergrund restaurieren
menü_check20:   bsr     menü_draw       ;selekieren
menü_check5:    movem.l (SP)+,D0-A6
                rts
menü_check25:   movep.w menü_titel+1(A4),D0
                move.b  menü_stitel+1(A4),D0
                move.w  D0,sel_menü_titel(A4)
menü_check23:   move.l  menü_titel(A4),D0
                addq.l  #1,D0
                beq.s   menü_check5
                moveq   #-1,D0
                move.l  D0,menü_titel(A4) ;Titel & Untertitel löschen
menü_check27:   tst.b   maustast(A4)    ;Maus entprellen
                bne.s   menü_check27
                st      scroll_action2(A4)
                bra.s   menü_check24

menü_check1:    move.w  menü_titel(A4),D0
                bmi     menü_check2
                move.w  D0,D1
                moveq   #1,D2           ;akt.Spalte
                movea.l menü_baum_adr(A4),A0 ;linke Koordinate des Menüs ermitteln
menü_check17:   tst.w   D0
                beq.s   menü_check16
                subq.w  #1,D0           ;Titelnummer-1
menü_check18:   addq.w  #1,D2           ;Spalte+1
                tst.b   (A0)+           ;Titel überlesen
                bne.s   menü_check18
                subq.w  #1,D2
menü_check19:   move.b  (A0)+,D3        ;Untertitel überlesen
                addq.b  #1,D3
                beq.s   menü_check17
                addq.b  #1,D3
                bne.s   menü_check19
menü_check16:   move.w  D1,D0
                movea.l menü_baum_adr(A4),A0
                bra.s   menü_check9
menü_check8:    move.b  (A0)+,D1
                addq.b  #2,D1
                beq.s   menü_check10    ;Ende des Menübaums
                subq.b  #1,D1
                bne.s   menü_check8     ;Menüeintragsende noch nicht gefunden
menü_check9:    dbra    D0,menü_check8
menü_check15:   tst.b   (A0)+           ;Menütitel ignorieren
                bne.s   menü_check15

                movea.l A0,A1
                moveq   #-2,D0
menü_check11:   addq.w  #1,D0           ;Breite des Menüs+1
                tst.b   (A1)+
                bne.s   menü_check11

                moveq   #1,D1
menü_check12:   move.b  (A1)+,D3        ;Anzahl der Unterpunkte
                addq.b  #1,D3
                beq.s   menü_check13
                addq.b  #1,D3
                beq.s   menü_check13
                subq.b  #2,D3
                bne.s   menü_check12
                addq.w  #1,D1           ;Anzahl der Menüzeilen+1
                bra.s   menü_check12

menü_check13:   moveq   #-1,D3          ;kein Untertitel selektiert
                cmp.w   mausxb(A4),D2
                bhi.s   menü_check10
                add.w   D0,D2
                cmp.w   mausxb(A4),D2
                bls.s   menü_check10
                cmp.w   mausyb(A4),D1
                blo.s   menü_check10
                move.w  mausyb(A4),D3
                subq.w  #1,D3
                move.w  D3,D0
                subq.w  #1,D0
                bmi.s   menü_check21
menü_check22:   tst.b   (A0)+
                bne.s   menü_check22
                dbra    D0,menü_check22
menü_check21:   btst    #1,(A0)
                beq.s   menü_check10
                moveq   #-1,D3
menü_check10:   cmp.w   menü_stitel(A4),D3
                beq.s   menü_check2
                move.w  D3,menü_stitel(A4)
                bsr.s   menü_redraw
menü_check2:    movem.l (SP)+,D0-A6
                rts

menü_redraw:    move.w  menü_titel(A4),D0
                cmp.w   menü_save_titel(A4),D0
                bne     menü_draw
                bsr     clr_maus
                move.l  menü_save_a0(A4),D0
                beq.s   menü_redraw3
                movea.l D0,A0
                addq.l  #1,A0
                move.l  menü_save_zeile(A4),menü_zeile(A4)
                moveq   #-1,D1          ;Light aus
                moveq   #$80,D2         ;Invers aus, linke Linie
                move.w  menü_save_d5(A4),D5
                tst.b   4(A0,D5.w)      ;1.Zeichen des Folgeeintrags testen
                smi     D3              ;letzte Zeile unterstreichen
                move.b  (A0)+,D0
                beq.s   menü_redraw3
                bsr     menü_char
                moveq   #0,D2
menü_redraw1:   move.b  (A0)+,D0
                bsr     menü_char
                dbra    D5,menü_redraw1
                moveq   #1,D2           ;rechte Linie
                move.b  (A0)+,D0
                bsr     menü_char
menü_redraw3:   movea.l menü_save_a1(A4),A0 ;zeigt auf die Unterpunkte
                move.w  menü_save_zeile+2(A4),menü_spalte(A4)
                move.w  menü_stitel(A4),D0
                bmi.s   menü_redraw4
                addq.w  #1,D0
                move.w  D0,menü_zeile(A4)
                move.l  menü_zeile(A4),menü_save_zeile(A4)
                subq.w  #1,D0
                beq.s   menü_redraw7
                subq.w  #1,D0
menü_redraw6:   tst.b   (A0)+           ;Eintrag überlesen
                bne.s   menü_redraw6
                dbra    D0,menü_redraw6
menü_redraw7:   move.l  A0,menü_save_a0(A4)
                addq.l  #1,A0
                moveq   #-1,D1          ;Light aus
                moveq   #-1,D2          ;Invers an
                moveq   #0,D3           ;Underline aus
menü_redraw5:   move.b  (A0)+,D0
                beq.s   menü_redraw4
                bsr     menü_char
                bra.s   menü_redraw5
menü_redraw4:   bra     set_maus
                ENDPART
                >PART 'menü_bar' ;Menüleiste A0 zeichnen
************************************************************************
* Menüleiste A0 zeichnen                                               *
************************************************************************
menü_draw:      movea.l menü_baum_adr(A4),A0
menü_bar:       movem.l D0-A6,-(SP)
                bsr     clr_maus
                clr.w   menü_spalte(A4)
                clr.w   menü_zeile(A4)
                moveq   #-1,D1          ;Lightmaske
                moveq   #0,D2           ;Xor-Maske
                moveq   #-1,D3          ;Underline
                moveq   #' ',D0
                bsr     menü_char
                moveq   #-1,D4          ;akt.Titel
menü_bar0:      move.w  menü_spalte(A4),D6 ;Spalte merken
                moveq   #0,D2           ;Invers aus
                addq.w  #1,D4           ;Titelnummer erhöhen
                cmp.w   menü_titel(A4),D4
                bne.s   menü_bar1
                moveq   #-1,D2          ;Invers darstellen
menü_bar1:      move.b  (A0)+,D0
                beq.s   menü_bar4
                bsr     menü_char
                bra.s   menü_bar1
menü_bar4:      cmp.w   menü_titel(A4),D4
                bne     menü_bar2       ;akt.Titel selektiert? Nein! =>
                move.w  D4,-(SP)
                move.w  menü_spalte(A4),-(SP)
                moveq   #-1,D4          ;Menüuntertitel=0
                moveq   #-5,D5
                move.l  A0,menü_save_a1(A4)
                movea.l A0,A1
menü_bar12:     addq.w  #1,D5           ;Länge eines Eintrags ermitteln
                tst.b   (A1)+
                bne.s   menü_bar12
menü_bar8:      move.w  D6,menü_spalte(A4)
                addq.w  #1,menü_zeile(A4) ;Menüpunkte ausgeben
                addq.w  #1,D4           ;nächster Menüuntertitel
                tst.b   5(A0,D5.w)      ;1.Zeichen des Folgeeintrags testen
                smi     D3              ;letzte Zeile unterstreichen
                moveq   #0,D7
                moveq   #$80,D2         ;Invers aus, linke Linie
                cmp.w   menü_stitel(A4),D4
                bne.s   menü_bar11
                move.l  menü_zeile(A4),menü_save_zeile(A4) ;Inverse Zeile merken
                move.l  A0,menü_save_a0(A4) ;Menüeintrag merken
                move.w  menü_titel(A4),menü_save_titel(A4)
                move.b  D3,menü_save_d3(A4)
                move.w  D5,menü_save_d5(A4)
                moveq   #-1,D2          ;Invers an
                moveq   #-1,D7
menü_bar11:     moveq   #-1,D1
                btst    #1,(A0)+        ;deselected?
                beq.s   menü_bar5
                moveq   #$55,D1         ;Zeile disablen
menü_bar5:      move.b  (A0)+,D0
                bsr     menü_char
                move.b  D7,D2
                move.w  D5,D7
menü_bar6:      move.b  (A0)+,D0
                bsr     menü_char
                dbra    D7,menü_bar6
                or.b    #1,D2           ;rechte vertikale Linie
                move.b  (A0)+,D0
                bsr.s   menü_char
                addq.l  #1,A0
                tst.b   (A0)
                bpl.s   menü_bar8       ;Ende der Menüleiste

                clr.w   menü_zeile(A4)
                moveq   #-1,D3          ;Underline an
                moveq   #-1,D1          ;Light aus
                move.w  (SP)+,menü_spalte(A4)
                move.w  (SP)+,D4
menü_bar2:      move.b  (A0)+,D0
                addq.b  #1,D0           ;nächsten Menütitel gefunden
                beq     menü_bar0
                addq.b  #1,D0           ;Ende der Menüleiste?
                bne.s   menü_bar2       ;Nein! =>
                moveq   #-1,D1
                moveq   #0,D2
                moveq   #' ',D0
                addq.w  #3,menü_spalte(A4)
                bsr.s   menü_char
                clr.b   save_asc_code(A4)
                bsr.s   print_time
                bsr     set_maus
                movem.l (SP)+,D0-A6
                rts
                ENDPART
                >PART 'print_time'
print_time:     movem.l D0-D4/A0,-(SP)
                moveq   #-1,D1          ;Light aus
                moveq   #0,D2           ;Invers aus
                moveq   #-1,D3          ;Underline an
                moveq   #0,D0
                move.w  sdrv_maxcur_x(A4),D0
                subq.w  #7,D0
                move.l  D0,menü_zeile(A4) ;Zeile=0, Spalte=72
                lea     time_txt(PC),A0
                moveq   #7,D4
print_time1:    move.b  (A0)+,D0        ;Uhrzeit ausgeben
                bsr.s   menü_char
                dbra    D4,print_time1
                jsr     scr_off
                movem.l (SP)+,D0-D4/A0
                rts

time_txt:       DC.B '00:00:00'
                ENDPART
                >PART 'menü_char' ;Zeichen D0 an Cursorposition (für Menüleiste)
************************************************************************
* Zeichen D0 an Cursorposition ausgeben                                *
************************************************************************
menü_char:      movem.l D0-A1,-(SP)
                and.w   #$FF,D0
                movea.l sdrv_akt_font(A4),A0 ;Fontadresse
                adda.w  D0,A0           ;plus ASCII-Code (= Zeichenadr)
                move.w  D1,D6
                move.w  D2,D7
                move.w  D3,D5
                move.b  D2,D4
                move.b  D7,D0
                addq.b  #1,D0           ;invers?
                bne.s   menü_char1      ;Nein! =>
                moveq   #0,D4
menü_char1:     movea.l sdrv_scrbase(A4),A1
                move.w  menü_zeile(A4),D2
                mulu    sdrv_offset(A4),D2
                adda.l  D2,A1           ;+ Zeilenadresse
                move.w  menü_spalte(A4),D3
                moveq   #1,D0
                and.w   D3,D0
                adda.w  D0,A1           ;+ (Spalte and 1)
                eor.w   D0,D3
                move.w  sdrv_plnshift(A4),D0
                lsl.w   D0,D3
                adda.w  D3,A1           ;+ (Spalte and -2) * 2
                move.w  sdrv_cheight(A4),D1 ;Zeilenanzahl
                subq.w  #1,D1
                move.w  #$0100,D2       ;Offset für den Zeichensatz
                move.w  sdrv_loffset(A4),D3 ;Offset für den Bildschirm
menü_char2:     move.b  (A0),D0         ;Aus dem Font holen
                and.b   D6,D0           ;light
                eor.b   D7,D0           ;invers
                or.b    D4,D0           ;vertikale Linien
                tst.w   D1
                bne.s   menü_char3
                or.b    D5,D0           ;Unterline
menü_char3:     move.b  D0,(A1)         ;auf den Screen
                adda.w  D2,A0
                adda.w  D3,A1
                rol.b   #1,D6           ;Maske rotieren
                dbra    D1,menü_char2
                addq.w  #1,menü_spalte(A4)
                movem.l (SP)+,D0-A1
                rts
                ENDPART
                >PART 'save/restore_mback' ;Menühintergrund retten / zurückkopieren
************************************************************************
* Menühintergrund retten                                               *
************************************************************************
restore_mback:  movem.l D0-D2/A0-A2,-(SP)
                bsr     clr_maus
                movea.l sdrv_scrbase(A4),A1
                moveq   #0,D0
                move.w  sdrv_offset(A4),D0
                adda.w  D0,A1
                movea.l screen_adr(A4),A0
                bsr     MemMove         ;die Statuszeile zurückkopieren
                bsr     set_maus
                lea     mark_tab(A4),A0
                moveq   #max_mlines-2,D1 ;max.Zeilenanzahl eines Menüpunktes
                moveq   #0,D0
restore_mback1: tst.b   0(A0,D0.w)      ;Zeile markiert?
                bne.s   restore_mback2  ;Ja! =>
                bsr     update_line     ;normale Zeile updaten
                addq.w  #1,D0
                dbra    D1,restore_mback1
                movem.l (SP)+,D0-D2/A0-A2
                rts
restore_mback2: bsr     update_mline    ;markierte Zeile updaten
                addq.w  #1,D0
                dbra    D1,restore_mback1
                movem.l (SP)+,D0-D2/A0-A2
                rts
save_mback:     movem.l D0-D2/A0-A2,-(SP)
                bsr     clr_maus
                movea.l sdrv_scrbase(A4),A0
                moveq   #0,D0
                move.w  sdrv_offset(A4),D0
                adda.w  D0,A0
                movea.l screen_adr(A4),A1
                bsr     MemMove         ;nur die Statuszeile retten
                bsr     set_maus
                movem.l (SP)+,D0-D2/A0-A2
                rts
                ENDPART

                >PART 'cursor_on' ;Cursor an
************************************************************************
* Cursor an-/ausschalten                                               *
************************************************************************
cursor_on:      bsr.s   flash_cursor    ;Cursor darstellen
                move.w  #$FF20,curflag(A4) ;Cursor ist an
cursor_:        rts
                ENDPART
                >PART 'cursor_off' ;Cursor aus
cursor_off:     bclr    #7,curflag(A4)  ;Cursor sofort stoppen
                bclr    #6,curflag(A4)
                beq.s   cursor_
                ENDPART
                >PART 'flash_cursor' ;Cursor invertieren
flash_cursor:   movem.l D0-D3/A0-A2,-(SP)
                bsr     clr_maus
                bsr     calc_crsr
                mulu    sdrv_cheight(A4),D2 ;Cursorzeile * 1280
                movea.l sdrv_scrbase(A4),A1
                adda.l  D2,A1           ;+ Bildschirmadresse
                moveq   #1,D1
                and.w   D3,D1
                adda.w  D1,A1           ;+ Bildschirmadresse
                eor.w   D1,D3
                move.w  sdrv_plnshift(A4),D1
                lsl.w   D1,D3
                adda.w  D3,A1           ;+ Cursorspalte
                move.w  sdrv_cheight(A4),D2
                subq.w  #1,D2
flash_cursor1:  not.b   (A1)
                adda.w  sdrv_loffset(A4),A1
                dbra    D2,flash_cursor1
                bsr     set_maus
                movem.l (SP)+,D0-D3/A0-A2
                rts
                ENDPART
                >PART 'tastchk' ;ist eine Taste gedrückt?
************************************************************************
* Tastaturabfrage (D0 = Tastencode) ( D0<0 => keine Taste )            *
************************************************************************
tastchk:        move.l  save_redef_key(A4),D0 ;Taste bei Redefinition-Error?
                bne.s   tastchk2        ;dann den Tastencode nehmen
                bsr     conin
                tst.l   D0
                beq.s   tastchk1        ;nicht gedrückt
tastchk2:       clr.l   save_redef_key(A4) ;Tastencode löschen
                tst.w   menü_titel(A4)  ;Menü aktiv?
                bpl.s   tastchk1        ;dann alles ignorieren
                sf      s_left_right(A4)
                move    #$FF,CCR
tastchk1:       rts                     ;negative gesetzt=Taste gedrückt
                ENDPART

************************************************************************
* Ein paar globale Ausgaben                                            *
************************************************************************
                >PART 'print_line' ;String auf dem Stack ausgeben bis zum Nullbyte
************************************************************************
* Text auf dem Stack bis zum Nullbyte ausgeben                         *
************************************************************************
print_line:     movem.l D0-A6,-(SP)
                movea.l 64(SP),A6       ;Anfangsadresse des Textes
printl1:        move.b  (A6)+,D0
                beq.s   printl2
                cmp.b   #13,D0
                bne.s   printl3
                bsr.s   crout
                bra.s   printl1
printl3:        bsr.s   chrout
                bra.s   printl1
printl2:        movem.l (SP)+,D0-A6
                move.l  (SP)+,(SP)      ;Returnadresse über Stringadresse kopieren
                rts
                ENDPART
                >PART 'crout'   ;Cursor in die nächste Zeile
crout:          movem.l D0-A6,-(SP)
                bsr.s   chr_cr
                movem.l (SP)+,D0-A6
                rts
                ENDPART
                >PART 'chrout'  ;Zeichen in D0 ausgeben (evtl. in Buffer)
************************************************************************
* Zeichen in D0 ausgeben                                               *
************************************************************************
chrout1:        move.b  D0,(A0)+        ;Zeichen in Ausgabebuffer
chrout2:        rts
chrout:         tst.b   testwrd(A4)     ;Ausgabe in den Buffer?
                bne.s   chrout1         ;Ja!
                tst.b   D0
                beq.s   chrout2         ;Nullbytes werden nicht ausgegeben
                and.w   #$FF,D0
                bsr     char_out        ;Zeichen ausgeben
                addq.w  #1,spalte(A4)   ;Cursor eine Spalte weiter
                move.w  spalte(A4),D0
                IF slider
                move.w  D1,-(SP)
                move.w  sdrv_maxcur_x(A4),D1
                sub.w   #slsize,D1
                cmp.w   D1,D0
                movem.w (SP)+,D1
                ELSE
                cmp.w   sdrv_maxcur_x(A4),D0 ;max.Spalte erreicht?
                ENDC
                ble.s   chr_cr1         ;Nein! =>
chr_cr:         clr.w   spalte(A4)      ;Spalte = 0
                addq.w  #1,zeile(A4)    ;Zeile erhöhen
                move.w  sdrv_zanz(A4),D0
                cmp.w   zeile(A4),D0    ;max.Zeile erreicht?
                bhs.s   chr_cr1         ;Nein! =>
                move.w  D0,zeile(A4)    ;in der letzten Zeile bleiben
                bra     scroll_up       ;und hochscrollen
chr_cr1:        rts
                ENDPART
                >PART 'c_bell'  ;Bell
c_bell:         lea     bell_data(PC),A0
                bra     do_sound        ;Pling!
                ENDPART
                >PART 'c_clrhome' ;Bildschirm löschen
c_clrhome:      bsr     clr_maus
                movem.l D0-D3/A0,-(SP)
                movea.l sdrv_scrbase(A4),A0
                move.w  sdrv_maxcur_x(A4),D0
                addq.w  #1,D0
                mulu    sdrv_planes(A4),D0
                move.w  sdrv_loffset(A4),D2
                sub.w   D0,D2           ;Offset auf die nächste Zeile
                bne.s   c_clrhome1      ;OverScan, o.ä. =>
                move.w  sdrv_maxcur_y(A4),D1
                addq.w  #1,D1
                mulu    sdrv_offset(A4),D1 ;Größe des Bildschirmspeichers
                moveq   #0,D0           ;Füllbyte
                bsr     MemFill         ;Bildschirm löschen
                bra.s   c_clrhome4
c_clrhome1:     subq.w  #1,D0
                move.w  sdrv_max_y(A4),D1
c_clrhome2:     move.w  D0,D3
c_clrhome3:     clr.b   (A0)+           ;eine Rasterzeile löschen
                dbra    D3,c_clrhome3
                adda.w  D2,A0
                dbra    D1,c_clrhome2
c_clrhome4:     bsr     set_maus
                movea.l sdrv_tscradr(A4),A0
                move.w  sdrv_maxcur_y(A4),D1
                addq.w  #1,D1
                mulu    sdrv_loffset(A4),D1 ;Zeichen auf dem Screen
                moveq   #' ',D0
                bsr     MemFill         ;Textscreen löschen
                clr.l   zeile(A4)
                movem.l (SP)+,D0-D3/A0
                rts
                ENDPART
                >PART 'light_char' ;Zeichen D0 an Cursorposition (mit Extras)
************************************************************************
* Zeichen D0 an Cursorposition ausgeben (D1=Lightmaske, D2=XOR-wert)   *
************************************************************************
light_char:     movem.l D0-A1,-(SP)
                move.w  D0,D4
                lsr.w   #8,D4           ;Negativ.B? => Fett/Klein
                and.w   #$FF,D0
                movea.l sdrv_akt_font(A4),A0 ;Fontadresse
                adda.w  D0,A0           ;plus ASCII-Code (= Zeichenadr)
                move.w  D0,-(SP)        ;ASCII-Code retten
                move.w  D1,D6
                move.w  D2,D7
                move.w  D3,D5
                movea.l sdrv_scrbase(A4),A1
                move.w  zeile(A4),D2
                addq.w  #menu_offset,D2
                mulu    sdrv_offset(A4),D2
                adda.l  D2,A1           ;+ Bildschirmadresse
                move.w  spalte(A4),D3
                moveq   #1,D0
                and.w   D3,D0
                adda.w  D0,A1           ;+ (Spalte and 1)
                eor.w   D0,D3
                move.w  sdrv_plnshift(A4),D0
                lsl.w   D0,D3
                adda.w  D3,A1           ;+ (Spalte and -2) * 2
                move.w  sdrv_cheight(A4),D1 ;Zeilenanzahl
                subq.w  #1,D1
                move.w  #$0100,D2       ;Offset für den Zeichensatz
                move.w  sdrv_loffset(A4),D3 ;Offset für den Bildschirm
                move.w  (SP)+,D0        ;ASCII-Code von oben wieder zurück
                tst.b   D4              ;bes.Attribut
                bmi.s   light_char5     ;Klein? dann dorthin
                bne.s   light_char3     ;Fett? dann dorthin
light_char1:    move.b  (A0),D0         ;Aus dem Font holen
                and.b   D6,D0           ;light
                eor.b   D7,D0           ;invers
                tst.w   D1
                bne.s   light_char2
                or.b    D5,D0           ;Unterline
light_char2:    move.b  D0,(A1)         ;auf den Screen
                adda.w  D2,A0
                adda.w  D3,A1
                rol.b   #1,D6           ;Maske rotieren
                dbra    D1,light_char1
                movem.l (SP)+,D0-A1
                rts
light_char3:    move.b  (A0),D0         ;Aus dem Font holen
                move.b  D0,D4
                lsr.b   #1,D4           ;Zeichen ein Bit nach rechts
                or.b    D4,D0           ;und wieder einsetzen => Fett
                and.b   D6,D0           ;light
                eor.b   D7,D0           ;invers
                tst.w   D1
                bne.s   light_char4
                or.b    D5,D0           ;Unterline
light_char4:    move.b  D0,(A1)         ;auf den Screen
                adda.w  D2,A0
                adda.w  D3,A1
                rol.b   #1,D6           ;Maske rotieren
                dbra    D1,light_char3
                movem.l (SP)+,D0-A1
                rts
light_char5:    movea.l sdrv_sml_font(A4),A0 ;Zeiger auf den kleinen Font
                move.w  82(A0),D1       ;Fonthöhe aus dem Zeichensatz
                move.w  80(A0),D2       ;Breite des Zeichensatz-Image (256)
                movea.l 76(A0),A0       ;Zeiger auf das Font-Image
                adda.w  D0,A0           ;ASCII-Code des Zeichens dazu
                cmp.w   sdrv_cheight(A4),D1 ;Fonthöhe schon erreicht?
                blo.s   light_char9     ;Nein, ist kleiner =>
                add.w   D2,D2           ;Breite vom Zeichensatz-Image verdoppeln
                lsr.w   #1,D1           ;Fonthöhe halbieren
light_char9:    subq.w  #1,D1
                move.w  D1,-(SP)
light_char6:    move.b  (A0),D0         ;Aus dem Font holen
                and.b   D6,D0           ;light
                eor.b   D7,D0           ;invers
                move.b  D0,(A1)         ;auf den Screen
                adda.w  D2,A0
                adda.w  D3,A1
                rol.b   #1,D6           ;Maske rotieren
                dbra    D1,light_char6
                move.w  (SP)+,D1        ;Die restlichen 8 Zeilen
light_char7:    move.b  D7,D0           ;invers?
                tst.w   D1
                bne.s   light_char8
                or.b    D5,D0           ;Unterline
light_char8:    move.b  D0,(A1)         ;auf den Screen
                adda.w  D3,A1
                dbra    D1,light_char7
                movem.l (SP)+,D0-A1
                rts
                ENDPART
                >PART 'char_out' ;Zeichen D0 auf den Screen
************************************************************************
* Asc-Zeichen in D0 auf Bildschirm                                     *
************************************************************************
char_out:       movem.l D0-D3/A0-A1,-(SP)
                bsr     clr_maus
                bsr.s   calc_crsr
                move.b  D0,(A0)         ;ASCII-Zeichen einsetzen
                movea.l sdrv_akt_font(A4),A0 ;Fontadresse
                adda.w  D0,A0           ;plus ASCII-Code (= Zeichenadr)
                mulu    sdrv_cheight(A4),D2
                movea.l sdrv_scrbase(A4),A1
                adda.l  D2,A1           ;+ Bildschirmadresse
                moveq   #1,D1
                and.w   D3,D1
                adda.w  D1,A1           ;+ (Spalte and 1)
                eor.w   D1,D3
                move.w  sdrv_plnshift(A4),D1
                lsl.w   D1,D3
                adda.w  D3,A1           ;+ Cursorspalte
                move.w  #$0100,D2
                move.w  sdrv_loffset(A4),D3
                move.w  sdrv_cheight(A4),D0
                subq.w  #2,D0
char_out1:      move.b  (A0),(A1)
                adda.w  D2,A0
                adda.w  D3,A1
                dbra    D0,char_out1
                move.b  (A0),D0
                tst.w   zeile(A4)
                bpl.s   char_out2
                moveq   #-1,D0
char_out2:      move.b  D0,(A1)
                bsr     set_maus
                movem.l (SP)+,D0-D3/A0-A1
                rts
                ENDPART
                >PART 'calc_crsr' ;Cursorposition errechnen
************************************************************************
* Cursorposition errechnen (Zeiger in A0)                              *
************************************************************************
calc_crsr:      movea.l sdrv_tscradr(A4),A0
                move.w  zeile(A4),D2
                addq.w  #menu_offset,D2
                mulu    sdrv_loffset(A4),D2
                move.w  spalte(A4),D3
                adda.w  D2,A0
                adda.w  D3,A0
                rts
                ENDPART
                >PART 'draw_line' ;Linien auf dem Screen neuzeichnen
************************************************************************
* Draw line                                                            *
************************************************************************
draw_lines:     movem.l D0-D1/A0,-(SP)
                bsr     clr_maus
                moveq   #1,D0
                bsr.s   draw_lines1     ;erste Zeile unterstreichen
                moveq   #2,D0
                bsr.s   draw_lines1     ;zweite Zeile unterstreichen
                bsr     set_maus
                movem.l (SP)+,D0-D1/A0
                rts
draw_lines1:    mulu    sdrv_cheight(A4),D0 ;mal Zeichenhöhe
                subq.w  #1,D0           ;minus 1 für Unterstreichen
                mulu    sdrv_loffset(A4),D0 ;Zeilenoffset
                movea.l sdrv_scrbase(A4),A0
                adda.l  D0,A0           ;Zeilenadresse
                move.w  sdrv_maxcur_x(A4),D1 ;Zeichen pro Zeile
                addq.w  #1,D1
                lsr.w   #1,D1           ;Words pro Zeile
                subq.w  #1,D1
                moveq   #-1,D0
draw_lines2:    move.w  D0,(A0)+
                adda.w  sdrv_poffset(A4),A0
                dbra    D1,draw_lines2
                rts
                ENDPART
                >PART 'update_line' ;Zeile D0 neu ausgeben
update_line:    movem.l D0/A0-A1,-(SP)
                lea     mark_tab(A4),A1
                sf      0(A1,D0.w)      ;Zeile ist nicht markiert
                addq.w  #menu_offset,D0
                mulu    sdrv_loffset(A4),D0
                movea.l sdrv_tscradr(A4),A0
                adda.w  D0,A0           ;Adresse der Bildschirmzeile
                lea     normal_font(A4),A1
                bsr.s   uline_out
                movem.l (SP)+,D0/A0-A1
                rts
                ENDPART
                >PART 'update_mline' ;markierte Zeile D0 neu ausgeben
update_mline:   movem.l D0/A0-A1,-(SP)
                lea     mark_tab(A4),A1
                st      0(A1,D0.w)      ;Zeile ist markiert
                movea.l sdrv_tscradr(A4),A0
                addq.w  #menu_offset,D0
                mulu    sdrv_loffset(A4),D0
                adda.w  D0,A0           ;Adresse der Bildschirmzeile
                lea     block_font(A4),A1
                bsr.s   uline_out
                movem.l (SP)+,D0/A0-A1
                rts
                ENDPART
                >PART 'uline_out' ;Zeile A0,D0 im Font A1 neu ausgeben
uline_out:      movem.l D0-D4/A2-A3,-(SP)
                bsr     clr_maus
                movea.l sdrv_scrbase(A4),A2 ;Basisadresse des Bildschirms
                mulu    sdrv_cheight(A4),D0 ;Höhe eines Buchstabens
                adda.l  D0,A2           ;Zeiger auf die Bitmap
                move.w  sdrv_maxcur_x(A4),D1 ;max.Zeilenbreite minus 1
                IF slider
                sub.w   #slsize,D1
                ENDC
                moveq   #0,D3           ;kein Plane-Offset am Zeilenanfang
                move.w  sdrv_poffset(A4),D4 ;Plane-Offset = 0 (bei s/w)
uline_out1:     moveq   #0,D0
                move.b  (A0)+,D0        ;Zeichen aus dem String holen
                mulu    sdrv_cheight(A4),D0
                lea     0(A1,D0.w),A3
                move.b  (A3)+,(A2)+
uline_out2:     move.b  (A3)+,79(A2)
                move.b  (A3)+,159(A2)
                move.b  (A3)+,239(A2)
                move.b  (A3)+,319(A2)
                move.b  (A3)+,399(A2)
                move.b  (A3)+,479(A2)
                move.b  (A3)+,559(A2)
                move.b  (A3)+,639(A2)
                move.b  (A3)+,719(A2)
                move.b  (A3)+,799(A2)
                move.b  (A3)+,879(A2)
                move.b  (A3)+,959(A2)
                move.b  (A3)+,1039(A2)
                move.b  (A3)+,1119(A2)
                move.b  (A3),1199(A2)
                not.w   D3              ;Plane-Offset?
                bne.s   uline_out3      ;Nein! =>
                adda.w  D4,A2
uline_out3:     dbra    D1,uline_out1   ;Zeile voll?
                bsr     set_maus
                movem.l (SP)+,D0-D4/A2-A3 ;dann direkt raus
                rts
                ENDPART
                >PART 'write_line' ;String A0 in Zeile D0 normal ausgeben
************************************************************************
* gibt eine normale Zeile ab A0 aus                                    *
************************************************************************
write_line:     movem.l D5-A1,-(SP)
                moveq   #$00,D5
                moveq   #$00,D6         ;Zeilenende nicht markieren
                moveq   #$00,D7
                lea     mark_tab(A4),A1
                sf      0(A1,D0.w)      ;Zeile ist nicht markiert
                lea     normal_font(A4),A1
                bsr.s   line_out
                movem.l (SP)+,D5-A1
                rts
                ENDPART
                >PART 'write_mline' ;String A0 in Zeile D0 markiert ausgeben
************************************************************************
* gibt eine markierte Zeile ab A0 aus                                  *
************************************************************************
write_mline:    movem.l D5-A1,-(SP)
                moveq   #$44,D5
                moveq   #$00,D6         ;Zeilenende markieren
                moveq   #$11,D7
                lea     mark_tab(A4),A1
                st      0(A1,D0.w)      ;Zeile ist markiert
                lea     block_font(A4),A1
                bsr.s   line_out
                movem.l (SP)+,D5-A1
                rts
                ENDPART
                >PART 'line_out' ;String A0 im Font A1 in Zeile D0 ausgeben
************************************************************************
* Text ab A0 im Font A1 ausgeben                                       *
* D0 - Zeile (-2 bis 21)                                               *
************************************************************************
line_out:       movem.l D0-D4/A2-A3/A5,-(SP)
                bsr     clr_maus
                addq.w  #menu_offset,D0 ;die Menüleiste
                mulu    sdrv_loffset(A4),D0 ;Zeilenoffset (z.B. 80)
                movea.l sdrv_tscradr(A4),A3 ;Zeiger auf das Hintergrundram
                adda.w  D0,A3           ;Zeiger auf den Hintergrundbuffer
                movea.l sdrv_scrbase(A4),A2 ;Basisadresse des Bildschirms
                mulu    sdrv_cheight(A4),D0 ;Höhe eines Buchstabens
                adda.l  D0,A2           ;Zeiger auf die Bitmap
                move.w  sdrv_maxcur_x(A4),D1 ;max.Zeilenbreite minus 1
                IF slider
                sub.w   #slsize,D1      ;für den Slider
                ENDC
                moveq   #0,D3           ;kein Plane-Offset am Zeilenanfang
                move.w  sdrv_poffset(A4),D4 ;Plane-Offset = 0 (bei s/w)
line_out1:      moveq   #0,D0
                move.b  (A0)+,D0        ;Zeichen aus dem String holen
                beq.s   line_out4       ;Stringende =>
                move.b  D0,(A3)+        ;in das Hintergrundram
                mulu    sdrv_cheight(A4),D0
                lea     0(A1,D0.w),A5
                move.b  (A5)+,(A2)+
line_out2:      move.b  (A5)+,79(A2)
                move.b  (A5)+,159(A2)
                move.b  (A5)+,239(A2)
                move.b  (A5)+,319(A2)
                move.b  (A5)+,399(A2)
                move.b  (A5)+,479(A2)
                move.b  (A5)+,559(A2)
                move.b  (A5)+,639(A2)
                move.b  (A5)+,719(A2)
                move.b  (A5)+,799(A2)
                move.b  (A5)+,879(A2)
                move.b  (A5)+,959(A2)
                move.b  (A5)+,1039(A2)
                move.b  (A5)+,1119(A2)
                move.b  (A5),1199(A2)
                not.w   D3              ;Plane-Offset?
                bne.s   line_out3       ;Nein! =>
                adda.w  D4,A2
line_out3:      dbra    D1,line_out1    ;Zeile voll?
                bsr     set_maus
                movem.l (SP)+,D0-D4/A2-A3/A5 ;dann direkt raus
                rts

line_out4:      moveq   #' ',D2
line_out5:      move.b  D2,(A3)+        ;in das Hintergrundram
                move.b  D5,(A2)+
line_out6:      move.b  D6,79(A2)
                move.b  D7,159(A2)
                move.b  D6,239(A2)
                move.b  D5,319(A2)
                move.b  D6,399(A2)
                move.b  D7,479(A2)
                move.b  D6,559(A2)
                move.b  D5,639(A2)
                move.b  D6,719(A2)
                move.b  D7,799(A2)
                move.b  D6,879(A2)
                move.b  D5,959(A2)
                move.b  D6,1039(A2)
                move.b  D7,1119(A2)
                move.b  D6,1199(A2)
                not.w   D3              ;Plane-Offset?
                bne.s   line_out7       ;Nein! =>
                adda.w  D4,A2
line_out7:      dbra    D1,line_out5    ;Zeilenrest gelöscht? Nein! =>
                bsr     set_maus
                movem.l (SP)+,D0-D4/A2-A3/A5 ;dann direkt raus
                rts
                ENDPART
                >PART 'scroll_dn' ;Bildschirm um eine Zeile nach unten
************************************************************************
* Bildschirm um eine Zeile runterscrollen                              *
************************************************************************
scroll_dn:      movem.l D0-D3/A0-A1,-(SP)
                bsr     clr_maus        ;Maus wieder an
                move.w  sdrv_zanz(A4),D1 ;Destinationzeile
                move.w  D1,D0
                subq.w  #1,D0           ;Sourcezeile
scroll_dn1:     bsr.s   copy_line
                subq.w  #1,D1
                subq.w  #1,D0
                bpl.s   scroll_dn1
                bsr     set_maus        ;Maus wieder an
                movem.l (SP)+,D0-D3/A0-A1
                rts
                ENDPART
                >PART 'scroll_up' ;Bildschirm um eine Zeile nach oben
************************************************************************
* Bildschirm um eine Zeile hochscrollen                                *
************************************************************************
scroll_up:      move.l  D0,-(SP)
                moveq   #0,D0           ;ab Zeile 0 hochscrollen
                bsr.s   scroll_up2
                move.l  (SP)+,D0
                rts
                ENDPART
                >PART 'scroll_up2' ;Bildschirm ab D0 nach oben
************************************************************************
* Bildschirm ab D0 um eine Zeile hochscrollen                          *
************************************************************************
scroll_up2:     movem.l D0-D3/A0-A1,-(SP)
                bsr     clr_maus        ;Maus wieder an
                move.w  D0,D1           ;Zielzeile
                addq.w  #1,D0           ;Sourcezeile
                bra.s   scroll_up22
scroll_up21:    bsr.s   copy_line
                addq.w  #1,D0
                addq.w  #1,D1
scroll_up22:    cmp.w   sdrv_zanz(A4),D0
                bls.s   scroll_up21
                bsr     set_maus        ;Maus wieder an
                movem.l (SP)+,D0-D3/A0-A1
                rts
                ENDPART
                >PART 'copy_line' ;Zeile D0 nach D1 kopieren
copy_line:      movem.l D0-D3/A0-A1,-(SP)
                lea     mark_tab(A4),A0
                move.b  0(A0,D0.w),0(A0,D1.w) ;Markierungs-Flag kopieren
                clr.b   0(A0,D0.w)      ;die alte Zeile ist damit nicht mehr markiert
                addq.w  #menu_offset,D0
                addq.w  #menu_offset,D1
                mulu    sdrv_loffset(A4),D0 ;mal Zeilenbreite
                mulu    sdrv_loffset(A4),D1
                movem.l D0-D1,-(SP)
                mulu    sdrv_cheight(A4),D0 ;mal 16
                mulu    sdrv_cheight(A4),D1 ;mal 16
                movea.l sdrv_scrbase(A4),A0
                lea     0(A0,D1.l),A1   ;Adresse der Destinationzeile
                adda.l  D0,A0           ;Adresse der Sourcezeile
                IF slider
                ENDC
                move.w  sdrv_offset(A4),D0
                ext.l   D0              ;Anzahl der Bytes (z.B. 1280)
                bsr     MemMove         ;Block verschieben
                movem.l (SP)+,D0-D1
                movea.l sdrv_tscradr(A4),A0 ;Zeiger auf den ASCII-Screen berechnen
                lea     0(A0,D1.w),A1
                adda.w  D0,A0
                move.w  sdrv_maxcur_x(A4),D0
                addq.w  #1,D0
                ext.l   D0
                bsr     MemMove
                movem.l (SP)+,D0-D3/A0-A1
                rts
                ENDPART
                >PART 'menüchk' ;Menübaum verwalten
************************************************************************
* Menübaum verwalten                                                   *
************************************************************************
menüchk:        move.w  sel_menü_titel(A4),D0
                bmi.s   menüchk3        ;keine Funktion angewählt
                tst.b   D0
                bmi.s   menüchk3
                lea     menü_tab(PC),A0
menüchk1:       tst.w   (A0)
                bmi.s   menüchk3        ;Tabelle abgrasen
                cmp.w   (A0)+,D0
                beq.s   menüchk2
                addq.l  #4,A0
                bra.s   menüchk1
menüchk2:       move.b  sel_menü_titel(A4),D0
                move.w  #-1,sel_menü_titel(A4)
                sf      s_left_right(A4) ;Linke Taste gedrückt
                move.l  (A0)+,D0        ;Tastencode holen
                move    #$FF,CCR        ;Was gefunden?
                rts
menüchk3:       move    #0,CCR          ;Nix los
                rts
                ENDPART
                >PART 'object_do' ;Baum A0 zeichnen und max. D0 Sek. warten
************************************************************************
* Objektbaum ab A0 zeichnen und auf Maus, Tastatur max.D0 Sek warten   *
************************************************************************
object_do:      movem.l D0-A6,-(SP)
                move.l  D0,D6
                mulu    #200,D6         ;mal 200Hz
                bsr     _objc_draw      ;Baum zeichnen
                bsr     clr_maus
                add.l   $04BA.w,D6
                move.l  mausx(A4),D7    ;X & Y holen!!!
object_do1:     cmp.l   $04BA.w,D6
                blo.s   object_do2      ;Weiter geht's
                cmp.l   mausx(A4),D7
                bne.s   object_do2      ;Maus wurde bewegt!
                bsr     tastchk         ;Tastencode holen
                bpl.s   object_do1      ;Taste wurde gedrückt
object_do2:     jsr     redraw_all
                bsr     set_maus
                movem.l (SP)+,D0-A6
                rts
                ENDPART
                >PART 'form_do' ;Baum ab A0 ausführen
************************************************************************
* form_do ab A0 ausführen                                              *
************************************************************************
_form_do:       movem.l D1-A6,-(SP)
                move.l  zeile(A4),-(SP)
                addq.b  #1,set_lock(A4) ;Cursorsetzen im VBL verhindern
                st      no_dklick(A4)   ;Kein Doppelklick
                move.w  curflag(A4),-(SP)
                bsr     cursor_off
                suba.l  A5,A5           ;aktuelle Buttonadr löschen
                movea.l A0,A1
                bsr     desel_abutt     ;Alle Exit-Buttons deselektieren
                moveq   #0,D0
                lea     -10(A1),A2
form_do1:       lea     10(A2),A2       ;Nächster Eintrag
                tst.w   (A2)
                bmi.s   form_do3        ;Nichts gefunden
                btst    #3,9(A2)        ;Text?
                beq.s   form_do1        ;kein Text
                btst    #7,9(A2)        ;Editierbar
                beq.s   form_do1        ;Nein
                moveq   #-1,D0
                movea.l 4(A2),A3        ;Adresse der Eingabedaten
                cmpi.b  #$FF,(A3)       ;Eingabefeld löschen?
                bne.s   form_do1
form_do2:       move.b  #' ',(A3)+      ;Eingabefeld löschen
                tst.b   (A3)
                bne.s   form_do2
                bra.s   form_do1
form_do3:       btst    #7,8(A1)        ;nur ein redraw?
                bne.s   form_do4
                move.b  #1,9(A1)        ;Hintergrund löschen
form_do4:       bsr     _objc_draw      ;Baum zeichnen
                move.b  #2,9(A1)        ;bei Redraw nur den Rahmen
                suba.l  A3,A3           ;Zeiger auf akt.Edit-Objekt
                lea     -10(A1),A0
                clr.b   no_cursor(A4)
                tst.w   D0
                bne.s   form_do5
                st      no_cursor(A4)   ;Damit der Cursor aus bleibt
form_do5:       lea     10(A0),A0       ;Nächster Eintrag (Flags unbeeinflußt)
                tst.w   (A0)
                bmi.s   form_do7        ;Nichts gefunden
                btst    #3,9(A0)        ;Text?
                beq.s   form_do5        ;Kein Text gefunden
                btst    #7,9(A0)        ;Editierbar?
                beq.s   form_do5        ;Nein
                movea.l A0,A3           ;Zeiger auf aktuelles Edit-Obj
                bsr     calc_cur_anf    ;Cursor an den Anfang der Eingabemaske
                move.w  D0,spalte(A4)
                move.w  D1,zeile(A4)
                bsr     cursor_on
                bra.s   form_do7
form_do6:       bsr     c_bell          ;bell
form_do7:       bsr     print_time      ;Uhrzeit updaten
                btst    #1,maustast(A4) ;Linke Taste gedrückt?
                beq     form_do21       ;Nein!
                clr.b   mausprell(A4)   ;merken, daß gedrückt wird
                bsr     find_etext      ;Maus über einem Text?
                bne.s   form_do12       ;Nein!
                movea.l A0,A3           ;Zeiger auf aktuelles Edit-Obj
                subq.l  #1,A2
                cmpi.b  #' ',-(A2)
                bne.s   form_do10       ;Falls das letzte Zeichen kein ' '
                addq.l  #1,A2
                sub.w   (A3),D0         ;Position im Eingabefeld
                movea.l 4(A3),A0        ;Zeiger auf den Eingabestring
                move.w  D7,D3
                moveq   #0,D2
form_do8:       cmpa.l  A0,A2
                beq.s   form_do9        ;Ganzes Eingabefeld leer?
                cmpi.b  #' ',-(A2)
                beq.s   form_do8
                suba.l  A0,A2
                move.w  A2,D2
                addq.w  #1,D2
                cmp.w   D2,D0
                blo.s   form_do10
form_do9:       bsr     calc_cur_anf
                add.w   D2,D0
                move.w  D0,D6
                move.w  D3,D7
form_do10:      cmp.w   spalte(A4),D6
                bne.s   form_do11
                cmp.w   zeile(A4),D7    ;Koordinaten immer noch gleich
                beq.s   form_do7
form_do11:      bsr     cursor_off      ;Cursor aus
                move.w  D6,spalte(A4)   ;Cursor neu setzen
                move.w  D7,zeile(A4)
                bsr     cursor_on       ;Cursor wieder an
                bra.s   form_do7

form_do12:      bsr     find_button     ;Maus über einem Button?
form_do13:      bne.s   form_do17       ;Nein!
                move.l  A5,D0
                beq.s   form_do14
                btst    #5,9(A5)        ;Exit-Button?
                beq.s   form_do14       ;Ja!
                btst    #0,9(A5)        ;selektiert?
                bne.s   form_do14       ;ja, alles OK
                bsr     desel_abutt     ;Exit-Buttons deselektieren
                suba.l  A5,A5           ;Kein aktueller Button mehr
form_do14:      cmpa.l  A0,A5           ;immer noch der gleiche Button?
                beq     form_do7        ;dann ignorieren
                btst    #6,9(A0)        ;Radio-Button?
                bne.s   form_do18       ;Ja! => Sonderbehandlung
                bchg    #0,9(A0)        ;Button selektieren/deselektieren
form_do15:      movea.l A0,A5           ;Buttonnummer merken
                movea.l A1,A0           ;Zeiger auf den Objektbaum
                bsr     _objc_draw      ;Baum neu zeichnen
                tst.b   no_cursor(A4)
                bne.s   form_do16
                bsr     cursor_on
form_do16:      bra     form_do7
form_do17:      bsr     desel_abutt     ;Exit-Buttons deselektieren
                suba.l  A0,A0
                move.l  A5,D0           ;kein aktueller Button da?
                beq     form_do7        ;dann auch nicht neuzeichnen
                bra.s   form_do15
form_do18:      moveq   #0,D0
                move.b  8(A0),D0        ;Die Radio-Button Nummer
                movem.l A0,-(SP)
                movea.l A1,A0
form_do19:      tst.w   (A0)            ;Baum zuende?
                bmi.s   form_do20       ;Ja!
                lea     10(A0),A0       ;Zeiger auf nächstes Objekt
                btst    #6,-1(A0)       ;Radio-Button?
                beq.s   form_do19       ;Nein? => Nicht deselektieren
                cmp.b   -2(A0),D0       ;ist's der entspr.Radio-Button?
                bne.s   form_do19       ;Nein? => Nicht deselektieren
                bclr    #0,-1(A0)       ;deselect Button
                bra.s   form_do19       ;Weiter suchen
form_do20:      movem.l (SP)+,A0
                bset    #0,9(A0)        ;Button selektieren
                bra.s   form_do15

form_do21:      tas.b   mausprell(A4)   ;Wurde die Taste losgelassen?
                bne.s   form_do24       ;Nö => Ende
                bsr     find_button     ;Button unter der Maus?
                beq.s   form_do23       ;Ja => evtl.Exit
                bsr     desel_abutt     ;Exit-Buttons deselektieren
                movea.l A1,A0           ;Zeiger auf den Objektbaum
                bsr     _objc_draw      ;Baum neu zeichnen
                tst.b   no_cursor(A4)
                bne.s   form_do22
                bsr     cursor_on
form_do22:      bsr     find_etext      ;Edt.Text unter der Maus?
                beq     form_do7        ;Ja => alles OK
                move.l  A5,D0
                beq     form_do6        ;Es wurde kein Button selektiert
                bra     form_do7        ;Weiter geht's
form_do23:      move.l  A5,D0
                beq.s   form_do22
                btst    #5,9(A5)        ;Exit-Button?
                beq.s   form_do22       ;Nein => Weiter geht's
                bra     form_exit       ;Ende

form_do24:      suba.l  A5,A5           ;aktuelle Buttonadr löschen
                bsr     tastchk
                bpl     form_do7        ;Keine Taste gedrückt
                moveq   #24+3,D1
                btst    D1,D0           ;Alternate
                beq.s   form_do29       ;Nein! =>
                cmp.w   #'A',D0
                blo.s   form_do29       ;kleiner als 'A', dat geht nicht
                cmp.w   #'Z',D0
                bls.s   form_do25       ;größer als 'Z' geht auch nit
                cmp.w   #'a',D0
                blo.s   form_do29       ;Kleinbuchstaben gehen auch
                cmp.w   #'z',D0
                bhi.s   form_do29
                sub.w   #32,D0
form_do25:      sub.w   #'A',D0
                moveq   #0,D2           ;Button Nr löschen
                movea.l A1,A0
form_do26:      tst.w   (A0)
                bmi.s   form_do27       ;Nichts gefunden
                lea     10(A0),A0       ;Nächster Eintrag (Flags unbeeinflußt)
                btst    #2,-1(A0)       ;Button?
                beq.s   form_do26       ;Kein Button
                addq.w  #1,D2           ;Button-Nr erhöhen
                dbra    D0,form_do26
                btst    #4,-1(A0)       ;disabled?
                bne.s   form_do27       ;Ja, dann Ende
                btst    #5,-1(A0)       ;Exit-Button?
                bne     form_return2    ;dann raus
                lea     -10(A0),A0
                move    #$FF,CCR        ;Button gefunden
                bra.s   form_do28
form_do27:      moveq   #0,D2           ;Kein Button selektiert
                move    #0,CCR
form_do28:      bra     form_do13

form_do29:      bsr     cursor_off
                cmp.w   #13,D0          ;Return
                beq     form_return     ;Default-Button suchen
                swap    D0
                cmp.b   #$61,D0         ;UNDO
                beq     form_abort
                move.l  A3,D1
                beq     form_do6        ;Kein Edit-Objekt da
                cmp.b   #$48,D0         ;Cursor up
                beq     form_up
                cmp.b   #$50,D0         ;Cursor down
                beq     form_down
                cmp.b   #$4B,D0         ;Cursor left
                beq     form_left
                cmp.b   #$4D,D0         ;Cursor right
                beq     form_right
                cmp.b   #$47,D0         ;Clr Home
                beq     form_home
                swap    D0
                cmp.w   #9,D0           ;Tab = Cursor down
                beq     form_down
                cmp.w   #27,D0          ;ESC
                beq     form_clr        ;Eingabefeld löschen
                cmp.w   #$7F,D0         ;Delete
                beq     form_delete
                cmp.w   #8,D0           ;Backspace
                beq     form_backspc
                moveq   #24+2,D1
                btst    D1,D0           ;Control
                bne.s   form_do35       ;=> keine Taste gedrückt
                cmp.w   #32,D0
                blo.s   form_do35       ;Steuerzeichen ignoriern
                btst    #5,9(A3)        ;"Exit" bei editable-Text?
                beq.s   form_do30       ;=> nur Ziffern erlaubt
                cmp.b   #'0',D0
                blo.s   form_do35       ;nur Ziffern sind legal!
                cmp.b   #'9',D0
                bhi.s   form_do35
form_do30:      move.w  D0,D3           ;Zeichencode retten
                bsr     calc_cur_anf
                move.w  D0,-(SP)        ;1.Spalte der Eingabemaske merken
                move.w  spalte(A4),D1
                sub.w   D0,D1           ;Position des Cursors im String
                movea.l 4(A3),A0        ;Zeiger auf den String
                moveq   #-1,D0
form_do31:      addq.w  #1,D0
                tst.b   (A0)+           ;Länge des Eingabefeldes ermitteln
                bne.s   form_do31
                subq.l  #2,A0
                move.w  D0,D2
                add.w   (SP)+,D2
                subq.w  #1,D2
                cmp.w   spalte(A4),D2
                beq.s   form_do33       ;max.Breite erreicht
                addq.w  #1,spalte(A4)
                sub.w   D1,D0
                subq.w  #2,D0
form_do32:      move.b  -(A0),1(A0)
                dbra    D0,form_do32
form_do33:      move.b  D3,(A0)         ;Zeichen einsetzen
                movea.l A1,A0           ;Zeiger auf den Objektbaum
                bsr     _objc_draw      ;Baum neu zeichnen
form_do34:      bsr     cursor_on
                bra     form_do7        ;Keine Taste gefunden
form_do35:      bsr     cursor_on
                bra     form_do6        ;Pling!

;Abbruch
form_abort:     sf      no_dklick(A4)
                jsr     redraw_all      ;Bildschirm neu aufbauen
                move.w  (SP)+,curflag(A4)
                btst    #6,curflag(A4)
                beq.s   form_abort1
                bsr     flash_cursor
form_abort1:    sf      no_dklick(A4)   ;Doppelklick wieder erlauben
                subq.b  #1,set_lock(A4) ;Cursor darf wieder im VBL gesetzt werden
                move.l  (SP)+,zeile(A4)
                movem.l (SP)+,D1-A6
                moveq   #-1,D0          ;Abort
                rts

;Ende
form_exit:      jsr     redraw_all      ;Bildschirm neu aufbauen
                move.w  D2,D0
                move.w  (SP)+,curflag(A4)
                btst    #6,curflag(A4)
                beq.s   form_exit1
                bsr     flash_cursor
form_exit1:     sf      no_dklick(A4)   ;Doppelklick wieder erlauben
                subq.b  #1,set_lock(A4) ;Cursor darf wieder im VBL gesetzt werden
                move.l  (SP)+,zeile(A4)
                movem.l (SP)+,D1-A6
                tst.w   D0              ;Flags setzen
                rts

; Return = Defaultbutton selektieren + Ende
form_return:    moveq   #0,D2           ;Button Nr löschen
                movea.l A1,A0
form_return1:   tst.w   (A0)
                bmi.s   form_return3    ;Kein Default-Button
                lea     10(A0),A0       ;Zeiger auf nächstes Element
                btst    #2,-1(A0)
                beq.s   form_return1    ;Kein Button
                addq.w  #1,D2           ;Button-Nr erhöhen
                btst    #1,-1(A0)       ;Default-Button?
                beq.s   form_return1
                btst    #4,-1(A0)       ;Disabled?
                bne.s   form_return1    ;das war wohl nichts
form_return2:   bsr     desel_abutt     ;deselect all buttons
                bset    #0,-(A0)
                movea.l A1,A0
                bsr     _objc_draw      ;Baum nochmal zeichnen
                bra.s   form_exit       ;Over and out
form_return3:   tst.w   D2
                bne     form_do6        ;Kein Default-Button
                bra.s   form_exit       ;gar kein Button!

; ESC = Eingabefeld löschen
form_clr:       movea.l 4(A3),A0        ;Zeiger auf Eingabefeld
form_clr1:      tst.b   (A0)
                beq.s   form_clr2       ;Ende der Eingabemaske gefunden
                move.b  #' ',(A0)+      ;Eingabefeld löschen
                bra.s   form_clr1
form_clr2:      movea.l A1,A0
                bsr     _objc_draw      ;Baum neu zeichnen

; Home = Cursor an den Anfang des Eingabefeldes
form_home:      bsr     calc_cur_anf    ;Cursor an den Anfang der Eingabemaske
                move.w  D0,spalte(A4)
                move.w  D1,zeile(A4)
                bra     form_do34       ;und weiter geht's

; Delete ausführen
form_delete:    bsr     calc_cur_anf
                move.l  A5,-(SP)
                move.w  spalte(A4),D1
                sub.w   D0,D1           ;Position des Cursors im String
                movea.l 4(A3),A0        ;Zeiger auf den String
                lea     0(A0,D1.w),A5   ;Zeiger auf akt.Zeichen
                moveq   #-1,D0
form_delete1:   addq.w  #1,D0
                tst.b   (A0)+           ;Länge des Eingabefeldes ermitteln
                bne.s   form_delete1
                sub.w   D1,D0
                subq.w  #1,D0
                bmi.s   form_delete3
form_delete2:   move.b  1(A5),(A5)+
                dbra    D0,form_delete2
                subq.l  #1,A5
form_delete3:   move.b  #' ',(A5)       ;Zeichen einsetzen
                movea.l (SP)+,A5
                movea.l A1,A0           ;Zeiger auf den Objektbaum
                bsr     _objc_draw      ;Baum neu zeichnen
                bra     form_do34

; Backspace ausführen
form_backspc:   bsr     calc_cur_anf
                move.w  spalte(A4),D1
                sub.w   D0,D1           ;Position des Cursors im String
                beq     form_do34       ;Backspace am Anfang der Eingabemaske
                move.l  A5,-(SP)
                subq.w  #1,spalte(A4)
                subq.w  #1,D1
                movea.l 4(A3),A0        ;Zeiger auf den String
                lea     0(A0,D1.w),A5   ;Zeiger auf akt.Zeichen
                moveq   #-1,D0
form_backspc1:  addq.w  #1,D0
                tst.b   (A0)+           ;Länge des Eingabefeldes ermitteln
                bne.s   form_backspc1
                sub.w   D1,D0
                subq.w  #1,D0
                bmi.s   form_backspc3
form_backspc2:  move.b  1(A5),(A5)+
                dbra    D0,form_backspc2
                subq.l  #1,A5
form_backspc3:  move.b  #' ',(A5)       ;Zeichen einsetzen
                movea.l (SP)+,A5
                movea.l A1,A0           ;Zeiger auf den Objektbaum
                bsr     _objc_draw      ;Baum neu zeichnen
                bra     form_do34

; Cursor left
form_left:      bsr     calc_cur_anf
                btst    #2,kbshift(A4)
                bne.s   form_left1      ;Control+Left
                move.w  spalte(A4),D1
                sub.w   D0,D1           ;Position des Cursors im String
                beq     form_do34       ;"CLeft" am Anfang der Eingabemaske verboten
                subq.w  #1,spalte(A4)   ;Cursor nach links
                bra     form_do34
form_left1:     bsr     calc_cur_anf
                move.w  D0,spalte(A4)   ;Cursor ganz nach links
                bra     form_do34

; Cursor right
form_right:     bsr     calc_cur_anf
                move.w  spalte(A4),D1
                sub.w   D0,D1           ;Position des Cursors im String
                movea.l 4(A3),A0        ;Zeiger auf den String
                tst.b   1(A0,D1.w)      ;nächstes Zeichen = Ende der Eingabe?
                beq     form_do34       ;Ja! =>
                moveq   #-2,D0
form_right1:    addq.w  #1,D0
                tst.b   (A0)+           ;Länge des Eingabefeldes ermitteln
                bne.s   form_right1
                subq.l  #1,A0
                addq.w  #1,D0
                bra.s   form_right3
form_right2:    subq.w  #1,D0           ;Eingabe nicht vollständig
form_right3:    cmpi.b  #' ',-(A0)
                beq.s   form_right2
                cmp.w   D0,D1
                beq     form_do34       ;Cursor bereits am Ende
                btst    #2,kbshift(A4)
                bne.s   form_right4     ;Control+Right
                addq.w  #1,spalte(A4)   ;Cursor nach rechts
                bra     form_do34
form_right4:    movea.l 4(A3),A0        ;Zeiger auf den String
                tst.b   0(A0,D0.w)      ;nächstes Zeichen = Ende der Eingabe?
                bne.s   form_right5     ;Nein! =>
                subq.w  #1,D0           ;Zeiger auf dem letzten Zeichen lassen
form_right5:    move.w  D0,spalte(A4)   ;Cursor ans Ende der Eingabe
                bsr.s   calc_cur_anf
                add.w   D0,spalte(A4)
                bra     form_do34

form_up1:       movea.l A1,A3           ;Anfangsadresse der RSC
form_up2:       lea     10(A3),A3       ;nächster Eintrag
                tst.w   (A3)            ;Ende erreicht?
                bpl.s   form_up2        ;weiter suchen
; Cursor up
form_up:        lea     -10(A3),A3      ;Nächster Eintrag
                cmpa.l  A1,A3
                bls.s   form_up1        ;Nichts gefunden
                btst    #3,9(A3)        ;Text?
                beq.s   form_up         ;Nein
                btst    #7,9(A3)        ;Editierbar
                beq.s   form_up         ;Nein
                bsr.s   calc_cur_anf    ;Cursor an den Anfang der Eingabemaske
                move.w  D0,spalte(A4)
                move.w  D1,zeile(A4)
                bra     form_do34

form_down1:     lea     -10(A1),A3
; Cursor down
form_down:      lea     10(A3),A3       ;Nächster Eintrag (Flags unbeeinflußt)
                tst.w   (A3)
                bmi.s   form_down1      ;Nichts gefunden
                btst    #3,9(A3)        ;Text?
                beq.s   form_down       ;Nein
                btst    #7,9(A3)        ;Editierbar?
                beq.s   form_down       ;Nein!
                bsr.s   calc_cur_anf    ;Cursor an den Anfang der Eingabemaske
                move.w  D0,spalte(A4)
                move.w  D1,zeile(A4)
                bra     form_do34

; Anfangskoordinate der Eingabemaske errechnen
calc_cur_anf:   movem.w 4(A1),D6-D7
                sub.w   sdrv_maxcur_x(A4),D6
                subq.w  #1,D6
                neg.w   D6
                lsr.w   #1,D6           ;Objekt zentieren
                sub.w   sdrv_zanz(A4),D7
                neg.w   D7
                lsr.w   #1,D7
                movem.w (A3),D0-D1
                add.w   D6,D0
                add.w   D7,D1
                rts
                ENDPART
                >PART 'desel_abutt' ;Deselect all buttons (D0 = selected Button)
************************************************************************
* Deselect all buttons (D0 = Selected Button)                          *
************************************************************************
desel_abutt:    movem.l D3/A0,-(SP)
                movea.l A1,A0
                moveq   #0,D3
                moveq   #0,D0
desel_abutt1:   tst.w   (A0)            ;Baum zuende?
                bmi.s   desel_abutt2    ;Ja!
                lea     10(A0),A0       ;Zeiger auf nächstes Objekt
                btst    #2,-1(A0)       ;Button?
                beq.s   desel_abutt1
                addq.w  #1,D3           ;Button Nr+1
                btst    #5,-1(A0)       ;Exit-Button?
                beq.s   desel_abutt1    ;Nein => Button nicht deselecten
                btst    #6,-1(A0)       ;Radio-Button?
                bne.s   desel_abutt1    ;Ja => dann nicht deselecten
                btst    #0,-1(A0)       ;Button selektiert?
                beq.s   desel_abutt1    ;Nein!
                move.w  D3,D0           ;Button Nr merken
                bclr    #0,-1(A0)       ;deselect Button
                bra.s   desel_abutt1    ;Weiter suchen
desel_abutt2:   movem.l (SP)+,D3/A0
                rts
                ENDPART
                >PART 'find_button' ;Button unter der Maus finden
************************************************************************
* Button unter der Maus finden (A0 zeigt auf den Button D2, Flags!)    *
************************************************************************
find_button:    movem.w mausx(A4),D0-D1
                lsr.w   #3,D0
                divs    sdrv_cheight(A4),D1 ;In Zeichenkoordinaten umrechnen
                ext.l   D1
                subq.w  #menu_offset,D1 ;in der Menüleiste?
                bmi.s   find_button3    ;Ja! =>
                movem.w 4(A1),D6-D7     ;Breite & Höhe holen
                sub.w   sdrv_maxcur_x(A4),D6
                subq.w  #1,D6
                neg.w   D6
                lsr.w   #1,D6           ;Objekt zentieren
                sub.w   sdrv_zanz(A4),D7
                neg.w   D7
                lsr.w   #1,D7
                sub.w   D6,D0
                bmi.s   find_button3
                sub.w   D7,D1           ;Mauskoordinaten in Offsets umrechnen
                bmi.s   find_button3
                moveq   #0,D2           ;Button Nr löschen
                movea.l A1,A0
find_button1:   tst.w   (A0)
                bmi.s   find_button3    ;Nichts gefunden
                lea     10(A0),A0       ;Nächster Eintrag (Flags unbeeinflußt)
                btst    #2,-1(A0)       ;Button?
                beq.s   find_button1    ;Kein Button
                addq.w  #1,D2           ;Button-Nr erhöhen
                btst    #4,-1(A0)       ;disabled?
                bne.s   find_button1    ;Ja, ignorieren
                move.w  -10(A0),D3      ;X-Koordinate holen
                cmp.w   D3,D0
                blo.s   find_button1    ;X zu klein
                movea.l -6(A0),A2       ;Textadresse
                moveq   #-1,D4
find_button2:   addq.l  #1,D4           ;Textlänge ermitteln
                tst.b   (A2)+
                bne.s   find_button2
                add.w   D4,D3           ;Breite dazu
                cmp.w   D3,D0
                bhs.s   find_button1    ;X zu groß
                move.w  -8(A0),D3       ;Y-Koordinate holen
                cmp.w   D3,D1
                blo.s   find_button1    ;Y zu klein
                addq.w  #1,D3           ;Höhe dazu (da Text, stets eine Zeile)
                cmp.w   D3,D1
                bhs.s   find_button1    ;Y zu groß
                lea     -10(A0),A0
                move    #$FF,CCR        ;Button gefunden
                rts
find_button3:   moveq   #0,D2           ;Kein Button selektiert
                move    #0,CCR
                rts
                ENDPART
                >PART 'find_etext' ;Edit.Text unter der Maus finden
************************************************************************
* Edt.Text unter der Maus finden (A0 zeigt auf den Text D2, Flags!)    *
************************************************************************
find_etext:     movem.w mausx(A4),D0-D1
                lsr.w   #3,D0
                divs    sdrv_cheight(A4),D1 ;In Zeichenkoordinaten umrechnen
                ext.l   D1
                subq.w  #menu_offset,D1
                bmi.s   find_etext3
                move.w  D0,D6
                move.w  D1,D7
                movem.w 4(A1),D2-D3     ;Breite & Höhe holen
                sub.w   sdrv_maxcur_x(A4),D2
                subq.w  #1,D2
                neg.w   D2
                lsr.w   #1,D2           ;Objekt zentieren
                sub.w   sdrv_zanz(A4),D3
                neg.w   D3
                lsr.w   #1,D3
                sub.w   D2,D0
                bmi.s   find_etext3
                sub.w   D3,D1           ;Mauskoordinaten in Offsets umrechnen
                bmi.s   find_etext3
                moveq   #0,D2           ;Text Nr löschen
                movea.l A1,A0
find_etext1:    tst.w   (A0)
                bmi.s   find_etext3     ;Nichts gefunden
                lea     10(A0),A0       ;Nächster Eintrag (Flags unbeeinflußt)
                btst    #3,-1(A0)       ;Text?
                beq.s   find_etext1     ;Kein Text
                btst    #7,-1(A0)       ;Editierbar?
                beq.s   find_etext1     ;Nein
                addq.w  #1,D2           ;Text-Nr erhöhen
                move.w  -10(A0),D3      ;X-Koordinate holen
                cmp.w   D3,D0
                blo.s   find_etext1     ;X zu klein
                movea.l -6(A0),A2       ;Textadresse
                moveq   #-1,D4
find_etext2:    addq.l  #1,D4           ;Textlänge ermitteln
                tst.b   (A2)+
                bne.s   find_etext2
                add.w   D4,D3           ;Breite dazu
                cmp.w   D3,D0
                bhs.s   find_etext1     ;X zu groß
                move.w  -8(A0),D3       ;Y-Koordinate holen
                cmp.w   D3,D1
                blo.s   find_etext1     ;Y zu klein
                addq.w  #1,D3           ;Höhe dazu (da Text, stets eine Zeile)
                cmp.w   D3,D1
                bhs.s   find_etext1     ;Y zu groß
                lea     -10(A0),A0
                move    #$FF,CCR        ;Text gefunden
                rts
find_etext3:    moveq   #0,D2           ;Kein Text gefunden
                move    #0,CCR
                rts
                ENDPART
                >PART 'objc_draw' ;Baum ab A0 zeichnen
************************************************************************
* Object draw (ab A0)                                                  *
************************************************************************
_objc_draw:     movem.l D0-A3/A5,-(SP)
                move.l  zeile(A4),-(SP)
                bsr     cursor_off
                clr.w   button_nr(A4)
                lea     jmptab(PC),A2   ;Sprungtabelle für S/W
                movem.w 4(A0),D6-D7
                sub.w   sdrv_maxcur_x(A4),D6
                subq.w  #1,D6
                neg.w   D6
                lsr.w   #1,D6           ;Objekt zentieren
                sub.w   sdrv_zanz(A4),D7
                neg.w   D7
                lsr.w   #1,D7
objc_draw2:     moveq   #0,D0
                moveq   #0,D1
                moveq   #0,D2
                moveq   #0,D3
                moveq   #0,D4
                movem.w (A0)+,D0-D4
                tst.w   D0              ;Ende der Liste?
                bmi.s   objc_draw4      ;Ja! =>
                moveq   #$1F,D5
                and.w   D4,D5
                add.w   D5,D5
                movea.w 0(A2,D5.w),A3
                cmp.w   #6,D5
                bls.s   objc_draw3
                movea.w (A2),A3
objc_draw3:     adda.l  A2,A3
                add.w   D6,D0
                add.w   D7,D1
                bsr     clr_maus
                jsr     (A3)
                bra.s   objc_draw2
objc_draw4:     bsr     set_maus
                move.l  (SP)+,zeile(A4)
                movem.l (SP)+,D0-A3/A5
                rts

                BASE DC.W,jmptab
jmptab:         DC.W draw_text  ;0 Default
                DC.W draw_border ;1
                DC.W draw_frame ;2
                DC.W draw_icon  ;3

draw_icon:      lsr.w   #8,D4
                addq.w  #menu_offset,D1 ;Zeile
                mulu    sdrv_cheight(A4),D1 ;mal Fonthöhe = Y-Position
                swap    D2
                move.w  D3,D2
                movea.l D2,A3           ;Adresse des Icons
                movea.l sdrv_scrbase(A4),A5
                mulu    sdrv_loffset(A4),D1
                adda.l  D1,A5           ;Adresse auf dem Screen
                moveq   #1,D1
                and.w   D0,D1
                adda.w  D1,A5
                eor.w   D1,D0
                move.w  sdrv_plnshift(A4),D1
                lsl.w   D1,D0
                adda.w  D0,A5           ;X-Koordinate dazu
                moveq   #$0F,D2
                and.w   D4,D2           ;Iconbreite in Bytes (1 bis 16 Bytes)
                moveq   #0,D5
                and.w   #$F0,D4
                lsr.w   #1,D4
                addq.w  #8,D4           ;Iconhöhe (minimal 8 Zeilen)
                cmpi.w  #16,sdrv_cheight(A4) ;Auflösung vertikal klein?
                bhs.s   draw_icon0      ;Nein! =>
                move.w  D2,D5
                addq.w  #1,D5           ;sonst jede 2.Zeile weglassen
                lsr.w   #1,D4           ;das sind halb soviele Zeilen
draw_icon0:     subq.w  #1,D4
                move.w  sdrv_poffset(A4),D3
draw_icon1:     move.w  D2,D1           ;Iconbreite in Bytes - 1
                movea.l A5,A1
draw_icon2:     move.b  (A3)+,(A1)+
                move.w  A1,D0
                btst    #0,D0           ;Adresse nun gerade?
                bne.s   draw_icon3      ;Nein! =>
                adda.w  D3,A1           ;Plane-Offset drauf
draw_icon3:     dbra    D1,draw_icon2
                adda.w  D5,A3           ;Offset auf die nächste Iconzeile
                adda.w  sdrv_loffset(A4),A5 ;nächste Rasterzeile
                dbra    D4,draw_icon1   ;Anzahl der Zeilen
                rts

draw_text:      swap    D2
                move.w  D3,D2
                move.w  D0,spalte(A4)
                move.w  D1,zeile(A4)
                movea.l D2,A3
                movem.l D0-D3,-(SP)
                btst    #2,D4
                beq.s   draw_text1
                cmpi.b  #' ',(A3)
                bne.s   draw_text1
                addq.l  #1,A3
                moveq   #'A',D0
                add.w   button_nr(A4),D0
                or.w    #$FF00,D0
                bra.s   draw_text2
draw_text1:     moveq   #0,D0
                move.b  (A3)+,D0
                beq.s   draw_text7
draw_text2:     moveq   #-1,D1          ;Light-Maske löschen
                moveq   #0,D2           ;Invers-Maske löschen
                moveq   #0,D3           ;Underline-Maske löschen
                btst    #0,D4           ;selected (invers) ?
                beq.s   draw_text3
                moveq   #-1,D2          ;Invers darstellen
draw_text3:     btst    #4,D4           ;disabled (light) ?
                beq.s   draw_text4
                moveq   #$55,D1         ;Light darstellen
draw_text4:     btst    #2,D4
                bne.s   draw_text5      ;=> Button
                btst    #6,D4           ;Fett?
                beq.s   draw_text5
                or.w    #$0100,D0       ;Im Zeichencode markieren
draw_text5:     btst    #7,D4           ;Editierbar?
                beq.s   draw_text6
                moveq   #-1,D3          ;Underline an
                tst.b   passwort_flag(A4)
                beq.s   draw_text6      ;Passwortabfrage?
                moveq   #'*',D0         ;dann nur '*' ausgeben
draw_text6:     bsr     light_char
                addq.w  #1,spalte(A4)
                bra.s   draw_text1
draw_text7:     movem.l (SP)+,D0-D3
                btst    #2,D4           ;Text oder Button
                beq.s   draw_text10     ;Text ohne Rahmen =>
                addq.w  #1,button_nr(A4) ;ein Button (hochzählen)
                movea.l D2,A3           ;Adresse vom Text
                move.w  D4,D5
                lsl.w   #3,D0           ;X
                subq.w  #1,D0
                move.w  D1,D2
                addq.w  #menu_offset,D2
                mulu    sdrv_cheight(A4),D2 ;Y
                subq.w  #1,D2
                moveq   #-7,D1
                add.w   D0,D1
draw_text8:     addq.w  #8,D1           ;Textlänge
                tst.b   (A3)+
                bne.s   draw_text8
                move.w  sdrv_cheight(A4),D4
                addq.w  #1,D4
                add.w   D2,D4
                moveq   #0,D3           ;Füllmuster: schwarz
                bsr.s   DrawFrame
draw_text9:     subq.w  #1,D0
                subq.w  #1,D2
                addq.w  #1,D1
                addq.w  #1,D4
                bsr.s   DrawFrame
                bclr    #1,D5
                bne.s   draw_text9
draw_text10:    rts

draw_border:    movem.w D0-D4,-(SP)
                lsl.w   #3,D0           ;X1
                addq.w  #menu_offset,D1
                mulu    sdrv_cheight(A4),D1 ;Y1
                lsl.w   #3,D2           ;Breite
                mulu    sdrv_cheight(A4),D3 ;Höhe
                exg     D1,D2
                add.w   D0,D1           ;X2
                move.w  D3,D4
                add.w   D2,D4           ;Y2
                subq.w  #4,D0
                subq.w  #4,D2
                addq.w  #4,D1
                addq.w  #4,D4
                moveq   #1,D3           ;Füllmuster: weiß
                bsr.s   DrawRect
                movem.w (SP)+,D0-D4
draw_frame:     lsl.w   #3,D0           ;X1
                addq.w  #menu_offset,D1
                mulu    sdrv_cheight(A4),D1 ;Y1
                lsl.w   #3,D2           ;Breite
                mulu    sdrv_cheight(A4),D3 ;Höhe
                exg     D1,D2
                add.w   D0,D1           ;X2
                move.w  D3,D4
                add.w   D2,D4           ;Y2
                moveq   #0,D3           ;Füllmuster: schwarz
                subq.w  #1,D0
                subq.w  #1,D2
                addq.w  #1,D1
                addq.w  #1,D4
                bsr.s   DrawFrame
                subq.w  #1,D0
                subq.w  #1,D2
                addq.w  #1,D1
                addq.w  #1,D4
                bsr.s   DrawFrame
                subq.w  #3,D0
                subq.w  #3,D2
                addq.w  #3,D1
                addq.w  #3,D4
                bsr.s   DrawFrame
                rts
                ENDPART
                >PART 'DrawFrame' ;Rahmen von (D0,D2) nach (D1,D4), Füllmuster D3
DrawFrame:      movem.l D0-D2/D4,-(SP)
                bsr.s   DrawHline       ;obere Linie ziehen
                exg     D4,D2
                bsr.s   DrawHline       ;untere Linie ziehen
                exg     D4,D1
                bsr     DrawVline       ;linke Linie ziehen
                move.w  D4,D0
                bsr     DrawVline       ;rechte Linie ziehen
                movem.l (SP)+,D0-D2/D4
                rts
                ENDPART
                >PART 'DrawRect' ;Rechteck von (D0,D2) nach (D1,D4), Füllmuster D3
DrawRect:       move.l  D2,-(SP)
DrawRect1:      bsr.s   DrawHline
                addq.w  #1,D2
                cmp.w   D4,D2
                bls.s   DrawRect1
                move.l  (SP)+,D2
                rts
                ENDPART
                >PART 'DrawHline' ;Linie von (D0,D2) nach (D1,D2), Füllmuster D3
DrawHline:      movem.l D0-D5/A0-A1,-(SP)
                tst.w   D0
                bpl.s   DrawHline1      ;Clipping für Xmin
                moveq   #0,D0
DrawHline1:     tst.w   D2
                bpl.s   DrawHline2      ;Clipping für Y
                moveq   #0,D2
DrawHline2:     move.w  sdrv_max_y(A4),D4
                cmp.w   D4,D2           ;Y zu groß?
                bhi.s   DrawHline7      ;Ja! => raus
                sub.w   D0,D1           ;Länge der Linie in Pixeln
                subq.w  #1,D1
                movea.l sdrv_scrbase(A4),A0 ;Adresse des Screens
                lsl.w   #5,D3           ;das Füllmuster mal 32
                lea     sdrv_fill(PC),A1
                adda.w  D3,A1
                moveq   #15,D3
                and.w   D2,D3
                add.w   D3,D3
                move.w  0(A1,D3.w),D4   ;Füllmuster holen
                mulu    sdrv_loffset(A4),D2 ;Y * Zeilenoffset
                adda.l  D2,A0           ;zur Screenadresse
                moveq   #15,D2
                and.w   D0,D2           ;X-Pixelstartposition
                eor.w   D2,D0
                lsr.w   #3,D0           ;durch 8
                move.w  sdrv_plnshift(A4),D3
                lsl.w   D3,D0
                adda.w  D0,A0           ;X zur Bitmapadresse
                moveq   #15,D3
                sub.w   D2,D3
                sub.w   D3,D1           ;Startpixel abziehen
                moveq   #15,D0
                and.w   D1,D0           ;X-Pixelendposition
                add.w   D2,D2           ;mal 2
                move.w  DrawHline_tab1(PC,D2.w),D2 ;X-Startmaske
                add.w   D0,D0           ;mal 2
                move.w  DrawHline_tab2(PC,D0.w),D0 ;X-Endmaske
                asr.w   #4,D1           ;Anzahl der zu setzenden Words
                bpl.s   DrawHline3      ;länger als 16 Pixel =>
                and.w   D2,D0           ;Start- und Endmaske verknüpfen
                bra.s   DrawHline6
DrawHline3:     move.w  D2,D5
                not.w   D5
                and.w   (A0),D5         ;neue Pixel löschen
                and.w   D4,D2           ;Füllmuster zur Bitmaske
                or.w    D2,D5           ;Bits setzen
                move.w  D5,(A0)+        ;und den Linienstart wieder zurück
                bra.s   DrawHline5
DrawHline4:     move.w  D4,(A0)+        ;Linie mit Füllmuster ziehen
DrawHline5:     adda.w  sdrv_poffset(A4),A0
                dbra    D1,DrawHline4
DrawHline6:     move.w  D0,D5
                not.w   D5
                and.w   (A0),D5
                and.w   D4,D0           ;Füllmuster dazu
                or.w    D0,D5
                move.w  D5,(A0)         ;Linienende setzen
DrawHline7:     movem.l (SP)+,D0-D5/A0-A1
                rts

DrawHline_tab1: DC.W $FFFF,$7FFF,$3FFF,$1FFF,$0FFF,$07FF,$03FF,$01FF
                DC.W $FF,$7F,$3F,$1F,$0F,$07,$03,$01
DrawHline_tab2: DC.W $8000,$C000,$E000,$F000,$F800,$FC00,$FE00,$FF00
                DC.W $FF80,$FFC0,$FFE0,$FFF0,$FFF8,$FFFC,$FFFE,$FFFF
                ENDPART
                >PART 'DrawVline' ;Linie von (D0,D1) nach (D0,D2), Füllmuster D3
DrawVline:      movem.l D0-D5/A0-A1,-(SP)
                tst.w   D0
                bpl.s   DrawVline1      ;Clipping für X
                moveq   #0,D0
DrawVline1:     tst.w   D1
                bpl.s   DrawVline2      ;Clipping für Ymin
                moveq   #0,D1
DrawVline2:     move.w  sdrv_max_y(A4),D4
                cmp.w   D4,D2
                blo.s   DrawVline3
                move.w  D4,D2
DrawVline3:     cmp.w   D4,D1           ;Ymin zu groß?
                bhi.s   DrawVline6      ;Ja! => raus
                sub.w   D1,D2           ;Länge der Linie
                lsl.w   #5,D3           ;das Füllmuster mal 32
                lea     sdrv_fill(PC),A1
                adda.w  D3,A1
                moveq   #15,D4
                and.w   D1,D4           ;Y-Position mod 16 merken (Füllmusterposition)
                add.w   D4,D4
                movea.l sdrv_scrbase(A4),A0 ;Adresse des Screens
                mulu    sdrv_loffset(A4),D1 ;Ystart * Zeilenoffset
                adda.l  D1,A0           ;zur Screenadresse
                moveq   #15,D1
                and.w   D0,D1
                eor.w   D1,D0
                add.w   D1,D1
                move.w  DrawVline_tab(PC,D1.w),D1 ;Maske der Linienposition
                lsr.w   #3,D0
                move.w  sdrv_plnshift(A4),D3
                lsl.w   D3,D0
                adda.w  D0,A0           ;X zur Bitmapadresse
                move.w  sdrv_loffset(A4),D3
                bra.s   DrawVline5
DrawVline4:     move.w  0(A1,D4.w),D0   ;Füllmuster holen
                addq.w  #2,D4
                and.w   #$1E,D4         ;zur nächsten Zeile im Füllmuster
                and.w   D1,D0           ;nur die Pixelposition nehmen
                move.w  D1,D5
                not.w   D5              ;inverse Bitmaske
                and.w   (A0),D5         ;Bitposition löschen
                or.w    D0,D5           ;neues Bit übertragen
                move.w  D5,(A0)         ;und wieder zurück
                adda.w  D3,A0
DrawVline5:     dbra    D2,DrawVline4
DrawVline6:     movem.l (SP)+,D0-D5/A0-A1
                rts
DrawVline_tab:  DC.W $8000,$4000,$2000,$1000,$0800,$0400,$0200,$0100
                DC.W $80,$40,$20,$10,$08,$04,$02,$01
                ENDPART
                >PART 'sdrv_fill' ;die Füllmuster
sdrv_fill:      DS.W 16,-1      ;0: schwarz
                DS.W 16         ;1: weiß
                DS.L 8,$5555AAAA ;2: dunkelgrau
                REPT 4
                DC.W %1000100010001000
                DC.W %0
                DC.W %10001000100010 ;3: hellgrau
                DC.W %0
                ENDR
                DS.L 8,$55550000 ;4: Windowtitel
                ENDPART

************************************************************************
* Schnelle Verschiebe bzw. Füllroutinen                                *
************************************************************************
                >PART 'MemMove' ;von A0 D0 Bytes nach A1 verschieben
********************************************************************************
* Speicherblock verschieben                                                    *
* A0 - Sourceadresse                                                          *
* D0 - Anzahl der Bytes                                                       *
* A1 - Destinationadresse                                                     *
********************************************************************************
MemMove:        and.l   #$FFFFFF,D0
                tst.l   D0
                beq     MemMove21
                movem.l D0-D2/A0-A1,-(SP)
                cmpa.l  A1,A0
                bhi     MemMove10
                beq     MemMove20
                adda.l  D0,A0
                adda.l  D0,A1
                move.w  A0,D1
                move.w  A1,D2
                btst    #0,D1
                beq.s   MemMove2
                btst    #0,D2
                bne.s   MemMove3
MemMove1:       move.b  -(A0),-(A1)
                subq.l  #1,D0
                bne.s   MemMove1
                bra     MemMove20
MemMove2:       btst    #0,D2
                bne.s   MemMove1
                bra.s   MemMove4
MemMove3:       move.b  -(A0),-(A1)
                subq.l  #1,D0
                beq     MemMove20
MemMove4:       move.l  D0,D1
                lsr.l   #5,D1
                lsr.l   #4,D1
                beq     MemMove6
                movem.l D2-D7/A3-A6,-(SP)
MemMove5:       movem.l -40(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -80(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -120(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -160(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -200(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -240(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -280(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -320(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -360(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -400(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -440(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -480(A0),D2-D7/A3-A6
                movem.l D2-D7/A3-A6,-(A1)
                movem.l -512(A0),D2-D7/A3-A4
                movem.l D2-D7/A3-A4,-(A1)
                lea     -512(A0),A0
                subq.l  #1,D1
                bne     MemMove5
                movem.l (SP)+,D2-D7/A3-A6
MemMove6:       move.w  D0,D1
                and.w   #$01FF,D0
                lsr.w   #2,D0
                beq.s   MemMove8
                subq.w  #1,D0
MemMove7:       move.l  -(A0),-(A1)
                dbra    D0,MemMove7
MemMove8:       and.w   #3,D1
                beq     MemMove20
                subq.w  #1,D1
MemMove9:       move.b  -(A0),-(A1)
                dbra    D1,MemMove9
                bra     MemMove20

MemMove10:      move.w  A0,D1
                move.w  A1,D2
                btst    #0,D1
                beq.s   MemMove12
                btst    #0,D2
                bne.s   MemMove13
MemMove11:      move.b  (A0)+,(A1)+
                subq.l  #1,D0
                bne.s   MemMove11
                bra     MemMove20
MemMove12:      btst    #0,D2
                bne.s   MemMove11
                bra.s   MemMove14
MemMove13:      move.b  (A0)+,(A1)+
                subq.l  #1,D0
MemMove14:      move.l  D0,D1
                lsr.l   #5,D1
                lsr.l   #4,D1
                beq     MemMove16
                movem.l D2-D7/A3-A6,-(SP)
MemMove15:      movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,40(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,80(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,120(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,160(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,200(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,240(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,280(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,320(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,360(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,400(A1)
                movem.l (A0)+,D2-D7/A3-A6
                movem.l D2-D7/A3-A6,440(A1)
                movem.l (A0)+,D2-D7/A3-A4
                movem.l D2-D7/A3-A4,480(A1)
                lea     512(A1),A1
                subq.l  #1,D1
                bne     MemMove15
                movem.l (SP)+,D2-D7/A3-A6
MemMove16:      move.w  D0,D1
                and.w   #$01FF,D0
                lsr.w   #2,D0
                beq.s   MemMove18
                subq.w  #1,D0
MemMove17:      move.l  (A0)+,(A1)+
                dbra    D0,MemMove17
MemMove18:      and.w   #3,D1
                beq.s   MemMove20
                subq.w  #1,D1
MemMove19:      move.b  (A0)+,(A1)+
                dbra    D1,MemMove19
MemMove20:      movem.l (SP)+,D0-D2/A0-A1
MemMove21:      rts
                ENDPART
                >PART 'MemFill' ;D1 Bytes ab A0 mit D0 füllen
********************************************************************************
* Speicherblock mit Füllwert füllen                                            *
* A0 - Anfangsadresse des Blockes                                             *
* D0 - Füllbyte                                                               *
* D1 - Anzahl der Bytes                                                       *
* A0 - Anfangsadresse des gefüllten Blockes                                   *
********************************************************************************
MemFill:        movem.l D0-D2/A0-A1,-(SP)
                adda.l  D1,A0
                move.l  A0,D2
                btst    #0,D2
                beq.s   MemFill1
                subq.l  #1,D1
                bcs     MemFill7
                move.b  D0,-(A0)
MemFill1:       move.b  D0,-(SP)
                move.w  (SP)+,D2
                move.b  D0,D2
                move.w  D2,D0
                swap    D2
                move.w  D0,D2
                move.l  D1,D0
                lsr.l   #8,D0
                lsr.l   #2,D0
                beq.s   MemFill3
                movem.l D1/D3-D7/A2-A6,-(SP)
                move.l  D2,D1
                move.l  D2,D3
                move.l  D2,D4
                move.l  D2,D5
                move.l  D2,D6
                move.l  D2,D7
                movea.l D2,A1
                movea.l D2,A2
                movea.l D2,A3
                movea.l D2,A4
                movea.l D2,A5
                movea.l D2,A6
MemFill2:       movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A6,-(A0)
                movem.l D1-D7/A1-A2,-(A0)
                subq.l  #1,D0
                bne.s   MemFill2
                movem.l (SP)+,D1/D3-D7/A2-A6
                and.w   #$03FF,D1
MemFill3:       move.w  D1,D0
                lsr.w   #2,D0
                beq.s   MemFill5
                subq.w  #1,D0
MemFill4:       move.l  D2,-(A0)
                dbra    D0,MemFill4
MemFill5:       and.w   #3,D1
                beq.s   MemFill7
                subq.w  #1,D1
MemFill6:       move.b  D2,-(A0)
                dbra    D1,MemFill6
MemFill7:       movem.l (SP)+,D0-D2/A0-A1
                rts
                ENDPART

************************************************************************
* Menütabelle                                                          *
************************************************************************
                >PART 'menü_tab' ;Die Menütabelle
menü_tab:       DC.W $00,$0417,$69 ;CTRL+I
                DC.W $01,$0517,$69 ;Shift+CTRL+I
                DC.W $03,$8000,$0A ;Shift+F1

                DC.W $0100,$8000,$0F ;Shift+F6
                DC.W $0101,$8000,$07 ;F8
                DC.W $0102,$8000,$11 ;Shift+F8
                DC.W $0103,$8000,$FFFF ;Shift+Fxxx
                DC.W $0105,$0410,$71 ;CTRL+Q
                DC.W $0106,$8000,$08 ;F9
                DC.W $0107,$8000,$12 ;Shift+F9
                DC.W $0109,$80,$07 ;Datei löschen
                DC.W $010B,$8000,$13 ;Shift+F10

                DC.W $0200,$081E,$61 ;Alt+A
                DC.W $0201,$8000,$00 ;F1
                DC.W $0203,$8000,$01 ;F2
                DC.W $0204,$80,$0B ;Debugger laden
                DC.W $0205,$80,$0C ;Debugger löschen
                DC.W $0207,$0418,$6F ;Optimierungsdialog
                DC.W $0208,$0811,$77 ;Alt+W

                DC.W $0300,$8000,$04 ;F5
kbd_patch1:     DC.W $0301,$041B,$2B ;CTRL+"+"
                DC.W $0303,$8000,$0D ;Shift+F4
                DC.W $0305,$8000,$06 ;F7
                DC.W $0306,$80,$0D ;Druckeranpassung laden

                DC.W $0400,$8000,$02 ;F3
                DC.W $0401,$8000,$0C ;Shift+F3
                DC.W $0402,$0426,$6C ;CTRL+L
                DC.W $0403,$0512,$65 ;CTRL+E
                DC.W $0405,$0815,$7A ;ALT+Z
                DC.W $0406,$0824,$6A ;ALT+J
                DC.W $0407,$081F,$73 ;ALT+S
                DC.W $0408,$041F,$73 ;CTRL+S

                DC.W $0500,$0430,$62 ;CTRL+B
                DC.W $0501,$0425,$6B ;CTRL+K
                DC.W $0502,$0423,$68 ;CTRL+H
                DC.W $0504,$042F,$76 ;CTRL+V
                DC.W $0505,$082E,$63 ;ALT+C
                DC.W $0506,$082C,$79 ;ALT+Y
                DC.W $0508,$8000,$FFFE ;Fyyy
                DC.W $050A,$80,$0A ;Block drucken

                DC.W $0600,$8000,$0E ;Shift+F5
                DC.W $0601,$8000,$03 ;F4
                DC.W $0602,$8000,$10 ;Shift+F7
                DC.W $0603,$80,$10
                DC.W $0605,$80,$08 ;Einstellungen sichern
                DC.W -1
                ENDPART

                DATA
                >PART 'menü_baum'
max_mlines      EQU 12          ;maximale Zeilenanzahl eines Menüpunktes
menü_baum:      DC.B '  ',0
                DC.B 1,'  TurboAss V'
                DC.B (version>>8)&$0F+'0'
                DC.B '.'
                DC.B (version>>4)&$0F+'0'
                DC.B '...     ^I ',0
                SWITCH sprache
                CASE 0
                DC.B 1,'  Dank an...          ^I ',0
                DC.B 3,'--------------------------',0
                DC.B 1,'  Accessories         F1 ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Datei ',0
                DC.B 1,'  Neu anlegen...    F6 ',0
                DC.B 1,'  Laden...           F8 ',0
                DC.B 1,'  Zuladen...        F8 ',0
                DC.B 1,'  Symbole zuladen...    ',0
                DC.B 3,'------------------------',0
                DC.B 1,'  Sichern            ^Q ',0
                DC.B 1,'  Sichern unter...   F9 ',0
                DC.B 1,'  ASCII-Sichern...  F9 ',0
                DC.B 3,'------------------------',0
                DC.B 1,'  Datei löschen...      ',0
                DC.B 3,'------------------------',0
                DC.B 1,'  Ende...          F10 ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Assembler ',0
                DC.B 1,'  Assemblieren         A ',0
                DC.B 1,'  Assemblieren...      F1 ',0
                DC.B 3,'--------------------------',0
debugger_entry: DC.B 3,'   Debugger           F2 ',0
debugger_entry2:DC.B 1,'  Debugger nachladen   D ',0
debugger_entry3:DC.B 3,'  Debugger löschen        ',0
                DC.B 3,'--------------------------',0
                DC.B 1,'  Optimierungen...     ^O ',0
warn_entry:     DC.B 1,'  Warnungen anspringen W ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Editor ',0
                DC.B 1,'  Rechner...        F5 ',0
                DC.B 1,'  Zeichentabelle... ^'
kbd_patch2:     DC.B '+ ',0
                DC.B 3,'-----------------------',0
                DC.B 1,'  Informationen... F4 ',0
                DC.B 3,'-----------------------',0
                DC.B 1,'  Drucken...        F7 ',0
                DC.B 1,'  Drucker:'
prt_type:       DC.B '             ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Suchen ',0
                DC.B 1,'  Symbol suchen...    F3 ',0
                DC.B 1,'  Symbol ersetzen... F3 ',0
                DC.B 1,'  Text suchen...      ^L ',0
                DC.B 1,'  Text ersetzen...   ^E ',0
                DC.B 3,'-------------------------',0
                DC.B 1,'  Sprung zu Zeile...  Z ',0
                DC.B 1,'  Nächster Fehler     J ',0
                DC.B 1,'  Nächster SFehler    S ',0
                DC.B 1,'  Nächster Merker     ^S ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Block ',0
                DC.B 1,'  Blockanfang setzen  ^B ',0
                DC.B 1,'  Blockende setzen    ^K ',0
block_entry:    DC.B 3,'  Blockmarken löschen ^H ',0
                DC.B 3,'-------------------------',0
                DC.B 3,'  Block verschieben   ^V ',0
                DC.B 3,'  Block kopieren      C ',0
                DC.B 3,'  Block löschen       Y ',0
                DC.B 3,'-------------------------',0
                DC.B 7,'  Block speichern...     ',0 ;Bit 2-Demokennung
                DC.B 3,'-------------------------',0
                DC.B 3,'  Block drucken          ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Einstellungen ',0
                DC.B 1,'  Darstellung...        F5 ',0
                DC.B 1,'  Editor 1...            F4 ',0
                DC.B 1,'  Editor 2...           F7 ',0
                DC.B 1,'  Editor 3...               ',0
                DC.B 3,'----------------------------',0
                DC.B 1,'  Einstellungen sichern     ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Hilfe ',0
                DC.B 3,'  Menücodes:    ',0
                DC.B 3,'   - Shift     ',0
                DC.B 3,'  ^ - Control   ',0
                DC.B 3,'   - Alternate ',0
                DC.B -2
                CASE 1
                DC.B 1,'  Thanks to...        ^I ',0
                DC.B 3,'--------------------------',0
                DC.B 1,'  Accessories         F1 ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' File ',0
                DC.B 1,'  New...            F6 ',0
                DC.B 1,'  Load...            F8 ',0
                DC.B 1,'  Merge...          F8 ',0
                DC.B 1,'  Merge symbols...      ',0
                DC.B 3,'------------------------',0
                DC.B 1,'  Save               ^Q ',0
                DC.B 1,'  Save as...         F9 ',0
                DC.B 1,'  ASCII-Save...     F9 ',0
                DC.B 3,'------------------------',0
                DC.B 1,'  Delete file...        ',0
                DC.B 3,'------------------------',0
                DC.B 1,'  Quit...          F10 ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Assembler ',0
                DC.B 1,'  Assemble           A ',0
                DC.B 1,'  Assemble...        F1 ',0
                DC.B 3,'------------------------',0
debugger_entry: DC.B 3,'   Debugger         F2 ',0
debugger_entry2:DC.B 1,'  Load debugger      D ',0
debugger_entry3:DC.B 3,'  Clear debugger        ',0
                DC.B 3,'------------------------',0
                DC.B 1,'  Optimizings...     ^O ',0
warn_entry:     DC.B 1,'  Jump to warnings   W ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Editor ',0
                DC.B 1,'  Calculator...     F5 ',0
                DC.B 1,'  Char table...     ^'
kbd_patch2:     DC.B '+ ',0
                DC.B 3,'-----------------------',0
                DC.B 1,'  Information...   F4 ',0
                DC.B 3,'-----------------------',0
                DC.B 1,'  Print...          F7 ',0
                DC.B 1,'  Printer:'
prt_type:       DC.B '             ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Search ',0
                DC.B 1,'  Search symbol...    F3 ',0
                DC.B 1,'  Replace symbol...  F3 ',0
                DC.B 1,'  Search text...      ^L ',0
                DC.B 1,'  Replace text...    ^E ',0
                DC.B 3,'-------------------------',0
                DC.B 1,'  Jump to line...     Z ',0
                DC.B 1,'  Next error          J ',0
                DC.B 1,'  Next Syntax-Error   S ',0
                DC.B 1,'  Next marker         ^S ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Block ',0
                DC.B 1,'  Set blockstart      ^B ',0
                DC.B 1,'  Set blockend        ^K ',0
block_entry:    DC.B 3,'  Clear blockmarks    ^H ',0
                DC.B 3,'-------------------------',0
                DC.B 3,'  Move block          ^V ',0
                DC.B 3,'  Copy block          C ',0
                DC.B 3,'  Erase block         Y ',0
                DC.B 3,'-------------------------',0
                DC.B 7,'  Save block...          ',0 ;Bit 2-Demokennung
                DC.B 3,'-------------------------',0
                DC.B 3,'  Print block            ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Settings ',0
                DC.B 1,'  Representation...     F5 ',0
                DC.B 1,'  Editor 1...            F4 ',0
                DC.B 1,'  Editor 2...           F7 ',0
                DC.B 1,'  Editor 3...               ',0
                DC.B 3,'----------------------------',0
                DC.B 1,'  Save settings             ',0
                DC.B -1         ;Ende des Eintrags
                DC.B ' Help ',0
                DC.B 3,'  Menucodes:    ',0
                DC.B 3,'   - Shift     ',0
                DC.B 3,'  ^ - Control   ',0
                DC.B 3,'   - Alternate ',0
                DC.B -2
                ENDS
                EVEN
                ENDPART
                >PART 'allowed_chars' ;erlaubte Zeichen in Symbolen
************************************************************************
* Tabelle der erlaubten Zeichen für den Labelnamen                     *
************************************************************************
allowed_chars:  DC.B 0,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1 ;1=Zeichen für Namen erlaubt
                DC.B 1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1 ;0=Zeichen ist Endekennung
                DC.B 0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0
                DC.B -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0 ;-1=Zeichen ist als
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 ;erstes Zeichen verboten
                DC.B 1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
                DC.B 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0
                ENDPART
                >PART 'upper_tab' ;Umwandlungstabelle in Großbuchstaben
************************************************************************
*  Tabelle für Umwandlung in Großbuchstaben                            *
************************************************************************
upper_tab:      DC.B $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
                DC.B $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1A,$1B,$1C,$1D,$1E,$1F
                DC.B $20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$2A,$2B,$2C,$2D,$2E,$2F
                DC.B $30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$3A,$3B,$3C,$3D,$3E,$3F
                DC.B $40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$4A,$4B,$4C,$4D,$4E,$4F
                DC.B $50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$5A,$5B,$5C,$5D,$5E,$5F
                DC.B $60,$41,$42,$43,$44,$45,$46,$47,$48,$49,$4A,$4B,$4C,$4D,$4E,$4F
                DC.B $50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$5A,$7B,$7C,$7D,$7E,$7F
                DC.B $80,$9A,$82,$83,$8E,$85,$86,$80,$88,$89,$8A,$8B,$8C,$8D,$8E,$8F
                DC.B $90,$91,$92,$93,$99,$95,$96,$97,$98,$99,$9A,$9B,$9C,$9D,$9E,$9F
                DC.B $A0,$A1,$A2,$A3,$A4,$A5,$A6,$A7,$A8,$A9,$AA,$AB,$AC,$AD,$AE,$AF
                DC.B $B0,$B1,$B2,$B3,$B4,$B5,$B6,$B7,$B8,$B9,$BA,$BB,$BC,$BD,$BE,$BF
                DC.B $C0,$C1,$C2,$C3,$C4,$C5,$C6,$C7,$C8,$C9,$CA,$CB,$CC,$CD,$CE,$CF
                DC.B $D0,$D1,$D2,$D3,$D4,$D5,$D6,$D7,$D8,$D9,$DA,$DB,$DC,$DD,$DE,$DF
                DC.B $E0,$E1,$E2,$E3,$E4,$E5,$E6,$E7,$E8,$E9,$EA,$EB,$EC,$ED,$EE,$EF
                DC.B $F0,$F1,$F2,$F3,$F4,$F5,$F6,$F7,$F8,$F9,$FA,$FB,$FC,$FD,$FE,$FF
                ENDPART
                >PART 'lower_tab' ;Umwandlungstabelle in Kleinbuchstaben
************************************************************************
*  Tabelle für Umwandlung in Kleinbuchstaben                           *
************************************************************************
lower_tab:      DC.B $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
                DC.B $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1A,$1B,$1C,$1D,$1E,$1F
                DC.B $20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$2A,$2B,$2C,$2D,$2E,$2F
                DC.B $30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$3A,$3B,$3C,$3D,$3E,$3F
                DC.B $40,$61,$62,$63,$64,$65,$66,$67,$68,$69,$6A,$6B,$6C,$6D,$6E,$6F
                DC.B $70,$71,$72,$73,$74,$75,$76,$77,$78,$79,$7A,$5B,$5C,$5D,$5E,$5F
                DC.B $60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$6A,$6B,$6C,$6D,$6E,$6F
                DC.B $70,$71,$72,$73,$74,$75,$76,$77,$78,$79,$7A,$7B,$7C,$7D,$7E,$7F
                DC.B $87,$81,$82,$83,$84,$85,$86,$87,$88,$89,$8A,$8B,$8C,$8D,$84,$86
                DC.B $90,$91,$92,$93,$94,$95,$96,$97,$98,$94,$81,$9B,$9C,$9D,$9E,$9F
                DC.B $A0,$A1,$A2,$A3,$A4,$A5,$A6,$A7,$A8,$A9,$AA,$AB,$AC,$AD,$AE,$AF
                DC.B $B0,$B1,$B2,$B3,$B4,$B5,$B6,$B7,$B8,$B9,$BA,$BB,$BC,$BD,$BE,$BF
                DC.B $C0,$C1,$C2,$C3,$C4,$C5,$C6,$C7,$C8,$C9,$CA,$CB,$CC,$CD,$CE,$CF
                DC.B $D0,$D1,$D2,$D3,$D4,$D5,$D6,$D7,$D8,$D9,$DA,$DB,$DC,$DD,$DE,$DF
                DC.B $E0,$E1,$E2,$E3,$E4,$E5,$E6,$E7,$E8,$E9,$EA,$EB,$EC,$ED,$EE,$EF
                DC.B $F0,$F1,$F2,$F3,$F4,$F5,$F6,$F7,$F8,$F9,$FA,$FB,$FC,$FD,$FE,$FF
                ENDPART
                >PART 'Infozeilentexte'
************************************************************************
*  Texte des Editors
************************************************************************
top_text:       SWITCH sprache
                CASE 0
                DC.B 'Z:      Sp:    ',0
                CASE 1
                DC.B 'L:      Co:    ',0
                ENDS
                ENDPART
                >PART 'Fehlermeldungen'
************************************************************************
*  Texte und Adressen der Fehlermeldungen                              *
************************************************************************
                DC.B 0
_e0:            DC.B '                                              ',0
                SWITCH sprache
                CASE 0
_e1:            DC.B 'Syntax-Fehler',0
_e2:            DC.B 'Illegaler Symbolname',0
_e3:            DC.B 'Unbekannter Befehl',0
_e4:            DC.B 'Doppelte Deklaration',0
_e5:            DC.B 'Wert zu groß / zu klein',0
_e6:            DC.B 'Symbolname zu lang',0
_e7:            DC.B 'Unzulässige Adressierung',0
_e8:            DC.B 'Operandensyntax falsch',0
_e9:            DC.B 'Zweiter Operand fehlt',0
_e10:           DC.B 'Unerlaubte Extension',0
_e11:           DC.B 'Position außerhalb der Datei',0
_e12:           DC.B 'Fehler beim Speichern',0
_e13:           DC.B 'Ausdruck zu komplex',0
_e14:           DC.B 'Unerlaubter Operand',0
_e15:           DC.B 'Im BSS-Bereich nicht erlaubt',0
_e16:           DC.B 'Zu viele Parameter',0
_e17:           DC.B 'INTERNAL ERROR',0
_e18:           DC.B 'Offset zu groß',0
_e19:           DC.B 'Symbol nicht definiert',0
_e20:           DC.B 'Offset/Wert wird negativ',0
_e21:           DC.B 'Symbol wird nicht benutzt',0
_e22:           DC.B 'Label hier nicht erlaubt',0
_e23:           DC.B 'Offset zu klein',0
_e24:           DC.B 'Division durch Null',0
_e25:           DC.B 'Adresse wurde begradigt',0
_e26:           DC.B 'Falsche Segmentfolge',0
_e27:           DC.B 'Filename zu lang',0
_e28:           DC.B 'Illegaler Filename',0
_e29:           DC.B 'Unerlaubte Rechenoperation',0
_e30:           DC.B 'String zu lang',0
_e31:           DC.B 'B??.S in NOP gewandelt',0
_e32:           DC.B 'IF nicht abgeschlossen',0
_e33:           DC.B 'ELSE ohne IF',0
_e34:           DC.B 'ENDC ohne IF',0
_e35:           DC.B 'REPT nicht abgeschlossen',0
_e36:           DC.B 'ENDR ohne REPT',0
_e37:           DC.B 'EQU-Wert nicht änderbar',0
_e38:           DC.B 'SWITCH nicht abgeschlossen',0
_e39:           DC.B 'CASE ohne SWITCH',0
_e40:           DC.B 'ENDS ohne SWITCH',0
_e41:           DC.B 'Kann zu B??.S optimiert werden',0
_e42:           DC.B 'Kann zu relativen Sprung optimiert werden',0
_e43:           DC.B 'Gleiche Parameternummern',0
_e44:           DC.B 'Zu wenig Parameter',0
_e45:           DC.B 'Name bereits reserviert',0
_e46:           DC.B 'Long-Adressierung einer RS-Konstante',0
_e47:           DC.B 'Änderung nicht erwünscht!',0
_e48:           DC.B 'Sprung auf die nächste Adresse',0
_e49:           DC.B 'Unnötiger Sprungbefehl',0
_e50:           DC.B 'PC-relative Adressierung möglich',0
_e51:           DC.B 'Wandlung nach PEA sinnvoll',0
_e52:           DC.B 'Wandlung nach LEA sinnvoll',0
_e54:           DC.B 'Kann zu SHORT optimiert werden',0
_e56:           DC.B 'PC-relative Adressierung über Segmentgrenze',0
_e57:           DC.B 'Um 4 Takte optimiert (12 auf 8 bzw. 8 auf 4)',0
                EVEN
                CASE 1
_e1:            DC.B 'Syntax error',0
_e2:            DC.B 'Illegal symbolname',0
_e3:            DC.B 'Unknown command',0
_e4:            DC.B 'Symbol declared twice',0
_e5:            DC.B 'Value out of range',0
_e6:            DC.B 'Symbolname too long',0
_e7:            DC.B 'Illegal addressing mode',0
_e8:            DC.B 'Operandsytax wrong',0
_e9:            DC.B 'Second operand missing',0
_e10:           DC.B 'Illegal extension',0
_e11:           DC.B 'Pointer out of file',0
_e12:           DC.B 'Error during saving',0
_e13:           DC.B 'Formula too complex',0
_e14:           DC.B 'Illegal operand',0
_e15:           DC.B 'In BSS not allowed',0
_e16:           DC.B 'Too many parameter',0
_e17:           DC.B 'INTERNAL ERROR',0
_e18:           DC.B 'Offset too big',0
_e19:           DC.B 'Symbol not defined',0
_e20:           DC.B 'Offset/value becomes negative',0
_e21:           DC.B 'Symbol is not used',0
_e22:           DC.B 'Label not allowed here',0
_e23:           DC.B 'Offset too small',0
_e24:           DC.B 'Division by zero',0
_e25:           DC.B 'Address has been aligned',0
_e26:           DC.B 'Wrong sequence of segments',0
_e27:           DC.B 'Filename too long',0
_e28:           DC.B 'Illegal filename',0
_e29:           DC.B 'Illegal opreation',0
_e30:           DC.B 'String too long',0
_e31:           DC.B 'B??.S converted to NOP',0
_e32:           DC.B 'IF not closed',0
_e33:           DC.B 'ELSE without IF',0
_e34:           DC.B 'ENDC without IF',0
_e35:           DC.B 'REPT not closed',0
_e36:           DC.B 'ENDR without REPT',0
_e37:           DC.B 'EQU-Wert nicht änderbar',0
_e38:           DC.B 'SWITCH not closed',0
_e39:           DC.B 'CASE without SWITCH',0
_e40:           DC.B 'ENDS without SWITCH',0
_e41:           DC.B 'Can optimized to B??.S',0
_e42:           DC.B 'Can optimized to relative jump',0
_e43:           DC.B 'Same parameternumbers',0
_e44:           DC.B 'Missing parameters',0
_e45:           DC.B 'Name already reserved',0
_e46:           DC.B 'Long-Addressed RS-constant',0
_e47:           DC.B 'Editing not allowed!',0
_e48:           DC.B 'Jump to next address',0
_e49:           DC.B 'Unnecessary jump',0
_e50:           DC.B 'PC-relativ addressing possible',0
_e51:           DC.B 'Converting to PEA efficient',0
_e52:           DC.B 'Converting to LEA efficient',0
_e54:           DC.B 'Can optimized to SHORT',0
_e56:           DC.B 'PC-relativ addressing over segmentlimits',0
_e57:           DC.B 'Optimized by 4 cycles (12 to 8 or 8 to 4)',0
                EVEN
                ENDS
                BASE DC.W,err_adr
err_adr:        DC.W _e0,_e1,_e2,_e3,_e4,_e5,_e6,_e7,_e8,_e9
                DC.W _e10,_e11,_e12,_e13,_e14,_e15,_e16,_e17,_e18,_e19
                DC.W _e20,_e21,_e22,_e23,_e24,_e25,_e26,_e27,_e28,_e29
                DC.W _e30,_e31,_e32,_e33,_e34,_e35,_e36,_e37,_e38,_e39
                DC.W _e40,_e41,_e42,_e43,_e44,_e45,_e46,_e47,_e48,_e49
                DC.W _e50,_e51,_e52,_e18,_e54,_e50,_e56,_e57
                ENDPART

                >PART 'cmd_tab' ;Tabelle für ESC-Befehle
************************************************************************
* Tabelle der Offsets auf die Befehlsnamen für ESC                     *
************************************************************************
                BASE DC.W,*
cmd_tab:        DC.W e_sa
                DC.W e_sb
                DC.W e_sc
                DC.W e_sd
                DC.W e_se
                DC.W 0          ;e_sf-cmd_tab
                DC.W 0          ;e_sg-cmd_tab
                DC.W 0          ;e_sh-cmd_tab
                DC.W e_si
                DC.W e_sj
                DC.W 0          ;e_sk-cmd_tab
                DC.W e_sl
                DC.W e_sm
                DC.W e_sn
                DC.W e_so
                DC.W e_sp
                DC.W e_sq
                DC.W e_sr
                DC.W e_ss
                DC.W e_st
                DC.W 0          ;e_su-cmd_tab
                DC.W 0          ;e_sv-cmd_tab
                DC.W 0          ;e_sw-cmd_tab
                DC.W 0          ;e_sx-cmd_tab
                DC.W 0          ;e_sy-cmd_tab
                DC.W 0          ;e_sz-cmd_tab
                DC.W e_a
                DC.W e_b
                DC.W e_c
                DC.W e_d
                DC.W e_e
                DC.W e_f
                DC.W 0          ;e_g-cmd_tab
                DC.W 0          ;e_h-cmd_tab
                DC.W e_i
                DC.W e_j
                DC.W 0          ;e_k-cmd_tab
                DC.W e_l
                DC.W e_m
                DC.W e_n
                DC.W e_o
                DC.W e_p
                DC.W e_q
                DC.W e_r
                DC.W e_s
                DC.W e_t
                DC.W e_u
                DC.W 0          ;e_v-cmd_tab
                DC.W 0          ;e_w-cmd_tab
                DC.W e_x
                DC.W 0          ;e_y-cmd_tab
                DC.W 0          ;e_z-cmd_tab
                ENDPART
                >PART 'code_tab' ;Befehlstabelle
************************************************************************
* Hier steht die Tabelle aller Befehle & Opcodes                       *
************************************************************************
code_tab:       DC.B '.=      '
                DC.L t_set
                DC.B 1,0,0,0
                DC.B '.BSS    '
                DC.L t_bss
                DC.B 1,1,0,0
                DC.B '.COMM   '
                DC.L t_common
                DC.B 1,0,0,0
                DC.B '.COMMON '
                DC.L t_common
                DC.B 1,0,0,0
                DC.B '.DATA   '
                DC.L t_data
                DC.B 1,1,0,0
                DC.B '.DC.B   '
                DC.L t_dcb
                DC.B 1,0,0,0
                DC.B '.DC.L   '
                DC.L t_dcl
                DC.B 1,0,0,0
                DC.B '.DC.W   '
                DC.L t_dcw
                DC.B 1,0,0,0
                DC.B '.DS.B   '
                DC.L t_dsb
                DC.B 1,0,0,0
                DC.B '.DS.L   '
                DC.L t_dsl
                DC.B 1,0,0,0
                DC.B '.DS.W   '
                DC.L t_dsw
                DC.B 1,0,0,0
                DC.B '.END    '
                DC.L t_end
                DC.B 1,0,0,0
                DC.B '.ENDC   '
                DC.L t_endc
                DC.B 1,0,0,0
                DC.B '.ENDR   '
                DC.L t_endr
                DC.B 1,0,0,0
                DC.B '.EQU    '
                DC.L t_equ
                DC.B 1,0,0,0
                DC.B '.EVEN   '
                DC.L t_even
                DC.B 1,0,0,0
                DC.B '.EXTERN '
                DC.L t_global
                DC.B 1,0,0,0
                DC.B '.GLOBL  '
                DC.L t_global
                DC.B 1,0,0,0
                DC.B '.PUBLIC '
                DC.L t_global
                DC.B 1,0,0,0
                DC.B '.REPT   '
                DC.L t_rept
                DC.B 1,0,0,0
                DC.B '.SET    '
                DC.L t_set
                DC.B 1,0,0,0
                DC.B '.TEXT   '
                DC.L t_text
                DC.B 1,0,0,0
                DC.B '.XDEF   '
                DC.L t_global
                DC.B 1,0,0,0
                DC.B '.XREF   '
                DC.L t_global
                DC.B 1,0,0,0
                DC.B '=       '
                DC.L t_equ
                DC.B 1,0,0,0
                DC.B '==      '
                DC.L t_equg
                DC.B 1,0,0,0
                DC.B '>PART   '
                DC.L t_part
                DC.B 1,0,0,0
                DC.B 'ABCD    '
                DC.L t_abcd
                DC.B 0,0,$C1,0
                DC.B 'ABCD.B  '
                DC.L t_abcd
                DC.B 0,0,$C1,0
                DC.B 'ADD     '
                DC.L t_add
                DC.B 0,0,$D0,$40
                DC.B 'ADD.B   '
                DC.L t_addb
                DC.B 0,0,$D0,0
e_sa:           DC.B 'ADD.L   '
                DC.L t_add
                DC.B 0,0,$D0,$80
e_a:            DC.B 'ADD.W   '
                DC.L t_add
                DC.B 0,0,$D0,$40
                DC.B 'ADDA    '
                DC.L t_adda
                DC.B 0,$80,$D0,$C0
                DC.B 'ADDA.L  '
                DC.L t_adda
                DC.B 0,$80,$D1,$C0
                DC.B 'ADDA.W  '
                DC.L t_adda
                DC.B 0,$80,$D0,$C0
                DC.B 'ADDI    '
                DC.L t_addi
                DC.B 0,0,6,$40
                DC.B 'ADDI.B  '
                DC.L t_addi
                DC.B 0,0,6,0
                DC.B 'ADDI.L  '
                DC.L t_addi
                DC.B 0,0,6,$80
                DC.B 'ADDI.W  '
                DC.L t_addi
                DC.B 0,0,6,$40
e_q:            DC.B 'ADDQ    '
                DC.L t_addq
                DC.B 0,0,$50,$40
                DC.B 'ADDQ.B  '
                DC.L t_addq
                DC.B 0,0,$50,0
                DC.B 'ADDQ.L  '
                DC.L t_addq
                DC.B 0,0,$50,$80
                DC.B 'ADDQ.W  '
                DC.L t_addq
                DC.B 0,0,$50,$40
                DC.B 'ADDX    '
                DC.L t_abcd
                DC.B 0,0,$D1,$40
                DC.B 'ADDX.B  '
                DC.L t_abcd
                DC.B 0,0,$D1,0
                DC.B 'ADDX.L  '
                DC.L t_abcd
                DC.B 0,0,$D1,$80
                DC.B 'ADDX.W  '
                DC.L t_abcd
                DC.B 0,0,$D1,$40
                DC.B 'ALIGN   '
                DC.L t_even
                DC.B 1,0,0,0
                DC.B 'ALIGN.W '
                DC.L t_even
                DC.B 1,0,0,0
                DC.B 'AND     '
                DC.L t_and
                DC.B 0,0,$C0,$40
                DC.B 'AND.B   '
                DC.L t_and
                DC.B 0,0,$C0,0
                DC.B 'AND.L   '
                DC.L t_and
                DC.B 0,0,$C0,$80
                DC.B 'AND.W   '
                DC.L t_and
                DC.B 0,0,$C0,$40
                DC.B 'ANDI    '
                DC.L t_andi
                DC.B 0,0,2,$40
                DC.B 'ANDI.B  '
                DC.L t_andi
                DC.B 0,0,2,0
                DC.B 'ANDI.L  '
                DC.L t_andi
                DC.B 0,0,2,$80
                DC.B 'ANDI.W  '
                DC.L t_andi
                DC.B 0,0,2,$40
                DC.B 'ASL     '
                DC.L t_asl
                DC.B 0,0,$E1,$40
                DC.B 'ASL.B   '
                DC.L t_asl
                DC.B 0,0,$E1,0
                DC.B 'ASL.L   '
                DC.L t_asl
                DC.B 0,0,$E1,$80
                DC.B 'ASL.W   '
                DC.L t_asl
                DC.B 0,0,$E1,$40
                DC.B 'ASR     '
                DC.L t_asl
                DC.B 0,0,$E0,$40
                DC.B 'ASR.B   '
                DC.L t_asl
                DC.B 0,0,$E0,0
                DC.B 'ASR.L   '
                DC.L t_asl
                DC.B 0,0,$E0,$80
                DC.B 'ASR.W   '
                DC.L t_asl
                DC.B 0,0,$E0,$40
                DC.B 'BASE    '
                DC.L t_base
                DC.B 1,0,0,0
                DC.B 'BCC     '
                DC.L t_bcc
                DC.B 0,0,$64,0
                DC.B 'BCC.B   '
                DC.L t_bccs
                DC.B 0,0,$64,0
                DC.B 'BCC.L   '
                DC.L t_bcc
                DC.B 0,0,$64,0
                DC.B 'BCC.S   '
                DC.L t_bccs
                DC.B 0,0,$64,0
                DC.B 'BCC.W   '
                DC.L t_bcc
                DC.B 0,0,$64,0
                DC.B 'BCHG    '
                DC.L t_bchg
                DC.B 0,0,1,$40
                DC.B 'BCHG.B  '
                DC.L t_bchg
                DC.B 0,0,1,$40
                DC.B 'BCHG.L  '
                DC.L t_bchg
                DC.B 0,0,1,$40
                DC.B 'BCLR    '
                DC.L t_bchg
                DC.B 0,0,1,$80
                DC.B 'BCLR.B  '
                DC.L t_bchg
                DC.B 0,0,1,$80
                DC.B 'BCLR.L  '
                DC.L t_bchg
                DC.B 0,0,1,$80
                DC.B 'BCS     '
                DC.L t_bcc
                DC.B 0,0,$65,0
                DC.B 'BCS.B   '
                DC.L t_bccs
                DC.B 0,0,$65,0
                DC.B 'BCS.L   '
                DC.L t_bcc
                DC.B 0,0,$65,0
                DC.B 'BCS.S   '
                DC.L t_bccs
                DC.B 0,0,$65,0
                DC.B 'BCS.W   '
                DC.L t_bcc
                DC.B 0,0,$65,0
                DC.B 'BEQ     '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'BEQ.B   '
                DC.L t_bccs
                DC.B 0,0,$67,0
                DC.B 'BEQ.L   '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'BEQ.S   '
                DC.L t_bccs
                DC.B 0,0,$67,0
                DC.B 'BEQ.W   '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'BGE     '
                DC.L t_bcc
                DC.B 0,0,$6C,0
                DC.B 'BGE.B   '
                DC.L t_bccs
                DC.B 0,0,$6C,0
                DC.B 'BGE.L   '
                DC.L t_bcc
                DC.B 0,0,$6C,0
                DC.B 'BGE.S   '
                DC.L t_bccs
                DC.B 0,0,$6C,0
                DC.B 'BGE.W   '
                DC.L t_bcc
                DC.B 0,0,$6C,0
                DC.B 'BGT     '
                DC.L t_bcc
                DC.B 0,0,$6E,0
                DC.B 'BGT.B   '
                DC.L t_bccs
                DC.B 0,0,$6E,0
                DC.B 'BGT.L   '
                DC.L t_bcc
                DC.B 0,0,$6E,0
                DC.B 'BGT.S   '
                DC.L t_bccs
                DC.B 0,0,$6E,0
                DC.B 'BGT.W   '
                DC.L t_bcc
                DC.B 0,0,$6E,0
                DC.B 'BHI     '
                DC.L t_bcc
                DC.B 0,0,$62,0
                DC.B 'BHI.B   '
                DC.L t_bccs
                DC.B 0,0,$62,0
                DC.B 'BHI.L   '
                DC.L t_bcc
                DC.B 0,0,$62,0
                DC.B 'BHI.S   '
                DC.L t_bccs
                DC.B 0,0,$62,0
                DC.B 'BHI.W   '
                DC.L t_bcc
                DC.B 0,0,$62,0
                DC.B 'BHS     '
                DC.L t_bcc
                DC.B 0,1,$64,0
                DC.B 'BHS.B   '
                DC.L t_bccs
                DC.B 0,1,$64,0
                DC.B 'BHS.L   '
                DC.L t_bcc
                DC.B 0,1,$64,0
                DC.B 'BHS.S   '
                DC.L t_bccs
                DC.B 0,1,$64,0
                DC.B 'BHS.W   '
                DC.L t_bcc
                DC.B 0,1,$64,0
                DC.B 'BKPT    '
                DC.L t_trap
                DC.B 0,0,$48,$48
                DC.B 'BLE     '
                DC.L t_bcc
                DC.B 0,0,$6F,0
                DC.B 'BLE.B   '
                DC.L t_bccs
                DC.B 0,0,$6F,0
                DC.B 'BLE.L   '
                DC.L t_bcc
                DC.B 0,0,$6F,0
                DC.B 'BLE.S   '
                DC.L t_bccs
                DC.B 0,0,$6F,0
                DC.B 'BLE.W   '
                DC.L t_bcc
                DC.B 0,0,$6F,0
                DC.B 'BLK     '
                DC.L t_dsw
                DC.B 1,0,0,0
                DC.B 'BLK.B   '
                DC.L t_dsb
                DC.B 1,0,0,0
                DC.B 'BLK.L   '
                DC.L t_dsl
                DC.B 1,0,0,0
                DC.B 'BLK.W   '
                DC.L t_dsw
                DC.B 1,0,0,0
                DC.B 'BLO     '
                DC.L t_bcc
                DC.B 0,1,$65,0
                DC.B 'BLO.B   '
                DC.L t_bccs
                DC.B 0,1,$65,0
                DC.B 'BLO.L   '
                DC.L t_bcc
                DC.B 0,1,$65,0
                DC.B 'BLO.S   '
                DC.L t_bccs
                DC.B 0,1,$65,0
                DC.B 'BLO.W   '
                DC.L t_bcc
                DC.B 0,1,$65,0
                DC.B 'BLS     '
                DC.L t_bcc
                DC.B 0,0,$63,0
                DC.B 'BLS.B   '
                DC.L t_bccs
                DC.B 0,0,$63,0
                DC.B 'BLS.L   '
                DC.L t_bcc
                DC.B 0,0,$63,0
                DC.B 'BLS.S   '
                DC.L t_bccs
                DC.B 0,0,$63,0
                DC.B 'BLS.W   '
                DC.L t_bcc
                DC.B 0,0,$63,0
                DC.B 'BLT     '
                DC.L t_bcc
                DC.B 0,0,$6D,0
                DC.B 'BLT.B   '
                DC.L t_bccs
                DC.B 0,0,$6D,0
                DC.B 'BLT.L   '
                DC.L t_bcc
                DC.B 0,0,$6D,0
                DC.B 'BLT.S   '
                DC.L t_bccs
                DC.B 0,0,$6D,0
                DC.B 'BLT.W   '
                DC.L t_bcc
                DC.B 0,0,$6D,0
                DC.B 'BMI     '
                DC.L t_bcc
                DC.B 0,0,$6B,0
                DC.B 'BMI.B   '
                DC.L t_bccs
                DC.B 0,0,$6B,0
                DC.B 'BMI.L   '
                DC.L t_bcc
                DC.B 0,0,$6B,0
                DC.B 'BMI.S   '
                DC.L t_bccs
                DC.B 0,0,$6B,0
                DC.B 'BMI.W   '
                DC.L t_bcc
                DC.B 0,0,$6B,0
                DC.B 'BNE     '
                DC.L t_bcc
                DC.B 0,0,$66,0
                DC.B 'BNE.B   '
                DC.L t_bccs
                DC.B 0,0,$66,0
                DC.B 'BNE.L   '
                DC.L t_bcc
                DC.B 0,0,$66,0
                DC.B 'BNE.S   '
                DC.L t_bccs
                DC.B 0,0,$66,0
                DC.B 'BNE.W   '
                DC.L t_bcc
                DC.B 0,0,$66,0
                DC.B 'BNZ     '
                DC.L t_bcc
                DC.B 0,0,$66,0
                DC.B 'BNZ.B   '
                DC.L t_bccs
                DC.B 0,0,$66,0
                DC.B 'BNZ.L   '
                DC.L t_bcc
                DC.B 0,0,$66,0
                DC.B 'BNZ.S   '
                DC.L t_bccs
                DC.B 0,0,$66,0
                DC.B 'BNZ.W   '
                DC.L t_bcc
                DC.B 0,0,$66,0
                DC.B 'BPL     '
                DC.L t_bcc
                DC.B 0,0,$6A,0
                DC.B 'BPL.B   '
                DC.L t_bccs
                DC.B 0,0,$6A,0
                DC.B 'BPL.L   '
                DC.L t_bcc
                DC.B 0,0,$6A,0
                DC.B 'BPL.S   '
                DC.L t_bccs
                DC.B 0,0,$6A,0
                DC.B 'BPL.W   '
                DC.L t_bcc
                DC.B 0,0,$6A,0
e_b:            DC.B 'BRA     '
                DC.L t_bcc
                DC.B 0,0,$60,0
                DC.B 'BRA.B   '
                DC.L t_bccs
                DC.B 0,0,$60,0
                DC.B 'BRA.L   '
                DC.L t_bcc
                DC.B 0,0,$60,0
                DC.B 'BRA.S   '
                DC.L t_bccs
                DC.B 0,0,$60,0
                DC.B 'BRA.W   '
                DC.L t_bcc
                DC.B 0,0,$60,0
                DC.B 'BREAKPT '
                DC.L t_breakp
                DC.B 1,0,0,0
                DC.B 'BSET    '
                DC.L t_bchg
                DC.B 0,0,1,$C0
                DC.B 'BSET.B  '
                DC.L t_bchg
                DC.B 0,0,1,$C0
                DC.B 'BSET.L  '
                DC.L t_bchg
                DC.B 0,0,1,$C0
e_sb:           DC.B 'BSR     '
                DC.L t_bcc
                DC.B 0,0,$61,0
                DC.B 'BSR.B   '
                DC.L t_bccs
                DC.B 0,0,$61,0
                DC.B 'BSR.L   '
                DC.L t_bcc
                DC.B 0,0,$61,0
                DC.B 'BSR.S   '
                DC.L t_bccs
                DC.B 0,0,$61,0
                DC.B 'BSR.W   '
                DC.L t_bcc
                DC.B 0,0,$61,0
                DC.B 'BSS     '
                DC.L t_bss
                DC.B 1,3,0,0
                DC.B 'BTST    '
                DC.L t_btst
                DC.B 0,0,1,0
                DC.B 'BTST.B  '
                DC.L t_btst
                DC.B 0,0,1,0
                DC.B 'BTST.L  '
                DC.L t_btst
                DC.B 0,0,1,0
                DC.B 'BVC     '
                DC.L t_bcc
                DC.B 0,0,$68,0
                DC.B 'BVC.B   '
                DC.L t_bccs
                DC.B 0,0,$68,0
                DC.B 'BVC.L   '
                DC.L t_bcc
                DC.B 0,0,$68,0
                DC.B 'BVC.S   '
                DC.L t_bccs
                DC.B 0,0,$68,0
                DC.B 'BVC.W   '
                DC.L t_bcc
                DC.B 0,0,$68,0
                DC.B 'BVS     '
                DC.L t_bcc
                DC.B 0,0,$69,0
                DC.B 'BVS.B   '
                DC.L t_bccs
                DC.B 0,0,$69,0
                DC.B 'BVS.L   '
                DC.L t_bcc
                DC.B 0,0,$69,0
                DC.B 'BVS.S   '
                DC.L t_bccs
                DC.B 0,0,$69,0
                DC.B 'BVS.W   '
                DC.L t_bcc
                DC.B 0,0,$69,0
                DC.B 'BZ      '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'BZ.B    '
                DC.L t_bccs
                DC.B 0,0,$67,0
                DC.B 'BZ.L    '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'BZ.S    '
                DC.L t_bccs
                DC.B 0,0,$67,0
                DC.B 'BZ.W    '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'BZE     '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'BZE.B   '
                DC.L t_bccs
                DC.B 0,0,$67,0
                DC.B 'BZE.L   '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'BZE.S   '
                DC.L t_bccs
                DC.B 0,0,$67,0
                DC.B 'BZE.W   '
                DC.L t_bcc
                DC.B 0,0,$67,0
                DC.B 'CASE    '
                DC.L t_case
                DC.B 1,0,0,0
                DC.B 'CHK     '
                DC.L t_chk
                DC.B 0,3,$41,$80
e_sc:           DC.B 'CLR     '
                DC.L t_clr
                DC.B 0,0,$42,$40
                DC.B 'CLR.B   '
                DC.L t_tst
                DC.B 0,0,$42,0
                DC.B 'CLR.L   '
                DC.L t_clr
                DC.B 0,0,$42,$80
                DC.B 'CLR.W   '
                DC.L t_clr
                DC.B 0,0,$42,$40
e_c:            DC.B 'CMP     '
                DC.L t_cmp
                DC.B 0,0,$B0,$40
                DC.B 'CMP.B   '
                DC.L t_cmpb
                DC.B 0,0,$B0,0
                DC.B 'CMP.L   '
                DC.L t_cmp
                DC.B 0,0,$B0,$80
                DC.B 'CMP.W   '
                DC.L t_cmp
                DC.B 0,0,$B0,$40
                DC.B 'CMPA    '
                DC.L t_adda
                DC.B 0,$80,$B0,$C0
                DC.B 'CMPA.L  '
                DC.L t_adda
                DC.B 0,$80,$B1,$C0
                DC.B 'CMPA.W  '
                DC.L t_adda
                DC.B 0,$80,$B0,$C0
                DC.B 'CMPI    '
                DC.L t_addi
                DC.B 0,0,$0C,$40
                DC.B 'CMPI.B  '
                DC.L t_addi
                DC.B 0,0,$0C,0
                DC.B 'CMPI.L  '
                DC.L t_addi
                DC.B 0,0,$0C,$80
                DC.B 'CMPI.W  '
                DC.L t_addi
                DC.B 0,0,$0C,$40
                DC.B 'CMPM    '
                DC.L t_cmpm
                DC.B 0,0,$B1,$48
                DC.B 'CMPM.B  '
                DC.L t_cmpm
                DC.B 0,0,$B1,8
                DC.B 'CMPM.L  '
                DC.L t_cmpm
                DC.B 0,0,$B1,$88
                DC.B 'CMPM.W  '
                DC.L t_cmpm
                DC.B 0,0,$B1,$48
                DC.B 'CNOP    '
                DC.L t_cnop
                DC.B 1,0,0,0
                DC.B 'COMM    '
                DC.L t_common
                DC.B 1,0,0,0
                DC.B 'COMMON  '
                DC.L t_common
                DC.B 1,0,0,0
                DC.B 'DATA    '
                DC.L t_data
                DC.B 1,2,0,0
                DC.B 'DBCC    '
                DC.L t_dbcc
                DC.B 0,0,$54,$C8
                DC.B 'DBCS    '
                DC.L t_dbcc
                DC.B 0,0,$55,$C8
                DC.B 'DBEQ    '
                DC.L t_dbcc
                DC.B 0,0,$57,$C8
                DC.B 'DBF     '
                DC.L t_dbcc
                DC.B 0,0,$51,$C8
                DC.B 'DBGE    '
                DC.L t_dbcc
                DC.B 0,0,$5C,$C8
                DC.B 'DBGT    '
                DC.L t_dbcc
                DC.B 0,0,$5E,$C8
                DC.B 'DBHI    '
                DC.L t_dbcc
                DC.B 0,0,$52,$C8
                DC.B 'DBHS    '
                DC.L t_dbcc
                DC.B 0,0,$54,$C8
                DC.B 'DBLE    '
                DC.L t_dbcc
                DC.B 0,0,$5F,$C8
                DC.B 'DBLO    '
                DC.L t_dbcc
                DC.B 0,0,$55,$C8
                DC.B 'DBLS    '
                DC.L t_dbcc
                DC.B 0,0,$53,$C8
                DC.B 'DBLT    '
                DC.L t_dbcc
                DC.B 0,0,$5D,$C8
                DC.B 'DBMI    '
                DC.L t_dbcc
                DC.B 0,0,$5B,$C8
                DC.B 'DBNE    '
                DC.L t_dbcc
                DC.B 0,0,$56,$C8
                DC.B 'DBNZ    '
                DC.L t_dbcc
                DC.B 0,0,$56,$C8
                DC.B 'DBPL    '
                DC.L t_dbcc
                DC.B 0,0,$5A,$C8
e_d:            DC.B 'DBRA    '
                DC.L t_dbcc
                DC.B 0,0,$51,$C8
                DC.B 'DBT     '
                DC.L t_dbcc
                DC.B 0,0,$50,$C8
                DC.B 'DBVC    '
                DC.L t_dbcc
                DC.B 0,0,$58,$C8
                DC.B 'DBVS    '
                DC.L t_dbcc
                DC.B 0,0,$59,$C8
                DC.B 'DBZE    '
                DC.L t_dbcc
                DC.B 0,0,$57,$C8
                DC.B 'DC      '
                DC.L t_dcw
                DC.B 1,0,0,0
                DC.B 'DC.B    '
                DC.L t_dcb
                DC.B 1,0,0,0
                DC.B 'DC.L    '
                DC.L t_dcl
                DC.B 1,0,0,0
                DC.B 'DC.W    '
                DC.L t_dcw
                DC.B 1,0,0,0
                DC.B 'DCB     '
                DC.L t_dswa
                DC.B 1,0,0,0
                DC.B 'DCB.B   '
                DC.L t_dsba
                DC.B 1,0,0,0
                DC.B 'DCB.L   '
                DC.L t_dsla
                DC.B 1,0,0,0
                DC.B 'DCB.W   '
                DC.L t_dswa
                DC.B 1,0,0,0
                DC.B 'DEFAULT '
                DC.L t_default
                DC.B 1,0,0,0
                DC.B 'DIVS    '
                DC.L t_chk
                DC.B 0,3,$81,$C0
                DC.B 'DIVS.W  '
                DC.L t_chk
                DC.B 0,3,$81,$C0
e_sd:           DC.B 'DIVU    '
                DC.L t_chk
                DC.B 0,3,$80,$C0
                DC.B 'DIVU.W  '
                DC.L t_chk
                DC.B 0,3,$80,$C0
                DC.B 'DS      '
                DC.L t_dsw
                DC.B 1,0,0,0
                DC.B 'DS.B    '
                DC.L t_dsb
                DC.B 1,0,0,0
                DC.B 'DS.L    '
                DC.L t_dsl
                DC.B 1,0,0,0
                DC.B 'DS.W    '
                DC.L t_dsw
                DC.B 1,0,0,0
                DC.B 'DSBSS   '
                DC.L t_dsw
                DC.B 1,0,0,0
                DC.B 'DSBSS.B '
                DC.L t_dsb
                DC.B 1,0,0,0
                DC.B 'DSBSS.L '
                DC.L t_dsl
                DC.B 1,0,0,0
                DC.B 'DSBSS.W '
                DC.L t_dsw
                DC.B 1,0,0,0
                DC.B 'DX      '
                DC.L t_dxb
                DC.B 1,0,0,0
                DC.B 'DX.B    '
                DC.L t_dxb
                DC.B 1,0,0,0
                DC.B 'DXSET   '
                DC.L t_dxset
                DC.B 1,0,0,0
                DC.B 'ELSE    '
                DC.L t_else
                DC.B 1,0,0,0
                DC.B 'END     '
                DC.L t_end
                DC.B 1,0,0,0
                DC.B 'ENDC    '
                DC.L t_endc
                DC.B 1,0,0,0
                DC.B 'ENDIF   '
                DC.L t_endc
                DC.B 1,0,0,0
                DC.B 'ENDP    '
                DC.L t_endpart
                DC.B 1,0,0,0
                DC.B 'ENDPART '
                DC.L t_endpart
                DC.B 1,0,0,0
                DC.B 'ENDR    '
                DC.L t_endr
                DC.B 1,0,0,0
                DC.B 'ENDS    '
                DC.L t_ends
                DC.B 1,0,0,0
e_e:            DC.B 'EOR     '
                DC.L t_eor
                DC.B 0,0,$B1,$40
                DC.B 'EOR.B   '
                DC.L t_eor
                DC.B 0,0,$B1,0
                DC.B 'EOR.L   '
                DC.L t_eor
                DC.B 0,0,$B1,$80
                DC.B 'EOR.W   '
                DC.L t_eor
                DC.B 0,0,$B1,$40
                DC.B 'EORI    '
                DC.L t_andi
                DC.B 0,0,$0A,$40
                DC.B 'EORI.B  '
                DC.L t_andi
                DC.B 0,0,$0A,0
                DC.B 'EORI.L  '
                DC.L t_andi
                DC.B 0,0,$0A,$80
                DC.B 'EORI.W  '
                DC.L t_andi
                DC.B 0,0,$0A,$40
                DC.B 'EQU     '
                DC.L t_equ
                DC.B 1,0,0,0
                DC.B 'EVEN    '
                DC.L t_even
                DC.B 1,0,0,0
                DC.B 'EXG     '
                DC.L t_exg
                DC.B 0,0,$C1,0
                DC.B 'EXG.L   '
                DC.L t_exg
                DC.B 0,0,$C1,0
e_se:           DC.B 'EXT     '
                DC.L t_ext
                DC.B 0,0,$48,$80
                DC.B 'EXT.L   '
                DC.L t_ext
                DC.B 0,0,$48,$C0
                DC.B 'EXT.W   '
                DC.L t_ext
                DC.B 0,0,$48,$80
e_f:            DC.B 'FAIL    '
                DC.L t_fail
                DC.B 1,0,0,0
                DC.B 'GLOBAL  '
                DC.L t_global
                DC.B 1,0,0,0
                DC.B 'GLOBL   '
                DC.L t_global
                DC.B 1,0,0,0
e_si:           DC.B 'IBYTES  '
                DC.L t_ibytes
                DC.B 1,0,0,0
                DC.B 'IF      '
                DC.L t_if
                DC.B 2,0,0,0
                DC.B 'IFD     '
                DC.L t_if
                DC.B $10,0,0,0
                DC.B 'IFEQ    '
                DC.L t_if
                DC.B 4,0,0,0
                DC.B 'IFGE    '
                DC.L t_if
                DC.B $0A,0,0,0
                DC.B 'IFGT    '
                DC.L t_if
                DC.B 8,0,0,0
                DC.B 'IFLE    '
                DC.L t_if
                DC.B $0E,0,0,0
                DC.B 'IFLT    '
                DC.L t_if
                DC.B $0C,0,0,0
                DC.B 'IFND    '
                DC.L t_if
                DC.B $12,0,0,0
                DC.B 'IFNE    '
                DC.L t_if
                DC.B 6,0,0,0
e_i:            DC.B 'ILLEGAL '
                DC.L t_nop
                DC.B 0,0,$4A,$FC
                DC.B 'INCBIN  '
                DC.L t_ibytes
                DC.B 1,0,0,0
                DC.B 'ISYMBOL '
                DC.L t_isymbol
                DC.B 1,0,0,0
e_sj:           DC.B 'JMP     '
                DC.L t_jmp
                DC.B 0,0,$4E,$C0
e_j:            DC.B 'JSR     '
                DC.L t_jmp
                DC.B 0,0,$4E,$80
e_l:            DC.B 'LEA     '
                DC.L t_lea
                DC.B 0,0,$41,$C0
                DC.B 'LEA.L   '
                DC.L t_lea
                DC.B 0,0,$41,$C0
                DC.B 'LEA.W   '
                DC.L t_lea
                DC.B 0,0,$41,$C0
                DC.B 'LINEA   '
                DC.L t_linea
                DC.B 0,0,$A0,0
                DC.B 'LINK    '
                DC.L t_link
                DC.B 0,0,$4E,$50
e_sl:           DC.B 'LSL     '
                DC.L t_asl
                DC.B 0,0,$E3,$48
                DC.B 'LSL.B   '
                DC.L t_asl
                DC.B 0,0,$E3,8
                DC.B 'LSL.L   '
                DC.L t_asl
                DC.B 0,0,$E3,$88
                DC.B 'LSL.W   '
                DC.L t_asl
                DC.B 0,0,$E3,$48
                DC.B 'LSR     '
                DC.L t_asl
                DC.B 0,0,$E2,$48
                DC.B 'LSR.B   '
                DC.L t_asl
                DC.B 0,0,$E2,8
                DC.B 'LSR.L   '
                DC.L t_asl
                DC.B 0,0,$E2,$88
                DC.B 'LSR.W   '
                DC.L t_asl
                DC.B 0,0,$E2,$48
e_m:            DC.B 'MOVE    '
                DC.L t_move
                DC.B 0,3,$30,0
                DC.B 'MOVE.B  '
                DC.L t_move
                DC.B 0,1,$10,0
                DC.B 'MOVE.L  '
                DC.L t_move
                DC.B 0,2,$20,0
                DC.B 'MOVE.W  '
                DC.L t_move
                DC.B 0,3,$30,0
                DC.B 'MOVEA   '
                DC.L t_move
                DC.B 0,3,$30,0
                DC.B 'MOVEA.L '
                DC.L t_move
                DC.B 0,2,$20,0
                DC.B 'MOVEA.W '
                DC.L t_move
                DC.B 0,3,$30,0
                DC.B 'MOVEM   '
                DC.L t_movem
                DC.B 0,0,$48,$80
                DC.B 'MOVEM.L '
                DC.L t_movem
                DC.B 0,0,$48,$C0
                DC.B 'MOVEM.W '
                DC.L t_movem
                DC.B 0,0,$48,$80
                DC.B 'MOVEP   '
                DC.L t_movep
                DC.B 0,0,1,8
                DC.B 'MOVEP.L '
                DC.L t_movep
                DC.B 0,0,1,$48
                DC.B 'MOVEP.W '
                DC.L t_movep
                DC.B 0,0,1,8
e_sq:           DC.B 'MOVEQ   '
                DC.L t_moveq
                DC.B 0,0,$70,0
                DC.B 'MOVEQ.L '
                DC.L t_moveq
                DC.B 0,0,$70,0
                DC.B 'MULS    '
                DC.L t_chk
                DC.B 0,3,$C1,$C0
                DC.B 'MULS.W  '
                DC.L t_chk
                DC.B 0,3,$C1,$C0
e_sm:           DC.B 'MULU    '
                DC.L t_chk
                DC.B 0,3,$C0,$C0
                DC.B 'MULU.W  '
                DC.L t_chk
                DC.B 0,3,$C0,$C0
                DC.B 'NBCD    '
                DC.L t_tst
                DC.B 0,0,$48,0
e_sn:           DC.B 'NEG     '
                DC.L t_tst
                DC.B 0,0,$44,$40
                DC.B 'NEG.B   '
                DC.L t_tst
                DC.B 0,0,$44,0
                DC.B 'NEG.L   '
                DC.L t_tst
                DC.B 0,0,$44,$80
                DC.B 'NEG.W   '
                DC.L t_tst
                DC.B 0,0,$44,$40
                DC.B 'NEGX    '
                DC.L t_tst
                DC.B 0,0,$40,$40
                DC.B 'NEGX.B  '
                DC.L t_tst
                DC.B 0,0,$40,0
                DC.B 'NEGX.L  '
                DC.L t_tst
                DC.B 0,0,$40,$80
                DC.B 'NEGX.W  '
                DC.L t_tst
                DC.B 0,0,$40,$40
                DC.B 'NOP     '
                DC.L t_nop
                DC.B 0,0,$4E,$71
e_n:            DC.B 'NOT     '
                DC.L t_tst
                DC.B 0,0,$46,$40
                DC.B 'NOT.B   '
                DC.L t_tst
                DC.B 0,0,$46,0
                DC.B 'NOT.L   '
                DC.L t_tst
                DC.B 0,0,$46,$80
                DC.B 'NOT.W   '
                DC.L t_tst
                DC.B 0,0,$46,$40
                DC.B 'OPT     '
                DC.L t_opt
                DC.B 1,0,0,0
e_o:            DC.B 'OR      '
                DC.L t_and
                DC.B 0,0,$80,$40
                DC.B 'OR.B    '
                DC.L t_and
                DC.B 0,0,$80,0
                DC.B 'OR.L    '
                DC.L t_and
                DC.B 0,0,$80,$80
                DC.B 'OR.W    '
                DC.L t_and
                DC.B 0,0,$80,$40
                DC.B 'ORG     '
                DC.L t_org
                DC.B 1,0,0,0
                DC.B 'ORI     '
                DC.L t_andi
                DC.B 0,0,0,$40
                DC.B 'ORI.B   '
                DC.L t_andi
                DC.B 0,0,0,0
                DC.B 'ORI.L   '
                DC.L t_andi
                DC.B 0,0,0,$80
                DC.B 'ORI.W   '
                DC.L t_andi
                DC.B 0,0,0,$40
e_so:           DC.B 'OUTPUT  '
                DC.L t_outp
                DC.B 1,0,0,0
                DC.B 'PART    '
                DC.L t_part
                DC.B 1,0,0,0
e_sp:           DC.B 'PATH    '
                DC.L t_path
                DC.B 1,0,0,0
e_p:            DC.B 'PEA     '
                DC.L t_pea
                DC.B 0,0,$48,$40
                DC.B 'REG     '
                DC.L t_reg
                DC.B 1,0,0,0
                DC.B 'REPEAT  '
                DC.L t_rept
                DC.B 1,0,0,0
                DC.B 'REPT    '
                DC.L t_rept
                DC.B 1,0,0,0
                DC.B 'RESET   '
                DC.L t_nop
                DC.B 0,0,$4E,$70
e_sr:           DC.B 'ROL     '
                DC.L t_asl
                DC.B 0,0,$E7,$58
                DC.B 'ROL.B   '
                DC.L t_asl
                DC.B 0,0,$E7,$18
                DC.B 'ROL.L   '
                DC.L t_asl
                DC.B 0,0,$E7,$98
                DC.B 'ROL.W   '
                DC.L t_asl
                DC.B 0,0,$E7,$58
                DC.B 'ROR     '
                DC.L t_asl
                DC.B 0,0,$E6,$58
                DC.B 'ROR.B   '
                DC.L t_asl
                DC.B 0,0,$E6,$18
                DC.B 'ROR.L   '
                DC.L t_asl
                DC.B 0,0,$E6,$98
                DC.B 'ROR.W   '
                DC.L t_asl
                DC.B 0,0,$E6,$58
                DC.B 'ROXL    '
                DC.L t_asl
                DC.B 0,0,$E5,$50
                DC.B 'ROXL.B  '
                DC.L t_asl
                DC.B 0,0,$E5,$10
                DC.B 'ROXL.L  '
                DC.L t_asl
                DC.B 0,0,$E5,$90
                DC.B 'ROXL.W  '
                DC.L t_asl
                DC.B 0,0,$E5,$50
                DC.B 'ROXR    '
                DC.L t_asl
                DC.B 0,0,$E4,$50
                DC.B 'ROXR.B  '
                DC.L t_asl
                DC.B 0,0,$E4,$10
                DC.B 'ROXR.L  '
                DC.L t_asl
                DC.B 0,0,$E4,$90
                DC.B 'ROXR.W  '
                DC.L t_asl
                DC.B 0,0,$E4,$50
                DC.B 'RS      '
                DC.L t_rsw
                DC.B 1,0,0,0
                DC.B 'RS.B    '
                DC.L t_rsb
                DC.B 1,0,0,0
                DC.B 'RS.L    '
                DC.L t_rsl
                DC.B 1,0,0,0
                DC.B 'RS.W    '
                DC.L t_rsw
                DC.B 1,0,0,0
                DC.B 'RSBSS   '
                DC.L t_rsbss
                DC.B 1,0,0,0
                DC.B 'RSEVEN  '
                DC.L t_rseven
                DC.B 1,0,0,0
                DC.B 'RSRESET '
                DC.L t_rsreset
                DC.B 1,0,0,0
                DC.B 'RSSET   '
                DC.L t_rsset
                DC.B 1,0,0,0
                DC.B 'RTE     '
                DC.L t_nop
                DC.B 0,0,$4E,$73
                DC.B 'RTR     '
                DC.L t_nop
                DC.B 0,0,$4E,$77
e_r:            DC.B 'RTS     '
                DC.L t_nop
                DC.B 0,0,$4E,$75
                DC.B 'SBCD    '
                DC.L t_abcd
                DC.B 0,0,$81,0
                DC.B 'SCC     '
                DC.L t_tst
                DC.B 0,0,$54,$C0
                DC.B 'SCC.B   '
                DC.L t_tst
                DC.B 0,0,$54,$C0
                DC.B 'SCS     '
                DC.L t_tst
                DC.B 0,0,$55,$C0
                DC.B 'SCS.B   '
                DC.L t_tst
                DC.B 0,0,$55,$C0
                DC.B 'SECTION '
                DC.L t_section
                DC.B 1,0,0,0
                DC.B 'SELECT  '
                DC.L t_switch
                DC.B 1,0,0,0
                DC.B 'SEQ     '
                DC.L t_tst
                DC.B 0,0,$57,$C0
                DC.B 'SEQ.B   '
                DC.L t_tst
                DC.B 0,0,$57,$C0
                DC.B 'SET     '
                DC.L t_set
                DC.B 1,0,0,0
                DC.B 'SF      '
                DC.L t_tst
                DC.B 0,0,$51,$C0
                DC.B 'SF.B    '
                DC.L t_tst
                DC.B 0,0,$51,$C0
                DC.B 'SGE     '
                DC.L t_tst
                DC.B 0,0,$5C,$C0
                DC.B 'SGE.B   '
                DC.L t_tst
                DC.B 0,0,$5C,$C0
                DC.B 'SGT     '
                DC.L t_tst
                DC.B 0,0,$5E,$C0
                DC.B 'SGT.B   '
                DC.L t_tst
                DC.B 0,0,$5E,$C0
                DC.B 'SHI     '
                DC.L t_tst
                DC.B 0,0,$52,$C0
                DC.B 'SHI.B   '
                DC.L t_tst
                DC.B 0,0,$52,$C0
                DC.B 'SHS     '
                DC.L t_tst
                DC.B 0,1,$54,$C0
                DC.B 'SHS.B   '
                DC.L t_tst
                DC.B 0,1,$54,$C0
                DC.B 'SLE     '
                DC.L t_tst
                DC.B 0,0,$5F,$C0
                DC.B 'SLE.B   '
                DC.L t_tst
                DC.B 0,0,$5F,$C0
                DC.B 'SLO     '
                DC.L t_tst
                DC.B 0,1,$55,$C0
                DC.B 'SLO.B   '
                DC.L t_tst
                DC.B 0,1,$55,$C0
                DC.B 'SLS     '
                DC.L t_tst
                DC.B 0,0,$53,$C0
                DC.B 'SLS.B   '
                DC.L t_tst
                DC.B 0,0,$53,$C0
                DC.B 'SLT     '
                DC.L t_tst
                DC.B 0,0,$5D,$C0
                DC.B 'SLT.B   '
                DC.L t_tst
                DC.B 0,0,$5D,$C0
                DC.B 'SMI     '
                DC.L t_tst
                DC.B 0,0,$5B,$C0
                DC.B 'SMI.B   '
                DC.L t_tst
                DC.B 0,0,$5B,$C0
                DC.B 'SNE     '
                DC.L t_tst
                DC.B 0,0,$56,$C0
                DC.B 'SNE.B   '
                DC.L t_tst
                DC.B 0,0,$56,$C0
                DC.B 'SPL     '
                DC.L t_tst
                DC.B 0,0,$5A,$C0
                DC.B 'SPL.B   '
                DC.L t_tst
                DC.B 0,0,$5A,$C0
                DC.B 'ST      '
                DC.L t_tst
                DC.B 0,0,$50,$C0
                DC.B 'ST.B    '
                DC.L t_tst
                DC.B 0,0,$50,$C0
                DC.B 'STOP    '
                DC.L t_stop
                DC.B 0,0,$4E,$72
e_s:            DC.B 'SUB     '
                DC.L t_add
                DC.B 0,0,$90,$40
                DC.B 'SUB.B   '
                DC.L t_addb
                DC.B 0,0,$90,0
                DC.B 'SUB.L   '
                DC.L t_add
                DC.B 0,0,$90,$80
                DC.B 'SUB.W   '
                DC.L t_add
                DC.B 0,0,$90,$40
                DC.B 'SUBA    '
                DC.L t_adda
                DC.B 0,$80,$90,$C0
                DC.B 'SUBA.L  '
                DC.L t_adda
                DC.B 0,$80,$91,$C0
                DC.B 'SUBA.W  '
                DC.L t_adda
                DC.B 0,$80,$90,$C0
                DC.B 'SUBI    '
                DC.L t_addi
                DC.B 0,0,4,$40
                DC.B 'SUBI.B  '
                DC.L t_addi
                DC.B 0,0,4,0
                DC.B 'SUBI.L  '
                DC.L t_addi
                DC.B 0,0,4,$80
                DC.B 'SUBI.W  '
                DC.L t_addi
                DC.B 0,0,4,$40
                DC.B 'SUBQ    '
                DC.L t_addq
                DC.B 0,0,$51,$40
                DC.B 'SUBQ.B  '
                DC.L t_addq
                DC.B 0,0,$51,0
                DC.B 'SUBQ.L  '
                DC.L t_addq
                DC.B 0,0,$51,$80
                DC.B 'SUBQ.W  '
                DC.L t_addq
                DC.B 0,0,$51,$40
                DC.B 'SUBX    '
                DC.L t_abcd
                DC.B 0,0,$91,$40
                DC.B 'SUBX.B  '
                DC.L t_abcd
                DC.B 0,0,$91,0
                DC.B 'SUBX.L  '
                DC.L t_abcd
                DC.B 0,0,$91,$80
                DC.B 'SUBX.W  '
                DC.L t_abcd
                DC.B 0,0,$91,$40
                DC.B 'SVC     '
                DC.L t_tst
                DC.B 0,0,$58,$C0
                DC.B 'SVC.B   '
                DC.L t_tst
                DC.B 0,0,$58,$C0
                DC.B 'SVS     '
                DC.L t_tst
                DC.B 0,0,$59,$C0
                DC.B 'SVS.B   '
                DC.L t_tst
                DC.B 0,0,$59,$C0
e_ss:           DC.B 'SWAP    '
                DC.L t_ext
                DC.B 0,0,$48,$40
                DC.B 'SWAP.L  '
                DC.L t_ext
                DC.B 0,0,$48,$40
                DC.B 'SWAP.W  '
                DC.L t_ext
                DC.B 0,0,$48,$40
                DC.B 'SWITCH  '
                DC.L t_switch
                DC.B 1,0,0,0
                DC.B 'TAS     '
                DC.L t_tst
                DC.B 0,0,$4A,$C0
                DC.B 'TAS.B   '
                DC.L t_tst
                DC.B 0,0,$4A,$C0
                DC.B 'TEXT    '
                DC.L t_text
                DC.B 1,1,0,0
e_st:           DC.B 'TRAP    '
                DC.L t_trap
                DC.B 0,0,$4E,$40
                DC.B 'TRAPV   '
                DC.L t_nop
                DC.B 0,0,$4E,$76
e_t:            DC.B 'TST     '
                DC.L t_tst
                DC.B 0,0,$4A,$40
                DC.B 'TST.B   '
                DC.L t_tst
                DC.B 0,0,$4A,0
                DC.B 'TST.L   '
                DC.L t_tst
                DC.B 0,0,$4A,$80
                DC.B 'TST.W   '
                DC.L t_tst
                DC.B 0,0,$4A,$40
                DC.B 'UNLINK  '
                DC.L t_unlk
                DC.B 0,0,$4E,$58
e_u:            DC.B 'UNLK    '
                DC.L t_unlk
                DC.B 0,0,$4E,$58
                DC.B 'XDEF    '
                DC.L t_global
                DC.B 1,0,0,0
e_x:            DC.B 'XOR     '
                DC.L t_eor
                DC.B 0,0,$B1,$40
                DC.B 'XOR.B   '
                DC.L t_eor
                DC.B 0,0,$B1,0
                DC.B 'XOR.L   '
                DC.L t_eor
                DC.B 0,0,$B1,$80
                DC.B 'XOR.W   '
                DC.L t_eor
                DC.B 0,0,$B1,$40
                DC.B 'XORI    '
                DC.L t_andi
                DC.B 0,0,$0A,$40
                DC.B 'XORI.B  '
                DC.L t_andi
                DC.B 0,0,$0A,0
                DC.B 'XORI.L  '
                DC.L t_andi
                DC.B 0,0,$0A,$80
                DC.B 'XORI.W  '
                DC.L t_andi
                DC.B 0,0,$0A,$40
                DC.B 'XREF    '
                DC.L t_global
                DC.B 1,0,0,0
                DC.B -1
                EVEN
                ENDPART

                PATH 'E:\TURBOASS.ALG\'
mac_trap_tab:   IBYTES 'MAC_TRAP.DAT' ;Tabellenstruktur für Trapmakros
                DS.B 4          ;Endekennung
                EVEN

                >PART 'Modul-Library'
************************************************************************
* Der Datenbereich                                                     *
************************************************************************
@modul_exit:    moveq   #0,D0           ;Normaler Abbruch
                jmp     s_assm_end2

@modul_error:   move.w  fhandle(A4),D0  ;Ist die Datei noch offen?
                beq.s   @modul_error1
                move.w  D0,-(SP)
                move.w  #$3E,-(SP)      ;dann
                jsr     do_trap_1       ;Fclose()
                addq.w  #4,SP
@modul_error1:  moveq   #-3,D0          ;Abbruch mit File error
                jmp     s_assm_end2

@fsel_input:    movem.l D1-A6,-(SP)
                tst.b   output_flag(A4) ;ein OUTPUT-Befehl im Programm?
                beq.s   @fsel_input1    ;Nein! =>
                bset    #31,D0          ;Bit für Filenamen-Extension setzen
@fsel_input1:   movea.l A0,A2           ;Header für Fsel_exinput
                lea     fpath_code(A4),A0
                lea     fname_code(A4),A1
                jsr     _fsel_input
                bmi.s   @modul_error    ;Fehler
                ext.l   D7
                move.l  D7,D0
                beq.s   @modul_exit     ;ABBRUCH
                movem.l (SP)+,D1-A6
                rts

@overwrite_file:movem.l D0-A6,-(SP)
                lea     fname_code(A4),A0
                jsr     s_write_file
                bmi.s   @modul_exit     ;ABBRUCH
                moveq   #1,D0
                bsr     _graf_mouse     ;Mauszeiger zu Diskette
                movem.l (SP)+,D0-A6
                rts

@fcreate:       movem.l D0-A6,-(SP)
                move.w  D0,-(SP)
                pea     fname_code(A4)
                move.w  #$3C,-(SP)
                jsr     do_trap_1       ;Fcreate()
                addq.l  #8,SP
                tst.w   D0
                bmi.s   @modul_error    ;Fehler beim Öffnen
                move.w  D0,fhandle(A4)
                movem.l (SP)+,D0-A6
                rts

@fopen:         movem.l D0-A6,-(SP)
                move.w  D0,-(SP)
                pea     fname_code(A4)
                move.w  #$3D,-(SP)
                jsr     do_trap_1       ;Fopen()
                addq.l  #8,SP
                tst.w   D0
                bmi     @modul_error    ;Fehler beim Öffnen
                move.w  D0,fhandle(A4)
                movem.l (SP)+,D0-A6
                rts

@fread:         movem.l D0-A6,-(SP)
                move.l  D0,D7
                move.w  fhandle(A4),D1
                beq     @modul_error    ;Fopen fehlt
                move.l  A0,-(SP)
                move.l  D7,-(SP)
                move.w  D1,-(SP)
                move.w  #$3F,-(SP)
                jsr     do_trap_1       ;Fread()
                lea     12(SP),SP
                cmp.l   D0,D7
                bne     @modul_error    ;Fehler beim Lesen
                movem.l (SP)+,D0-A6
                rts

@fwrite:        movem.l D0-A6,-(SP)
                move.l  D0,D7
                move.w  fhandle(A4),D1
                beq     @modul_error    ;Fopen fehlt
                move.l  A0,-(SP)
                move.l  D7,-(SP)
                move.w  D1,-(SP)
                move.w  #$40,-(SP)
                jsr     do_trap_1       ;Fwrite()
                lea     12(SP),SP
                lea     fname_code(A4),A1
                cmp.l   D0,D7
                beq.s   @fwrite1        ;alles ok!
                moveq   #-4,D0
                jmp     s_assm_end2     ;Disk ist voll!
@fwrite1:       movem.l (SP)+,D0-A6
                rts

@fclose:        movem.l D0-A6,-(SP)
                move.w  fhandle(A4),D0
                beq     @modul_error    ;Fopen fehlt
                move.w  D0,-(SP)
                move.w  #$3E,-(SP)
                jsr     do_trap_1       ;Fclose()
                addq.l  #4,SP
                movem.l (SP)+,D0-A6
                rts

@fdelete:       movem.l D0-A6,-(SP)
                pea     fname_code(A4)
                move.w  #$41,-(SP)
                jsr     do_trap_1       ;Fdelete()
                addq.l  #8,SP
                movem.l (SP)+,D0-A6
                rts

@trap_1:        jmp     do_trap_1

@dez_out:       movem.l D0-D7/A1-A6,-(SP)
                move.l  D1,D4
                move.l  D0,D1
                st      testwrd(A4)
                jsr     dezw_out
                sf      testwrd(A4)
                movem.l (SP)+,D0-D7/A1-A6
                rts

@hexbout:       movem.l D0-D7/A1-A6,-(SP)
                move.l  D0,D1
                bsr.s   @hex_out_init
                jsr     hexbout
                bsr.s   @hex_out_exit
                movem.l (SP)+,D0-D7/A1-A6
                rts

@hexwout:       movem.l D0-D7/A1-A6,-(SP)
                move.l  D0,D1
                bsr.s   @hex_out_init
                jsr     hexwout
                bsr.s   @hex_out_exit
                movem.l (SP)+,D0-D7/A1-A6
                rts

@hex_out_init:  st      testwrd(A4)
                move.w  small(A4),D7
                clr.w   small(A4)
                rts
@hex_out_exit:  sf      testwrd(A4)
                move.w  D7,small(A4)
                rts

@hexaout:       movem.l D0-D7/A1-A6,-(SP)
                move.l  D0,D1
                bsr.s   @hex_out_init
                jsr     hexaout
                bsr.s   @hex_out_exit
                movem.l (SP)+,D0-D7/A1-A6
                rts

@hexlout:       movem.l D0-D7/A1-A6,-(SP)
                move.l  D0,D1
                bsr.s   @hex_out_init
                jsr     hexlout
                bsr.s   @hex_out_exit
                movem.l (SP)+,D0-D7/A1-A6
                rts

@graf_mouse:    bra     _graf_mouse

@form_do:       bsr     _form_do
                bmi     @modul_exit     ;ABBRUCH mit UNDO
                rts

@bell:          movem.l D0-A6,-(SP)
                bsr     c_bell
                movem.l (SP)+,D0-A6
                rts

@hexlin:        movem.l D1-D2/A0,-(SP)  ;ASCII-Hexzahl nach D0 holen
                moveq   #0,D0
                moveq   #0,D2
@hexlin1:       move.b  (A0)+,D1
                beq.s   @hexlin4        ;Ende der Eingabe
                cmp.b   #' ',D1
                beq.s   @hexlin1        ;Spaces werden überlesen
                subi.b  #'0',D1
                bmi.s   @hexlin6        ;Fehler
                cmp.b   #10,D1
                blo.s   @hexlin3        ;Zeichen bereits ok
                subq.b  #7,D1
                bmi.s   @hexlin6        ;Fehler
@hexlin2:       cmp.b   #10,D1
                blo.s   @hexlin6        ;Fehler
                cmp.b   #15,D1
                bls.s   @hexlin3        ;Zeichen ok
                bclr    #5,D1           ;Kleinbuchstabe => Großbuchstabe
                bne.s   @hexlin2
                bra.s   @hexlin6        ;Fehler
@hexlin3:       moveq   #1,D2           ;ein gültiges Zeichen wurde gefunden
                lsl.l   #4,D0
                or.b    D1,D0
                bra.s   @hexlin1        ;und auf ein weiteres (Zeichen)
@hexlin4:       tst.b   D2              ;Z-Flag ist gesetzt, wenn keine Eingabe
                bra.s   @hexlin5
@hexlin6:       subq.l  #1,A0           ;Zeiger auf das fehlerhafte Zeichen
@hexlin7:       tst.b   (A0)
                beq.s   @hexlin8        ;Eingabe ab dem Fehler löschen
                move.b  #' ',(A0)+
                bra.s   @hexlin7
@hexlin8:       bsr     c_bell          ;Pling ...
                move    #8,CCR          ;Fehler !! N-Flag ist gesetzt
@hexlin5:       movem.l (SP)+,D1-D2/A0
                rts

@org_driver:    jmp     switch_org_drv
@ass_driver:    jmp     switch_my_drv
ganz_ans_ende:  jmp     anfang2
                OPT O-
                jmp     @org_driver
                jmp     @ass_driver
                jmp     @bell
                jmp     @form_do
                jmp     @graf_mouse
                jmp     @hexlin
                jmp     @hexlout
                jmp     @hexaout
                jmp     @hexwout        ;für die nachgeladenen Module
                jmp     @hexbout
                jmp     @dez_out
                jmp     @trap_1
                jmp     @fdelete
                jmp     @fclose
                jmp     @fwrite
                jmp     @fread
                jmp     @fopen
                jmp     @fcreate
                jmp     @overwrite_file
                jmp     @fsel_input
                ENDPART
                OPT W-
                BSS
varbase:        DS.W 0
                RSRESET
marker:         RS.W 10         ;10 Textmarker
text_pointer:   RS.W 1          ;Zeiger auf TEXT-Segment
data_pointer:   RS.W 1          ;Zeiger auf DATA-Segment
bss_pointer:    RS.W 1          ;Zeiger auf BSS-Segment
base_adreßreg:  RS.L 8          ;Adresse für BASE A0-A7
dcwbase:        RS.L 1          ;Adresse für BASE
dcbbase:        RS.L 1          ;Adresse für BASE
segm_adr:       RS.L 3          ;Startadressen der 3 Segmente
tabs:           RS.W 5          ;5 Tabulatoren
hexlen_flag:    RS.B 1          ;Flag für Kürzen von HEX und BIN
sp_flag:        RS.B 1          ;Flag für SP/A7
hex_flag:       RS.B 1          ;Upperflag für Hexzahlen
reg_flag:       RS.B 1          ;Upperflag für Register
pcodesize_flag: RS.B 1          ;Groß/Kleinflag für Pseudoopcodes
opcodesize_flag:RS.B 1          ;Groß/Kleinflag für Opcodes
ins_mode:       RS.B 1          ;Insert-Flag
last_char:      RS.B 1          ;Speicher für letztes Zeichen
upper_flag:     RS.B 1          ;Symbole groß, klein oder gemischt
s_suchzeichen:  RS.B 1          ;Suchzeichen
start_flag:     RS.B 1          ;Flag für Debugger
top_ptr:        RS.L 3          ;Speicher für die 3 Zeiger auf den Text
ass_stack:      RS.L 1          ;Defaultstack für Assembler
debugger_adr:   RS.L 1          ;Einsprungadresse in den Debugger
program_base:   RS.L 1          ;Startadresse des Quelltextes
program_top:    RS.L 1          ;zeigt auf das Ende des Quelltextes
program_max:    RS.L 1          ;zeigt auf das Maximum für Quelltextes
z_info_base:    RS.L 1          ;Startadresse der Zeileninfotabelle
z_info_top:     RS.L 1          ;zeigt auf Ende der Zeileninfotabelle
z_info_max:     RS.L 1          ;zeigt auf Maximum für Zeileninfotabelle
label_base:     RS.L 1          ;Startadresse der Labeltabelle
label_top:      RS.L 1          ;Endadresse der Labeltabelle
label_max:      RS.L 1          ;max. Adresse für Labeltabelle
comment_base:   RS.L 1          ;Startadresse der Comments
comment_top:    RS.L 1          ;zeigt hinter den letzten Comment
comment_max:    RS.L 1          ;max. Adresse für Comments
label_top_ind:  RS.W 1          ;höchster Index in Labeltabelle
max_index:      RS.W 1          ;maximaler Index für Tabelle
max_lines:      RS.W 1          ;maximale Zeile
memory_top:     RS.L 1          ;zeigt auf das Ende des Sourcecodespeichers
memory_base:    RS.L 1          ;zeigt auf den Anfang des Sourcespeichers
ass_adr:        RS.L 1          ;Startadresse des Zielcodes
end_adr:        RS.L 1          ;Endadresse des Zielcodes
merk200:        RS.L 1          ;200Hz-Timer
save_date:      RS.L 1          ;gemerktes Erstellungsdatum einer Datei
save_prot:      RS.B 8          ;gemerktes Passwort
asm_default:    RS.W 1          ;Offset für den akt.Defaultbutton
err_count:      RS.W 1          ;Zähler für Fehler
warn_count:     RS.W 1          ;Zähler für Warnings
dx_anzahl:      RS.W 1          ;Länge eines DX-Eintrags
dx_wert:        RS.W 1          ;Füllwert für DX
rs_count:       RS.L 1          ;Zähler für RS-Befehle
rs_merk:        RS.L 1          ;Größe des BSS-Bereichs bei RS.x
a_date:         RS.W 1          ;Variable für Datum
a_time:         RS.W 1          ;Variable für Zeit
error_pos:      RS.W 1          ;Fehlerposition
scr_z:          RS.W 1          ;ak. Zeile für Form-Input
letzte_zeile:   RS.W 1          ;Speicher für letzte Zeile
top_line:       RS.W 1          ;oberste Zeile des Programmausschnitts
save_pos:       RS.W 1          ;Speicher für Spalte
block_anf:      RS.W 1          ;Startzeile des Blocks
block_end:      RS.W 1          ;Endzeile des Blocks
block_pointer:  RS.L 3          ;Programmzeiger für Block
block_pointer2: RS.L 3          ;Programmzeiger für Blockende
rept_count:     RS.L 1          ;Zähler für REPT
rept_line:      RS.W 1          ;Zeile für REPT
rept_pointer:   RS.L 2          ;Zeiger für REPT
org_adr:        RS.L 1          ;Adresse für ORG-Befehl
default_but:    RS.W 1          ;Nummer des Default-Buttons
switch_adr:     RS.L 1          ;Adresse für SWITCH
switch_wert:    RS.W 1          ;Wert für SWITCH
switch_flag:    RS.B 1          ;Flag für SWITCH
switch_aktiv:   RS.B 1          ;<>0 => SWITCH ist in einer CASE-Struktur
reloc_fl:       RS.B 1          ;Flag für Relocinfo
if_flag:        RS.B 1          ;Flag für bedingte Assemblierung
opt_w_flag:     RS.B 1          ;Flag für OPT W
opt_o_flag:     RS.B 1          ;Flag für OPT O
opt_d_flag:     RS.B 1          ;Flag für OPT D,X
opt_p_flag:     RS.B 1          ;Flag für OPT P
optimize_flag:  RS.B 1          ;Flag für Sprunganpassung
block_fl:       RS.B 1          ;Flag für Block markieren
block_fl2:      RS.B 1          ;Flag für Block markieren
action_fl:      RS.B 1          ;Veränderung der Zeile
change_flag:    RS.B 1          ;Veränderung im Sourcetext
load_fl:        RS.B 1          ;Flag für Laden
entry_free:     RS.B 1          ;Flag, ob freie Einträge da sind
repl_flag:      RS.B 1          ;Flag, ob Remarksuche erlaubt
al_flag:        RS.B 1          ;Flag für ASCII-Ersetzen
macro_flag:     RS.B 1          ;Flag für get_ea-Routine
local_char:     RS.B 1          ;Erkennungszeichen für lokale Symbole
zei_count:      RS.W 1          ;Zeilenzähler
optim_flag:     RS.W 1          ;Flags für Optimierungsdialog
local_pointer:  RS.L 1          ;Zeiger auf Hilfstabelle
entry_pointer:  RS.L 1          ;Zeiger auf entry_buffer
tablen:         RS.W 1          ;Anzahl der Einträge in der Befehlstabelle
anz_zeilen:     RS.W 1          ;Anzahl der Programmzeilen
such_zeiger:    RS.W 3          ;Zeiger für ASCII-Suchen
such_sym:       RS.L 1          ;Zeiger für Label suchen
buff_rest:      RS.W 1          ;Rest im Disass-Buffer
mem_list:       RS.L 16         ;Liste der freien Speicherbereiche
save_top:       RS.W 1          ;für Slider: oberste dargestellte Zeile
save_anz:       RS.W 1          ;für Slider: Zeilenanzahl
zeingabe:       RS.B 300        ;Puffer für Eingabestring
zreserve:       RS.B 258        ;2.Puffer zum Codieren
dbuffer:        RS.W 2050       ;Puffer für Disk-Operationen
op_buffer:      RS.B 500        ;Puffer Opcode und Zeileninfo
merk_buff:      RS.B 258        ;Puffer für Control M
undo_buff:      RS.B 260        ;Puffer für UNDO (Zeile löschen)
such_puffer:    RS.B 30         ;Puffer für Patternstring
such_puffer2:   RS.B 30         ;Puffer für Patternstring(Ziel)
entry_buffer:   RS.L 64         ;Puffer für Eintragsadressen
tab_spalte:     RS.W 1          ;Tabulatorspalte für ASCII-Read
s_undo_zeile:   RS.W 1          ;Zeile für UNDO
cursor_spalte:  RS.W 1          ;Cursorspalte
s_zeile:        RS.W 1          ;Zeile für Cursor positionieren
s_spalte:       RS.W 1          ;Spalte "    "          "
s_offset:       RS.L 1          ;Rückgabe vom Debugger
s_offset_ptr:   RS.L 1          ;Zeiger auf Offsets (Debugger)
crunch_len:     RS.L 1          ;Länge der gecrunchten Tabelle
s_scroll_delay: RS.B 1          ;Flag für Scrollverzögerung
s_symbol_flag:  RS.B 1          ;Flag für Symboltabelle
s_left_right:   RS.B 1          ;Flag für linke/rechte Maustaste
s_such_flag:    RS.B 1          ;Flag für ASCII-Suchen
sym_flag:       RS.B 1          ;Flag für Suchtabelle
sym_typ:        RS.B 1          ;Symboltyp
debugger_da:    RS.B 1          ;Flag, ob Debugger resident im Speicher
                RSEVEN
mark_tab:       RS.B max_scrlines+1 ;Flag-Tabelle: <>0: Zeile ist markiert
lin_tab:        RS.B max_scrlines+1 ;Flag-Tabelle: <>0: Zeile ist dargestellt
                RSEVEN
lin_tab2:       RS.W max_scrlines+1 ;Tabelle der Zeilennummern für Screen

sdrv_akt_font:  RS.L 1          ;Zeiger auf den GEM-Font-Image
sdrv_cheight:   RS.W 1          ;Höhe eines Zeichens (16)
sdrv_maxcur_x:  RS.W 1          ;max. X-Position des Cursors (79)
sdrv_maxcur_y:  RS.W 1          ;max. Y-Position des Cursors (24)
sdrv_offset:    RS.W 1          ;Charakterzeilenbreite in Bytes (1280)
sdrv_planes:    RS.W 1          ;Anzahl der Planes (1)
sdrv_loffset:   RS.W 1          ;Offset von einer Zeile auf die nächste (80)
sdrv_poffset:   RS.W 1          ;Offset auf die nächste Plane (0)
sdrv_plnshift:  RS.W 1          ;Shift-Offset der Planes (1>1, 2>2, 4>3, 8>4)
sdrv_max_x:     RS.W 1          ;max.X-Koordinate (639)
sdrv_max_y:     RS.W 1          ;max.Y-Koordinate (399)
sdrv_scrbase:   RS.L 1          ;Bildschirmbasisadresse
sdrv_zanz:      RS.W 1          ;alte Konstante "anzahl_zeilen"
sdrv_tscradr:   RS.L 1          ;Adresse des Textscreens
sdrv_sml_font:  RS.L 1          ;Ptr auf den Fontheader vom 8x8-Font

curflag:        RS.W 1          ;<>0: Cursor an
zeile:          RS.W 1          ;Cursorzeile 0-24
spalte:         RS.W 1          ;Cursorspalte 0-79
screen_adr:     RS.L 1          ;Interne Bildschirmadresse
                RSEVEN

;Variablen des Tastaturtreibers
std_keytab:     RS.L 1          ;Zeiger auf Keyboardtabellen
shift_keytab:   RS.L 1
caps_keytab:    RS.L 1
iorec_IKBD:     RS.L 2
iorec_puffer:   RS.L 64
save_kbdvek:    RS.L 1
save_hz200:     RS.L 1
save_vbl:       RS.L 1

tmacro_pointer: RS.L 1          ;Zeigt auf aktives TMacro (0=kein TMacro)
tmacro_repeat:  RS.W 1          ;Anzahl der Wiederholungen einer Taste
                RS.L 1          ;muß Null sein!
tmacro_tab:     RS.L 1024       ;TMacro-Tabelle
tmacro_tab_end: RS.L 1          ;Ende der TMacro-Tabelle
tmacro_def_key: RS.L 1          ;<>0 => TMacro-Definition aktiv (MTastencode)
tmacro_def_adr: RS.L 1          ;akt.Pnt auf TMacro-Definiton
tmacro_def_flag:RS.B 1          ;<>0 => Wartet auf Taste bei Control-ESC

button_nr:      RS.W 1

timer_c_bitmap: RS.W 1
save_redef_key: RS.L 1
kbalt:          RS.B 1
kbstate:        RS.B 1
kbindex:        RS.B 1
stat_paket:     RS.B 7
maus_paket_1:   RS.B 5
maus_paket_2:   RS.B 3
zeit_paket:     RS.B 6
joydat0:        RS.B 3
joydat2:        RS.B 0
kbshift:        RS.B 1
kbd_r_key:      RS.B 1
kbd_r_verz:     RS.B 1
kbd_r_cnt:      RS.B 1
kbd_repeat_on:  RS.B 1
                RSEVEN
kbd_r_init:     RS.B 1
kbd_r_rate:     RS.B 1
language:       RS.W 1          ;Landesversion des TOS

mausx:          RS.W 1          ;Mausx (0-639)
mausy:          RS.W 1          ;Mausy (0-399)
mausxb:         RS.W 1          ;Mausx (0-79)
mausyb:         RS.W 1          ;Mausy (0-24)
maus_time:      RS.L 1          ;200Hz Zählerstand beim letzten Linksklick
maus_time2:     RS.L 1          ;200Hz Zählerstand für Dauerklick
sprite_no:      RS.W 1          ;Spritenummer (0=Pfeil,1=Diskette)
maus_flag:      RS.W 1          ;=0     => Doppelklick möglich (Taste n.gedrückt)
no_dklick:      RS.B 1          ;<>0 => Keine Doppelklickabfrage
mausdauer:      RS.B 1          ;Dauerklickflag für Blockdefinition
no_cursor:      RS.B 1          ;<>0 => Cursor bleibt aus
akt_maust:      RS.B 1          ;Maustasten für den 200Hz-Timer
maus_merk:      RS.B 1
maus_merk2:     RS.B 1
maustast:       RS.B 1          ;Bit 0-Rechts,B1-Links,B2-ReDop,B3-LiDop
mausprell:      RS.B 1          ;zum Entprellen
mausprell2:     RS.B 1
mausoff:        RS.B 1          ;<>0 => Kein Maussetzen durch den VBL
mausmove:       RS.B 1          ;<>0 => Maus wurde bewegt
mausflg:        RS.B 1          ;=0  => Maus nicht da
set_lock:       RS.B 1          ;<>0 => Cursorsetzen im VBL ist verboten
testwrd:        RS.B 1          ;<>0 => Ausgabe in Buffer, sonst Screen
time_h:         RS.B 1          ;Die Uhr (Stunden)
time_m:         RS.B 1          ;Die Uhr (Minuten)
time_s:         RS.B 1          ;Dir Uhr (Sekunden)
_dumpflg:       RS.B 1          ;=1 => Screendump auf Disk
_dumpflg2:      RS.B 1          ;=1 => Hardcopy aktiv
vbl_time_flag:  RS.B 1          ;=0 => Zeit wieder darstellen
passwort_flag:  RS.B 1          ;<>0 => bei Dialogen in EDIT nur '*'
no_protect:     RS.B 1          ;<>0 => Passwort ignorieren
bell_flag:      RS.B 1          ;<>0 => kein Pling bei neuem Label
hz200_time:     RS.W 1          ;200 Hertz-Zähler für die Zeit
mausf_time:     RS.L 1          ;Zeit für die dynamische Mausbeschleunigung
mausbuffer:     RS.W 35         ;Hintergrundspeicher der Maus
prt_mem:        RS.L 1          ;Anfangsadresse der Druckerdaten
prt_tab1:       RS.L 1          ;Anfangsadr der Steuerzeichentabelle
prt_tab2:       RS.L 1          ;Anfangsadr der Konvertierungstabelle
                RS.L 1          ;Dummy
partbuffer:     RS.L 1
                RS.L part_anz+1 ;Tabelle der Zeilennummern der Parts
part_flag:      RS.W 1
;Allgemeine Variablen
fpath_src:      RS.B 128        ;Buffer für ak. Sourcetext-Pfadnamen
fpath_code:     RS.B 128        ;Buffer für Zielcode-Pfadnamen
fpath_temp:     RS.B 128        ;Buffer für ak. Zulade-Pfadnamen, Datei löschen
fpath_sel:      RS.B 128        ;Buffer für Fileselector
fpath_inf:      RS.B 128        ;Buffer für INF-Datei
fname_src:      RS.B 20         ;Buffer für ak. Sourcetext-Filenamen
fname_code:     RS.B 20         ;Buffer für ak. Zielcode-Filenamen
fname_temp:     RS.B 20         ;Buffer für ak. Zulade-Filenamen
fname_sel:      RS.B 20         ;Buffer für Fileselector
dta_buffer:     RS.B 44         ;DTA-Buffer
s_exit_flag:    RS.B 1          ;Flag für Programmende
fhandle:        RS.W 1          ;Filehandle für I/O-Operationen
_regsav2:       RS.L 1
_regsav:        RS.L 16         ;Register bei do_trap_1
regs:           RS.L 15         ;Register bei Exeception
rega7:          RS.L 1
_xsr:           RS.W 1          ;Statusregister bei Exception
_pc:            RS.L 1          ;PC bei Exception
_xusp:          RS.L 1          ;USP bei Exception
_ssp:           RS.L 1          ;SSP bei Exception
spaced:         RS.B 80         ;Buffer für z.B. den Disassembler

bak_flag:       RS.B 1          ;Flag für Sicherheitskopie
autoconfig_flag:RS.B 1          ;Flag für Autokonfig
uhr_flag:       RS.B 1          ;<>0 => Uhr aus
skip_warn:      RS.B 1          ;Flag für Warnings überspringen
asc_show_flag:  RS.B 1          ;<>0 => ASCII-Anzeige aus
editor3_flag:   RS.B 1          ;Flags für Editor3 Menü
memory_free:    RS.L 1          ;Anzahl der freien Bytes
memory_gem:     RS.L 1          ;Anzahl der freigehaltenen Bytes
max_code_len:   RS.L 1          ;Anzahl Bytes für Zielcode
small:          RS.W 1          ;<>0 => Kleinschrift
col0:           RS.W 1          ;Hintergrundfarbe des Assemblers
col1:           RS.W 1          ;Vordergrundfarbe  "       "
conterm:        RS.W 1          ;Bit0=1 => Tastaturklick
screen_delay:   RS.L 1          ;Zeit für Screensaver
next_stime:     RS.L 1          ;nächste Umschaltzeit
screen_time:    RS.L 1          ;akt.Zeit des Screensavers
scr_color:      RS.W 2          ;Farben für den Screensaver

global:         RS.W 15
contrl:         RS.W 16
evnt_buff:      RS.W 8          ;für die Menüleiste
intin:          RS.W 128
intout:         RS.W 128
ptsin:          RS.W 0
addrin:         RS.W 128
redraw_buf:     RS.W 0          ;Buffer für Bildschirm-Redraw
ptsout:         RS.W 0
addrout:        RS.W 128
vdi_handle:     RS.W 1          ;Die Handle der Bildschirm-Workstation

menü_zeile:     RS.W 1          ;Koordinaten der Zeichenausgaben in der Menüleiste
menü_spalte:    RS.W 1
menü_save_zeile:RS.L 1          ;per MOVE.L Zeile & Spalte!!!
menü_save_a0:   RS.L 1          ;Zeiger auf den akt.Menütext
menü_save_a1:   RS.L 1          ;Zeiger auf Untermenüstrings
menü_save_titel:RS.W 1          ;gemerkter Menütitel
menü_save_d5:   RS.W 1          ;gemerkete Länge des Eintrags
menü_save_d3:   RS.B 1          ;gemerkter Underline-Status
menü_titel:     RS.W 1          ;akt.selektierter Menütitel
menü_stitel:    RS.W 1          ;akt.selektierter Menüuntertitel
menü_baum_adr:  RS.L 1          ;Adresse des akt.Menübaums
sel_menü_titel: RS.B 1          ;mit der linken Taste gewählter Eintrag
spez_flag:      RS.B 1

s_assm_stk:     RS.L 1          ;gemerkter Stackpointer beim Einsprung ins Moduls
scroll_action:  RS.B 1          ;<>0 => es wird gerade gescrollt!
scroll_action2: RS.B 1          ;<>0 => es wurde gerade gescrollt!
output_flag:    RS.B 1          ;<>0 => OUTPUT-Befehl im Programm
save_asc_code:  RS.B 1          ;gemerkter ASCII-Code der ASCII-Code-Anzeige
maustast_flag:  RS.B 1          ;Flag für rechte Maustaste bei Ende
act_pd:         RS.L 1          ;Aktueller Prozeß-Zeiger
dbg_basepage:   RS.L 1          ;Basepageadr des residenten Debuggers
kbshift_adr:    RS.L 1          ;Adresse der Kbshift-Variable
prn_buff:       RS.B 82         ;Buffer für Druckerausgabe
old_color:      RS.W 16         ;die geretteten Farben
old_critic:     RS.L 1          ;Originaler etv_critic-Vektor
old_stack:      RS.L 1          ;alter SSP
basepage:       RS.L 1          ;Basepage des Debuggers
save_data:      RS.B 1296       ;Kopie des Speicherbereichs von $8 bis $517
checksum_1:     RS.L 1
checksum_2:     RS.L 1
sektor_buf:     RS.B 512        ;Sektorbuffer für do_mediach
drv_chk_table:  RS.L 32         ;Seriennummern der Laufwerke
normal_font:    RS.B 4096       ;normaler gewandelter Font
block_font:     RS.B 4096       ;Font für Block markieren
hires:          RS.B $87FF      ;Für die Hires
                RSEVEN
                RS.L $0100      ;Stack
ende:           RS.L 0          ;Dummy fürs Ende
                RSBSS
                END
